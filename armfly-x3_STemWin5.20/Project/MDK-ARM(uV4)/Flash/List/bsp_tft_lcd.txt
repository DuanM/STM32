; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\bsp_tft_lcd.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=..\output\bsp_tft_lcd.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=870 -I..\..\User -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\User\fonts -I..\..\emWin\GUI_X -I..\..\emWin\Config -I..\..\emWin\Include -I..\..\emWin\emWinTask -I..\..\User\fatfs\src -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM4F -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -ID:\Keil_v4\ARM\RV31\INC -ID:\Keil_v4\ARM\CMSIS\Include -ID:\Keil_v4\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F4XX -DARM_MATH_CM4 -D__CC_ARM ..\..\User\bsp_stm32f4xx\src\bsp_tft_lcd.c]
                          THUMB

                          AREA ||i.Blend565||, CODE, READONLY, ALIGN=2

                  Blend565 PROC
;;;752    */
;;;753    uint16_t Blend565(uint16_t src, uint16_t dst, uint8_t alpha)
000000  b570              PUSH     {r4-r6,lr}
;;;754    {
000002  4603              MOV      r3,r0
;;;755    	uint32_t src2;
;;;756    	uint32_t dst2;
;;;757    
;;;758    	src2 = ((src << 16) |src) & 0x07E0F81F;
000004  ea434003          ORR      r0,r3,r3,LSL #16
000008  4e08              LDR      r6,|L1.44|
00000a  ea000406          AND      r4,r0,r6
;;;759    	dst2 = ((dst << 16) | dst) & 0x07E0F81F;
00000e  ea414001          ORR      r0,r1,r1,LSL #16
000012  ea000506          AND      r5,r0,r6
;;;760    	dst2 = ((((dst2 - src2) * alpha) >> 5) + src2) & 0x07E0F81F;
000016  1b28              SUBS     r0,r5,r4
000018  4350              MULS     r0,r2,r0
00001a  eb041050          ADD      r0,r4,r0,LSR #5
00001e  ea000506          AND      r5,r0,r6
;;;761    	return (dst2 >> 16) | dst2;
000022  ea454015          ORR      r0,r5,r5,LSR #16
000026  b280              UXTH     r0,r0
;;;762    }
000028  bd70              POP      {r4-r6,pc}
;;;763    
                          ENDP

00002a  0000              DCW      0x0000
                  |L1.44|
                          DCD      0x07e0f81f

                          AREA ||i.Bus_Delay||, CODE, READONLY, ALIGN=1

                  Bus_Delay PROC
;;;58     */
;;;59     static void Bus_Delay(__IO uint32_t nCount)
000000  b501              PUSH     {r0,lr}
;;;60     {
;;;61       for(; nCount != 0; nCount--);
000002  e002              B        |L2.10|
                  |L2.4|
000004  9800              LDR      r0,[sp,#0]
000006  1e40              SUBS     r0,r0,#1
000008  9000              STR      r0,[sp,#0]
                  |L2.10|
00000a  9800              LDR      r0,[sp,#0]
00000c  2800              CMP      r0,#0
00000e  d1f9              BNE      |L2.4|
;;;62     }
000010  bd08              POP      {r3,pc}
;;;63     
                          ENDP


                          AREA ||i.LCD_ClrScr||, CODE, READONLY, ALIGN=2

                  LCD_ClrScr PROC
;;;225    */
;;;226    void LCD_ClrScr(uint16_t _usColor)
000000  b510              PUSH     {r4,lr}
;;;227    {
000002  4604              MOV      r4,r0
;;;228    	if (g_ChipID == IC_8875)	/* RA8875 分支 */
000004  4805              LDR      r0,|L3.28|
000006  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000008  2875              CMP      r0,#0x75
00000a  d103              BNE      |L3.20|
;;;229    	{
;;;230    		RA8875_ClrScr(_usColor);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       RA8875_ClrScr
000012  e002              B        |L3.26|
                  |L3.20|
;;;231    	}
;;;232    	else	/* 5420，4001，61509 分支 */
;;;233    	{
;;;234    		SPFD5420_ClrScr(_usColor);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       SPFD5420_ClrScr
                  |L3.26|
;;;235    	}
;;;236    }
00001a  bd10              POP      {r4,pc}
;;;237    
                          ENDP

                  |L3.28|
                          DCD      g_ChipID

                          AREA ||i.LCD_CtrlLinesConfig||, CODE, READONLY, ALIGN=2

                  LCD_CtrlLinesConfig PROC
;;;1415   */
;;;1416   static void LCD_CtrlLinesConfig(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;1417   {
;;;1418   	GPIO_InitTypeDef GPIO_InitStructure;
;;;1419   
;;;1420   	/* 使能FSMC时钟 */
;;;1421   	RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC, ENABLE);
000002  2101              MOVS     r1,#1
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       RCC_AHB3PeriphClockCmd
;;;1422   
;;;1423   	/* 使能 GPIO时钟 */
;;;1424   	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD | RCC_AHB1Periph_GPIOE, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  2018              MOVS     r0,#0x18
00000e  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;1425   
;;;1426   	/* 设置 PD.00(D2), PD.01(D3), PD.04(NOE), PD.05(NWE), PD.08(D13), PD.09(D14),
;;;1427   	 PD.10(D15), PD.14(D0), PD.15(D1) 为复用推挽输出 */
;;;1428   
;;;1429   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource0, GPIO_AF_FSMC);
000012  220c              MOVS     r2,#0xc
000014  2100              MOVS     r1,#0
000016  4844              LDR      r0,|L4.296|
000018  f7fffffe          BL       GPIO_PinAFConfig
;;;1430   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource1, GPIO_AF_FSMC);
00001c  220c              MOVS     r2,#0xc
00001e  2101              MOVS     r1,#1
000020  4841              LDR      r0,|L4.296|
000022  f7fffffe          BL       GPIO_PinAFConfig
;;;1431   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource4, GPIO_AF_FSMC);
000026  220c              MOVS     r2,#0xc
000028  2104              MOVS     r1,#4
00002a  483f              LDR      r0,|L4.296|
00002c  f7fffffe          BL       GPIO_PinAFConfig
;;;1432   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource5, GPIO_AF_FSMC);
000030  220c              MOVS     r2,#0xc
000032  2105              MOVS     r1,#5
000034  483c              LDR      r0,|L4.296|
000036  f7fffffe          BL       GPIO_PinAFConfig
;;;1433   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource8, GPIO_AF_FSMC);
00003a  220c              MOVS     r2,#0xc
00003c  2108              MOVS     r1,#8
00003e  483a              LDR      r0,|L4.296|
000040  f7fffffe          BL       GPIO_PinAFConfig
;;;1434   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource9, GPIO_AF_FSMC);
000044  220c              MOVS     r2,#0xc
000046  2109              MOVS     r1,#9
000048  4837              LDR      r0,|L4.296|
00004a  f7fffffe          BL       GPIO_PinAFConfig
;;;1435   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource10, GPIO_AF_FSMC);
00004e  220c              MOVS     r2,#0xc
000050  210a              MOVS     r1,#0xa
000052  4835              LDR      r0,|L4.296|
000054  f7fffffe          BL       GPIO_PinAFConfig
;;;1436   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource14, GPIO_AF_FSMC);
000058  220c              MOVS     r2,#0xc
00005a  210e              MOVS     r1,#0xe
00005c  4832              LDR      r0,|L4.296|
00005e  f7fffffe          BL       GPIO_PinAFConfig
;;;1437   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource15, GPIO_AF_FSMC);
000062  220c              MOVS     r2,#0xc
000064  210f              MOVS     r1,#0xf
000066  4830              LDR      r0,|L4.296|
000068  f7fffffe          BL       GPIO_PinAFConfig
;;;1438   
;;;1439   	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_4 | GPIO_Pin_5 |
00006c  f24c7033          MOV      r0,#0xc733
000070  9000              STR      r0,[sp,#0]
;;;1440   	                            GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_14 |
;;;1441   	                            GPIO_Pin_15;
;;;1442   	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000072  2002              MOVS     r0,#2
000074  f88d0004          STRB     r0,[sp,#4]
;;;1443   	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
000078  2003              MOVS     r0,#3
00007a  f88d0005          STRB     r0,[sp,#5]
;;;1444   	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00007e  2000              MOVS     r0,#0
000080  f88d0006          STRB     r0,[sp,#6]
;;;1445   	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
000084  f88d0007          STRB     r0,[sp,#7]
;;;1446   	GPIO_Init(GPIOD, &GPIO_InitStructure);
000088  4669              MOV      r1,sp
00008a  4827              LDR      r0,|L4.296|
00008c  f7fffffe          BL       GPIO_Init
;;;1447   
;;;1448   	/* 设置 PE.07(D4), PE.08(D5), PE.09(D6), PE.10(D7), PE.11(D8), PE.12(D9), PE.13(D10),
;;;1449   	 PE.14(D11), PE.15(D12) 为复用推挽输出 */
;;;1450   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource7 , GPIO_AF_FSMC);
000090  220c              MOVS     r2,#0xc
000092  2107              MOVS     r1,#7
000094  4825              LDR      r0,|L4.300|
000096  f7fffffe          BL       GPIO_PinAFConfig
;;;1451   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource8 , GPIO_AF_FSMC);
00009a  220c              MOVS     r2,#0xc
00009c  2108              MOVS     r1,#8
00009e  4823              LDR      r0,|L4.300|
0000a0  f7fffffe          BL       GPIO_PinAFConfig
;;;1452   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource9 , GPIO_AF_FSMC);
0000a4  220c              MOVS     r2,#0xc
0000a6  2109              MOVS     r1,#9
0000a8  4820              LDR      r0,|L4.300|
0000aa  f7fffffe          BL       GPIO_PinAFConfig
;;;1453   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource10 , GPIO_AF_FSMC);
0000ae  220c              MOVS     r2,#0xc
0000b0  210a              MOVS     r1,#0xa
0000b2  481e              LDR      r0,|L4.300|
0000b4  f7fffffe          BL       GPIO_PinAFConfig
;;;1454   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource11 , GPIO_AF_FSMC);
0000b8  220c              MOVS     r2,#0xc
0000ba  210b              MOVS     r1,#0xb
0000bc  481b              LDR      r0,|L4.300|
0000be  f7fffffe          BL       GPIO_PinAFConfig
;;;1455   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource12 , GPIO_AF_FSMC);
0000c2  220c              MOVS     r2,#0xc
0000c4  4611              MOV      r1,r2
0000c6  4819              LDR      r0,|L4.300|
0000c8  f7fffffe          BL       GPIO_PinAFConfig
;;;1456   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource13 , GPIO_AF_FSMC);
0000cc  220c              MOVS     r2,#0xc
0000ce  210d              MOVS     r1,#0xd
0000d0  4816              LDR      r0,|L4.300|
0000d2  f7fffffe          BL       GPIO_PinAFConfig
;;;1457   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource14 , GPIO_AF_FSMC);
0000d6  220c              MOVS     r2,#0xc
0000d8  210e              MOVS     r1,#0xe
0000da  4814              LDR      r0,|L4.300|
0000dc  f7fffffe          BL       GPIO_PinAFConfig
;;;1458   	GPIO_PinAFConfig(GPIOE, GPIO_PinSource15 , GPIO_AF_FSMC);
0000e0  220c              MOVS     r2,#0xc
0000e2  210f              MOVS     r1,#0xf
0000e4  4811              LDR      r0,|L4.300|
0000e6  f7fffffe          BL       GPIO_PinAFConfig
;;;1459   
;;;1460   	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 |
0000ea  f64f7080          MOV      r0,#0xff80
0000ee  9000              STR      r0,[sp,#0]
;;;1461   	                            GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 |
;;;1462   	                            GPIO_Pin_15;
;;;1463   	GPIO_Init(GPIOE, &GPIO_InitStructure);
0000f0  4669              MOV      r1,sp
0000f2  480e              LDR      r0,|L4.300|
0000f4  f7fffffe          BL       GPIO_Init
;;;1464   
;;;1465   	/* 设置 PD.13(A18 (RS))  为复用推挽输出 */
;;;1466   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource13, GPIO_AF_FSMC);
0000f8  220c              MOVS     r2,#0xc
0000fa  210d              MOVS     r1,#0xd
0000fc  480a              LDR      r0,|L4.296|
0000fe  f7fffffe          BL       GPIO_PinAFConfig
;;;1467   
;;;1468   	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
000102  f44f5000          MOV      r0,#0x2000
000106  9000              STR      r0,[sp,#0]
;;;1469   	GPIO_Init(GPIOD, &GPIO_InitStructure);
000108  4669              MOV      r1,sp
00010a  4807              LDR      r0,|L4.296|
00010c  f7fffffe          BL       GPIO_Init
;;;1470   
;;;1471   	/* 设置 PD.7(NE1 (LCD/CS)) 为复用推挽输出 */
;;;1472   	GPIO_PinAFConfig(GPIOD, GPIO_PinSource7, GPIO_AF_FSMC);
000110  220c              MOVS     r2,#0xc
000112  2107              MOVS     r1,#7
000114  4804              LDR      r0,|L4.296|
000116  f7fffffe          BL       GPIO_PinAFConfig
;;;1473   
;;;1474   	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;
00011a  2080              MOVS     r0,#0x80
00011c  9000              STR      r0,[sp,#0]
;;;1475   	GPIO_Init(GPIOD, &GPIO_InitStructure);
00011e  4669              MOV      r1,sp
000120  4801              LDR      r0,|L4.296|
000122  f7fffffe          BL       GPIO_Init
;;;1476   }
000126  bd1c              POP      {r2-r4,pc}
;;;1477   
                          ENDP

                  |L4.296|
                          DCD      0x40020c00
                  |L4.300|
                          DCD      0x40021000

                          AREA ||i.LCD_DispControl||, CODE, READONLY, ALIGN=1

                  LCD_DispControl PROC
;;;1270   */
;;;1271   void LCD_DispControl(void *_pControl)
000000  b570              PUSH     {r4-r6,lr}
;;;1272   {
000002  4604              MOV      r4,r0
;;;1273   	uint8_t id;
;;;1274   
;;;1275   	id = *(uint8_t *)_pControl;	/* 读取ID */
000004  7825              LDRB     r5,[r4,#0]
;;;1276   
;;;1277   	switch (id)
000006  2d08              CMP      r5,#8
000008  d21e              BCS      |L5.72|
00000a  e8dff005          TBB      [pc,r5]
00000e  1d04              DCB      0x1d,0x04
000010  05090d11          DCB      0x05,0x09,0x0d,0x11
000014  1519              DCB      0x15,0x19
;;;1278   	{
;;;1279   		case ID_ICON:
;;;1280   			//void LCD_DrawIcon(const ICON_T *_tIcon, FONT_T *_tFont, uint8_t _ucFocusMode);
;;;1281   			break;
000016  e017              B        |L5.72|
;;;1282   
;;;1283   		case ID_WIN:
;;;1284   			LCD_DrawWin((WIN_T *)_pControl);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       LCD_DrawWin
;;;1285   			break;
00001e  e013              B        |L5.72|
;;;1286   
;;;1287   		case ID_LABEL:
;;;1288   			LCD_DrawLabel((LABEL_T *)_pControl);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       LCD_DrawLabel
;;;1289   			break;
000026  e00f              B        |L5.72|
;;;1290   
;;;1291   		case ID_BUTTON:
;;;1292   			LCD_DrawButton((BUTTON_T *)_pControl);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       LCD_DrawButton
;;;1293   			break;
00002e  e00b              B        |L5.72|
;;;1294   
;;;1295   		case ID_CHECK:
;;;1296   			LCD_DrawCheckBox((CHECK_T *)_pControl);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       LCD_DrawCheckBox
;;;1297   			break;
000036  e007              B        |L5.72|
;;;1298   
;;;1299   		case ID_EDIT:
;;;1300   			LCD_DrawEdit((EDIT_T *)_pControl);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       LCD_DrawEdit
;;;1301   			break;
00003e  e003              B        |L5.72|
;;;1302   
;;;1303   		case ID_GROUP:
;;;1304   			LCD_DrawGroupBox((GROUP_T *)_pControl);
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       LCD_DrawGroupBox
;;;1305   			break;
000046  bf00              NOP      
                  |L5.72|
000048  bf00              NOP                            ;1281
;;;1306   	}
;;;1307   }
00004a  bd70              POP      {r4-r6,pc}
;;;1308   
                          ENDP


                          AREA ||i.LCD_DispOff||, CODE, READONLY, ALIGN=2

                  LCD_DispOff PROC
;;;205    */
;;;206    void LCD_DispOff(void)
000000  b510              PUSH     {r4,lr}
;;;207    {
;;;208    	if (g_ChipID == IC_8875)
000002  4805              LDR      r0,|L6.24|
000004  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000006  2875              CMP      r0,#0x75
000008  d102              BNE      |L6.16|
;;;209    	{
;;;210    		RA8875_DispOff();
00000a  f7fffffe          BL       RA8875_DispOff
00000e  e001              B        |L6.20|
                  |L6.16|
;;;211    	}
;;;212    	else	/* 61509, 5420, 4001 */
;;;213    	{
;;;214    		SPFD5420_DispOff();
000010  f7fffffe          BL       SPFD5420_DispOff
                  |L6.20|
;;;215    	}
;;;216    }
000014  bd10              POP      {r4,pc}
;;;217    
                          ENDP

000016  0000              DCW      0x0000
                  |L6.24|
                          DCD      g_ChipID

                          AREA ||i.LCD_DispOn||, CODE, READONLY, ALIGN=2

                  LCD_DispOn PROC
;;;185    */
;;;186    void LCD_DispOn(void)
000000  b510              PUSH     {r4,lr}
;;;187    {
;;;188    	if (g_ChipID == IC_8875)
000002  4805              LDR      r0,|L7.24|
000004  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000006  2875              CMP      r0,#0x75
000008  d102              BNE      |L7.16|
;;;189    	{
;;;190    		RA8875_DispOn();
00000a  f7fffffe          BL       RA8875_DispOn
00000e  e001              B        |L7.20|
                  |L7.16|
;;;191    	}
;;;192    	else	/* 61509, 5420, 4001 */
;;;193    	{
;;;194    		SPFD5420_DispOn();
000010  f7fffffe          BL       SPFD5420_DispOn
                  |L7.20|
;;;195    	}
;;;196    }
000014  bd10              POP      {r4,pc}
;;;197    
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      g_ChipID

                          AREA ||i.LCD_DispStr||, CODE, READONLY, ALIGN=2

                  LCD_DispStr PROC
;;;249    */
;;;250    void LCD_DispStr(uint16_t _usX, uint16_t _usY, char *_ptr, FONT_T *_tFont)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;251    {
000004  b09b              SUB      sp,sp,#0x6c
000006  4691              MOV      r9,r2
000008  461f              MOV      r7,r3
;;;252    	uint32_t i;
;;;253    	uint8_t code1;
;;;254    	uint8_t code2;
;;;255    	uint32_t address;
;;;256    	uint8_t buf[24 * 24 / 8];	/* 最大支持24点阵汉字 */
;;;257    	uint8_t width;
;;;258    	uint16_t m;
;;;259    	uint8_t font_width,font_height, font_bytes;
;;;260    	uint16_t x, y;
;;;261    	const uint8_t *pAscDot;
;;;262    
;;;263    #ifdef USE_SMALL_FONT	
;;;264    	const uint8_t *pHzDot;
;;;265    #else	
;;;266    	uint32_t AddrHZK;
;;;267    #endif	
;;;268    
;;;269    	/* 如果字体结构为空指针，则缺省按16点阵 */
;;;270    	if (_tFont->FontCode == FC_ST_12)
00000a  8838              LDRH     r0,[r7,#0]
00000c  2801              CMP      r0,#1
00000e  d107              BNE      |L8.32|
;;;271    	{
;;;272    		font_height = 12;
000010  200c              MOVS     r0,#0xc
000012  9005              STR      r0,[sp,#0x14]
;;;273    		font_width = 12;
000014  4680              MOV      r8,r0
;;;274    		font_bytes = 24;
000016  2418              MOVS     r4,#0x18
;;;275    		pAscDot = g_Ascii12;
000018  4855              LDR      r0,|L8.368|
00001a  9002              STR      r0,[sp,#8]
;;;276    		
;;;277    	#ifdef USE_SMALL_FONT		
;;;278    		pHzDot = g_Hz12;		
00001c  4e55              LDR      r6,|L8.372|
00001e  e006              B        |L8.46|
                  |L8.32|
;;;279    	#else
;;;280    		AddrHZK = HZK12_ADDR;
;;;281    	#endif		
;;;282    	}
;;;283    	else
;;;284    	{
;;;285    		/* 缺省是16点阵 */
;;;286    		font_height = 16;
000020  2010              MOVS     r0,#0x10
000022  9005              STR      r0,[sp,#0x14]
;;;287    		font_width = 16;
000024  4680              MOV      r8,r0
;;;288    		font_bytes = 32;
000026  2420              MOVS     r4,#0x20
;;;289    		pAscDot = g_Ascii16;
000028  4853              LDR      r0,|L8.376|
00002a  9002              STR      r0,[sp,#8]
;;;290    		
;;;291    	#ifdef USE_SMALL_FONT	
;;;292    		pHzDot = g_Hz16;	
00002c  4e53              LDR      r6,|L8.380|
                  |L8.46|
;;;293    	#else
;;;294    		AddrHZK = HZK16_ADDR;
;;;295    	#endif		
;;;296    	}
;;;297    
;;;298    	/* 开始循环处理字符 */
;;;299    	while (*_ptr != 0)
00002e  e096              B        |L8.350|
                  |L8.48|
;;;300    	{
;;;301    		code1 = *_ptr;	/* 读取字符串数据， 该数据可能是ascii代码，也可能汉字代码的高字节 */
000030  f8990000          LDRB     r0,[r9,#0]
000034  901a              STR      r0,[sp,#0x68]
;;;302    		if (code1 < 0x80)
000036  981a              LDR      r0,[sp,#0x68]
000038  2880              CMP      r0,#0x80
00003a  da16              BGE      |L8.106|
;;;303    		{
;;;304    			/* 将ascii字符点阵复制到buf */
;;;305    			memcpy(buf, &pAscDot[code1 * (font_bytes / 2)], (font_bytes / 2));
00003c  9401              STR      r4,[sp,#4]
00003e  eb0470d4          ADD      r0,r4,r4,LSR #31
000042  ea4f0c60          ASR      r12,r0,#1
000046  9400              STR      r4,[sp,#0]
000048  9b1a              LDR      r3,[sp,#0x68]
00004a  9802              LDR      r0,[sp,#8]
00004c  fb03010c          MLA      r1,r3,r12,r0
000050  eb0470d4          ADD      r0,r4,r4,LSR #31
000054  1042              ASRS     r2,r0,#1
000056  a807              ADD      r0,sp,#0x1c
000058  f7fffffe          BL       __aeabi_memcpy
;;;306    			width = font_width / 2;
00005c  4640              MOV      r0,r8
00005e  eb0871d0          ADD      r1,r8,r0,LSR #31
000062  f3c10147          UBFX     r1,r1,#1,#8
000066  9106              STR      r1,[sp,#0x18]
000068  e032              B        |L8.208|
                  |L8.106|
;;;307    		}
;;;308    		else
;;;309    		{
;;;310    			code2 = *++_ptr;
00006a  f1090001          ADD      r0,r9,#1
00006e  4681              MOV      r9,r0
000070  7800              LDRB     r0,[r0,#0]
000072  9019              STR      r0,[sp,#0x64]
;;;311    			if (code2 == 0)
000074  9819              LDR      r0,[sp,#0x64]
000076  b900              CBNZ     r0,|L8.122|
;;;312    			{
;;;313    				break;
000078  e076              B        |L8.360|
                  |L8.122|
;;;314    			}
;;;315    
;;;316    			/* 计算16点阵汉字点阵地址
;;;317    				ADDRESS = [(code1-0xa1) * 94 + (code2-0xa1)] * 32
;;;318    				;
;;;319    			*/
;;;320    			#ifdef USE_SMALL_FONT
;;;321    				m = 0;
00007a  f04f0a00          MOV      r10,#0
;;;322    				while(1)
00007e  e023              B        |L8.200|
                  |L8.128|
;;;323    				{
;;;324    					address = m * (font_bytes + 2);
000080  1ca0              ADDS     r0,r4,#2
000082  fb0af500          MUL      r5,r10,r0
;;;325    					m++;
000086  f10a0001          ADD      r0,r10,#1
00008a  fa1ffa80          UXTH     r10,r0
;;;326    					if ((code1 == pHzDot[address + 0]) && (code2 == pHzDot[address + 1]))
00008e  5d71              LDRB     r1,[r6,r5]
000090  981a              LDR      r0,[sp,#0x68]
000092  4281              CMP      r1,r0
000094  d10b              BNE      |L8.174|
000096  1c68              ADDS     r0,r5,#1
000098  5c31              LDRB     r1,[r6,r0]
00009a  9819              LDR      r0,[sp,#0x64]
00009c  4281              CMP      r1,r0
00009e  d106              BNE      |L8.174|
;;;327    					{
;;;328    						address += 2;
0000a0  1cad              ADDS     r5,r5,#2
;;;329    						memcpy(buf, &pHzDot[address], font_bytes);
0000a2  1971              ADDS     r1,r6,r5
0000a4  4622              MOV      r2,r4
0000a6  a807              ADD      r0,sp,#0x1c
0000a8  f7fffffe          BL       __aeabi_memcpy
;;;330    						break;
0000ac  e00d              B        |L8.202|
                  |L8.174|
;;;331    					}
;;;332    					else if ((pHzDot[address + 0] == 0xFF) && (pHzDot[address + 1] == 0xFF))
0000ae  5d70              LDRB     r0,[r6,r5]
0000b0  28ff              CMP      r0,#0xff
0000b2  d109              BNE      |L8.200|
0000b4  1c68              ADDS     r0,r5,#1
0000b6  5c30              LDRB     r0,[r6,r0]
0000b8  28ff              CMP      r0,#0xff
0000ba  d105              BNE      |L8.200|
;;;333    					{
;;;334    						/* 字库搜索完毕，未找到，则填充全FF */
;;;335    						memset(buf, 0xFF, font_bytes);
0000bc  22ff              MOVS     r2,#0xff
0000be  4621              MOV      r1,r4
0000c0  a807              ADD      r0,sp,#0x1c
0000c2  f7fffffe          BL       __aeabi_memset
;;;336    						break;
0000c6  e000              B        |L8.202|
                  |L8.200|
0000c8  e7da              B        |L8.128|
                  |L8.202|
0000ca  bf00              NOP                            ;330
;;;337    					}
;;;338    				}
;;;339    			#else	/* 用全字库 */
;;;340    				/* 此处需要根据字库文件存放位置进行修改 */
;;;341    				if (code1 >=0xA1 && code1 <= 0xA9 && code2 >=0xA1)
;;;342    				{
;;;343    					address = ((code1 - 0xA1) * 94 + (code2 - 0xA1)) * font_bytes + AddrHZK;
;;;344    				}
;;;345    				else if (code1 >=0xB0 && code1 <= 0xF7 && code2 >=0xA1)
;;;346    				{
;;;347    					address = ((code1 - 0xB0) * 94 + (code2 - 0xA1) + 846) * font_bytes + AddrHZK;
;;;348    				}
;;;349    				memcpy(buf, (const uint8_t *)address, font_bytes);
;;;350    			#endif
;;;351    
;;;352    				width = font_width;
0000cc  f8cd8018          STR      r8,[sp,#0x18]
                  |L8.208|
;;;353    		}
;;;354    
;;;355    		y = _usY;
0000d0  981c              LDR      r0,[sp,#0x70]
0000d2  9003              STR      r0,[sp,#0xc]
;;;356    		/* 开始刷LCD */
;;;357    		for (m = 0; m < font_height; m++)	/* 字符高度 */
0000d4  f04f0a00          MOV      r10,#0
0000d8  e035              B        |L8.326|
                  |L8.218|
;;;358    		{
;;;359    			x = _usX;
0000da  981b              LDR      r0,[sp,#0x6c]
0000dc  9004              STR      r0,[sp,#0x10]
;;;360    			for (i = 0; i < width; i++)	/* 字符宽度 */
0000de  f04f0b00          MOV      r11,#0
0000e2  e025              B        |L8.304|
                  |L8.228|
;;;361    			{
;;;362    				if ((buf[m * ((2 * width) / font_width) + i / 8] & (0x80 >> (i % 8 ))) != 0x00)
0000e4  9806              LDR      r0,[sp,#0x18]
0000e6  0040              LSLS     r0,r0,#1
0000e8  fb90f0f8          SDIV     r0,r0,r8
0000ec  fb00f00a          MUL      r0,r0,r10
0000f0  eb0000db          ADD      r0,r0,r11,LSR #3
0000f4  a907              ADD      r1,sp,#0x1c
0000f6  5c08              LDRB     r0,[r1,r0]
0000f8  f00b0207          AND      r2,r11,#7
0000fc  2180              MOVS     r1,#0x80
0000fe  4111              ASRS     r1,r1,r2
000100  4208              TST      r0,r1
000102  d005              BEQ      |L8.272|
;;;363    				{
;;;364    					LCD_PutPixel(x, y, _tFont->FrontColor);	/* 设置像素颜色为文字色 */
000104  887a              LDRH     r2,[r7,#2]
000106  e9dd1003          LDRD     r1,r0,[sp,#0xc]
00010a  f7fffffe          BL       LCD_PutPixel
00010e  e009              B        |L8.292|
                  |L8.272|
;;;365    				}
;;;366    				else
;;;367    				{
;;;368    					if (_tFont->BackColor != CL_MASK)	/* 透明色 */
000110  88b8              LDRH     r0,[r7,#4]
000112  f5a04119          SUB      r1,r0,#0x9900
000116  3999              SUBS     r1,r1,#0x99
000118  d004              BEQ      |L8.292|
;;;369    					{
;;;370    						LCD_PutPixel(x, y, _tFont->BackColor);	/* 设置像素颜色为文字背景色 */
00011a  88ba              LDRH     r2,[r7,#4]
00011c  e9dd1003          LDRD     r1,r0,[sp,#0xc]
000120  f7fffffe          BL       LCD_PutPixel
                  |L8.292|
;;;371    					}
;;;372    				}
;;;373    
;;;374    				x++;
000124  9804              LDR      r0,[sp,#0x10]
000126  1c40              ADDS     r0,r0,#1
000128  b280              UXTH     r0,r0
00012a  9004              STR      r0,[sp,#0x10]
00012c  f10b0b01          ADD      r11,r11,#1            ;360
                  |L8.304|
000130  9806              LDR      r0,[sp,#0x18]         ;360
000132  4583              CMP      r11,r0                ;360
000134  d3d6              BCC      |L8.228|
;;;375    			}
;;;376    			y++;
000136  9803              LDR      r0,[sp,#0xc]
000138  1c40              ADDS     r0,r0,#1
00013a  b280              UXTH     r0,r0
00013c  9003              STR      r0,[sp,#0xc]
00013e  f10a0001          ADD      r0,r10,#1             ;357
000142  fa1ffa80          UXTH     r10,r0                ;357
                  |L8.326|
000146  9805              LDR      r0,[sp,#0x14]         ;357
000148  4582              CMP      r10,r0                ;357
00014a  dbc6              BLT      |L8.218|
;;;377    		}
;;;378    
;;;379    		if (_tFont->Space > 0)
;;;380    		{
;;;381    			/* 如果文字底色按_tFont->usBackColor，并且字间距大于点阵的宽度，那么需要在文字之间填充(暂时未实现) */
;;;382    		}
;;;383    		_usX += width + _tFont->Space;	/* 列地址递增 */
00014c  88f9              LDRH     r1,[r7,#6]
00014e  9806              LDR      r0,[sp,#0x18]
000150  4401              ADD      r1,r1,r0
000152  981b              LDR      r0,[sp,#0x6c]
000154  4408              ADD      r0,r0,r1
000156  b280              UXTH     r0,r0
000158  901b              STR      r0,[sp,#0x6c]
;;;384    		_ptr++;			/* 指向下一个字符 */
00015a  f1090901          ADD      r9,r9,#1
                  |L8.350|
00015e  f8990000          LDRB     r0,[r9,#0]            ;299
000162  2800              CMP      r0,#0                 ;299
000164  f47faf64          BNE      |L8.48|
                  |L8.360|
000168  bf00              NOP                            ;313
;;;385    	}
;;;386    }
00016a  b01f              ADD      sp,sp,#0x7c
00016c  e8bd8ff0          POP      {r4-r11,pc}
;;;387    
                          ENDP

                  |L8.368|
                          DCD      g_Ascii12
                  |L8.372|
                          DCD      g_Hz12
                  |L8.376|
                          DCD      g_Ascii16
                  |L8.380|
                          DCD      g_Hz16

                          AREA ||i.LCD_DrawBMP||, CODE, READONLY, ALIGN=2

                  LCD_DrawBMP PROC
;;;563    */
;;;564    void LCD_DrawBMP(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint16_t *_ptr)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;565    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9c08              LDR      r4,[sp,#0x20]
;;;566    	if (g_ChipID == IC_8875)
00000e  480a              LDR      r0,|L9.56|
000010  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000012  2875              CMP      r0,#0x75
000014  d107              BNE      |L9.38|
;;;567    	{
;;;568    		RA8875_DrawBMP(_usX, _usY, _usHeight, _usWidth, _ptr);
000016  4643              MOV      r3,r8
000018  463a              MOV      r2,r7
00001a  4631              MOV      r1,r6
00001c  4628              MOV      r0,r5
00001e  9400              STR      r4,[sp,#0]
000020  f7fffffe          BL       RA8875_DrawBMP
000024  e006              B        |L9.52|
                  |L9.38|
;;;569    	}
;;;570    	else
;;;571    	{
;;;572    		SPFD5420_DrawBMP(_usX, _usY, _usHeight, _usWidth, _ptr);
000026  4643              MOV      r3,r8
000028  463a              MOV      r2,r7
00002a  4631              MOV      r1,r6
00002c  4628              MOV      r0,r5
00002e  9400              STR      r4,[sp,#0]
000030  f7fffffe          BL       SPFD5420_DrawBMP
                  |L9.52|
;;;573    	}
;;;574    }
000034  e8bd83f8          POP      {r3-r9,pc}
;;;575    
                          ENDP

                  |L9.56|
                          DCD      g_ChipID

                          AREA ||i.LCD_DrawBmp32||, CODE, READONLY, ALIGN=1

                  LCD_DrawBmp32 PROC
;;;868    */
;;;869    void LCD_DrawBmp32(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint8_t *_pBmp)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;870    {
000004  b087              SUB      sp,sp,#0x1c
000006  4680              MOV      r8,r0
000008  4689              MOV      r9,r1
;;;871    	const uint8_t *p;
;;;872    	uint16_t usOldRGB, usNewRGB;
;;;873    	int16_t x, y;		/* 用于记录窗口内的相对坐标 */
;;;874    	uint8_t R1,G1,B1,A;	/* 新像素色彩分量 */
;;;875    	uint8_t R0,G0,B0;	/* 旧像素色彩分量 */
;;;876    
;;;877    	p = (const uint8_t *)_pBmp;
00000a  9c14              LDR      r4,[sp,#0x50]
;;;878    	p += 54;		/* 直接指向图像数据区 */
00000c  3436              ADDS     r4,r4,#0x36
;;;879    
;;;880    	/* 按照BMP位图次序，从左至右，从上至下扫描 */
;;;881    	for (y = _usHeight - 1; y >= 0; y--)
00000e  9809              LDR      r0,[sp,#0x24]
000010  1e40              SUBS     r0,r0,#1
000012  b207              SXTH     r7,r0
000014  e081              B        |L10.282|
                  |L10.22|
;;;882    	{
;;;883    		for (x = 0; x < _usWidth; x++)
000016  2600              MOVS     r6,#0
000018  e07a              B        |L10.272|
                  |L10.26|
;;;884    		{
;;;885    			B1 = *p++;
00001a  f8140b01          LDRB     r0,[r4],#1
00001e  9004              STR      r0,[sp,#0x10]
;;;886    			G1 = *p++;
000020  f8140b01          LDRB     r0,[r4],#1
000024  9005              STR      r0,[sp,#0x14]
;;;887    			R1 = *p++;
000026  f814bb01          LDRB     r11,[r4],#1
;;;888    			A = *p++;	/* Alpha 值(透明度)，0-255, 0表示透明，1表示不透明, 中间值表示透明度 */
00002a  f8145b01          LDRB     r5,[r4],#1
;;;889    
;;;890    			if (A == 0x00)	/* 需要透明,显示背景 */
00002e  2d00              CMP      r5,#0
000030  d06c              BEQ      |L10.268|
;;;891    			{
;;;892    				;	/* 不用刷新背景 */
;;;893    			}
;;;894    			else if (A == 0xFF)	/* 完全不透明， 显示新像素 */
000032  2dff              CMP      r5,#0xff
000034  d114              BNE      |L10.96|
;;;895    			{
;;;896    				usNewRGB = RGB(R1, G1, B1);
000036  ea4f00eb          ASR      r0,r11,#3
00003a  02c1              LSLS     r1,r0,#11
00003c  9805              LDR      r0,[sp,#0x14]
00003e  1080              ASRS     r0,r0,#2
000040  ea411140          ORR      r1,r1,r0,LSL #5
000044  9804              LDR      r0,[sp,#0x10]
000046  ea4100e0          ORR      r0,r1,r0,ASR #3
00004a  9006              STR      r0,[sp,#0x18]
;;;897    				//if (_ucFocusMode == 1)
;;;898    				//{
;;;899    				//	usNewRGB = Blend565(usNewRGB, CL_YELLOW, 10);
;;;900    				//}
;;;901    				LCD_PutPixel(x + _usX, y + _usY, usNewRGB);
00004c  eb070209          ADD      r2,r7,r9
000050  b291              UXTH     r1,r2
000052  eb060208          ADD      r2,r6,r8
000056  b290              UXTH     r0,r2
000058  9a06              LDR      r2,[sp,#0x18]
00005a  f7fffffe          BL       LCD_PutPixel
00005e  e055              B        |L10.268|
                  |L10.96|
;;;902    			}
;;;903    			else 	/* 半透明 */
;;;904    			{
;;;905    				/* 计算公式： 实际显示颜色 = 前景颜色 * Alpha / 255 + 背景颜色 * (255-Alpha) / 255 */
;;;906    				usOldRGB = LCD_GetPixel(x + _usX, y + _usY);
000060  eb070209          ADD      r2,r7,r9
000064  b291              UXTH     r1,r2
000066  eb060208          ADD      r2,r6,r8
00006a  b290              UXTH     r0,r2
00006c  f7fffffe          BL       LCD_GetPixel
000070  4682              MOV      r10,r0
;;;907    				R0 = RGB565_R(usOldRGB);
000072  20f8              MOVS     r0,#0xf8
000074  ea00202a          AND      r0,r0,r10,ASR #8
000078  9003              STR      r0,[sp,#0xc]
;;;908    				G0 = RGB565_G(usOldRGB);
00007a  20fc              MOVS     r0,#0xfc
00007c  ea0000ea          AND      r0,r0,r10,ASR #3
000080  9002              STR      r0,[sp,#8]
;;;909    				B0 = RGB565_B(usOldRGB);
000082  20f8              MOVS     r0,#0xf8
000084  ea0000ca          AND      r0,r0,r10,LSL #3
000088  9001              STR      r0,[sp,#4]
;;;910    
;;;911    				R1 = (R1 * A) / 255 + R0 * (255 - A) / 255;
00008a  fb0bf005          MUL      r0,r11,r5
00008e  21ff              MOVS     r1,#0xff
000090  fb90f2f1          SDIV     r2,r0,r1
000094  f1c501ff          RSB      r1,r5,#0xff
000098  9803              LDR      r0,[sp,#0xc]
00009a  4341              MULS     r1,r0,r1
00009c  20ff              MOVS     r0,#0xff
00009e  fb91f0f0          SDIV     r0,r1,r0
0000a2  4410              ADD      r0,r0,r2
0000a4  f0000bff          AND      r11,r0,#0xff
;;;912    				G1 = (G1 * A) / 255 + G0 * (255 - A) / 255;
0000a8  9805              LDR      r0,[sp,#0x14]
0000aa  4368              MULS     r0,r5,r0
0000ac  21ff              MOVS     r1,#0xff
0000ae  fb90f2f1          SDIV     r2,r0,r1
0000b2  f1c501ff          RSB      r1,r5,#0xff
0000b6  9802              LDR      r0,[sp,#8]
0000b8  4341              MULS     r1,r0,r1
0000ba  20ff              MOVS     r0,#0xff
0000bc  fb91f0f0          SDIV     r0,r1,r0
0000c0  4410              ADD      r0,r0,r2
0000c2  b2c0              UXTB     r0,r0
0000c4  9005              STR      r0,[sp,#0x14]
;;;913    				B1 = (B1 * A) / 255 + B0 * (255 - A) / 255;
0000c6  9804              LDR      r0,[sp,#0x10]
0000c8  4368              MULS     r0,r5,r0
0000ca  21ff              MOVS     r1,#0xff
0000cc  fb90f2f1          SDIV     r2,r0,r1
0000d0  f1c501ff          RSB      r1,r5,#0xff
0000d4  9801              LDR      r0,[sp,#4]
0000d6  4341              MULS     r1,r0,r1
0000d8  20ff              MOVS     r0,#0xff
0000da  fb91f0f0          SDIV     r0,r1,r0
0000de  4410              ADD      r0,r0,r2
0000e0  b2c0              UXTB     r0,r0
0000e2  9004              STR      r0,[sp,#0x10]
;;;914    				usNewRGB = RGB(R1, G1, B1);
0000e4  ea4f00eb          ASR      r0,r11,#3
0000e8  02c1              LSLS     r1,r0,#11
0000ea  9805              LDR      r0,[sp,#0x14]
0000ec  1080              ASRS     r0,r0,#2
0000ee  ea411140          ORR      r1,r1,r0,LSL #5
0000f2  9804              LDR      r0,[sp,#0x10]
0000f4  ea4100e0          ORR      r0,r1,r0,ASR #3
0000f8  9006              STR      r0,[sp,#0x18]
;;;915    				//if (_ucFocusMode == 1)
;;;916    				//{
;;;917    				//	usNewRGB = Blend565(usNewRGB, CL_YELLOW, 10);
;;;918    				//}
;;;919    				LCD_PutPixel(x + _usX, y + _usY, usNewRGB);
0000fa  eb070209          ADD      r2,r7,r9
0000fe  b291              UXTH     r1,r2
000100  eb060208          ADD      r2,r6,r8
000104  b290              UXTH     r0,r2
000106  9a06              LDR      r2,[sp,#0x18]
000108  f7fffffe          BL       LCD_PutPixel
                  |L10.268|
00010c  1c70              ADDS     r0,r6,#1              ;883
00010e  b206              SXTH     r6,r0                 ;883
                  |L10.272|
000110  980a              LDR      r0,[sp,#0x28]         ;883
000112  4286              CMP      r6,r0                 ;883
000114  db81              BLT      |L10.26|
000116  1e78              SUBS     r0,r7,#1              ;881
000118  b207              SXTH     r7,r0                 ;881
                  |L10.282|
00011a  2f00              CMP      r7,#0                 ;881
00011c  f6bfaf7b          BGE      |L10.22|
;;;920    			}
;;;921    		}
;;;922    	}
;;;923    }
000120  b00b              ADD      sp,sp,#0x2c
000122  e8bd8ff0          POP      {r4-r11,pc}
;;;924    
                          ENDP


                          AREA ||i.LCD_DrawButton||, CODE, READONLY, ALIGN=1

                  LCD_DrawButton PROC
;;;1117   */
;;;1118   void LCD_DrawButton(BUTTON_T *_pBtn)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1119   {
000004  4604              MOV      r4,r0
;;;1120   #if 1
;;;1121   		uint16_t len, fwidth, x, y;
;;;1122   
;;;1123   		if (_pBtn->Focus == 1)
000006  7d20              LDRB     r0,[r4,#0x14]
000008  2801              CMP      r0,#1
00000a  d15f              BNE      |L11.204|
;;;1124   		{
;;;1125   			/* 仿XP风格，平面编辑框 */
;;;1126   			LCD_DrawRect(_pBtn->Left, _pBtn->Top, _pBtn->Height, _pBtn->Width, BUTTON_BORDER_COLOR);
00000c  2010              MOVS     r0,#0x10
00000e  9000              STR      r0,[sp,#0]
000010  8923              LDRH     r3,[r4,#8]
000012  88e2              LDRH     r2,[r4,#6]
000014  88a1              LDRH     r1,[r4,#4]
000016  8860              LDRH     r0,[r4,#2]
000018  f7fffffe          BL       LCD_DrawRect
;;;1127   			LCD_DrawRect(_pBtn->Left + 1, _pBtn->Top + 1, _pBtn->Height - 2, _pBtn->Width - 2, BUTTON_BORDER1_COLOR);
00001c  f64f70ff          MOV      r0,#0xffff
000020  9000              STR      r0,[sp,#0]
000022  f8b4c008          LDRH     r12,[r4,#8]
000026  f1ac0c02          SUB      r12,r12,#2
00002a  fa1ff38c          UXTH     r3,r12
00002e  f8b4c006          LDRH     r12,[r4,#6]
000032  f1ac0c02          SUB      r12,r12,#2
000036  fa1ff28c          UXTH     r2,r12
00003a  f8b4c004          LDRH     r12,[r4,#4]
00003e  f10c0c01          ADD      r12,r12,#1
000042  fa1ff18c          UXTH     r1,r12
000046  f8b4c002          LDRH     r12,[r4,#2]
00004a  f10c0c01          ADD      r12,r12,#1
00004e  fa1ff08c          UXTH     r0,r12
000052  f7fffffe          BL       LCD_DrawRect
;;;1128   			LCD_DrawRect(_pBtn->Left + 2, _pBtn->Top + 2, _pBtn->Height - 4, _pBtn->Width - 4, BUTTON_BORDER2_COLOR);
000056  f24940b2          MOV      r0,#0x94b2
00005a  9000              STR      r0,[sp,#0]
00005c  f8b4c008          LDRH     r12,[r4,#8]
000060  f1ac0c04          SUB      r12,r12,#4
000064  fa1ff38c          UXTH     r3,r12
000068  f8b4c006          LDRH     r12,[r4,#6]
00006c  f1ac0c04          SUB      r12,r12,#4
000070  fa1ff28c          UXTH     r2,r12
000074  f8b4c004          LDRH     r12,[r4,#4]
000078  f10c0c02          ADD      r12,r12,#2
00007c  fa1ff18c          UXTH     r1,r12
000080  f8b4c002          LDRH     r12,[r4,#2]
000084  f10c0c02          ADD      r12,r12,#2
000088  fa1ff08c          UXTH     r0,r12
00008c  f7fffffe          BL       LCD_DrawRect
;;;1129   
;;;1130   			LCD_Fill_Rect(_pBtn->Left + 3, _pBtn->Top + 3, _pBtn->Height - 6, _pBtn->Width - 6, BUTTON_ACTIVE_COLOR);	/* 选中后的底色 */
000090  f64770ff          MOV      r0,#0x7fff
000094  9000              STR      r0,[sp,#0]
000096  f8b4c008          LDRH     r12,[r4,#8]
00009a  f1ac0c06          SUB      r12,r12,#6
00009e  fa1ff38c          UXTH     r3,r12
0000a2  f8b4c006          LDRH     r12,[r4,#6]
0000a6  f1ac0c06          SUB      r12,r12,#6
0000aa  fa1ff28c          UXTH     r2,r12
0000ae  f8b4c004          LDRH     r12,[r4,#4]
0000b2  f10c0c03          ADD      r12,r12,#3
0000b6  fa1ff18c          UXTH     r1,r12
0000ba  f8b4c002          LDRH     r12,[r4,#2]
0000be  f10c0c03          ADD      r12,r12,#3
0000c2  fa1ff08c          UXTH     r0,r12
0000c6  f7fffffe          BL       LCD_Fill_Rect
0000ca  e05e              B        |L11.394|
                  |L11.204|
;;;1131   		}
;;;1132   		else
;;;1133   		{
;;;1134   			/* 仿XP风格，平面编辑框 */
;;;1135   			LCD_DrawRect(_pBtn->Left, _pBtn->Top, _pBtn->Height, _pBtn->Width, BUTTON_BORDER_COLOR);
0000cc  2010              MOVS     r0,#0x10
0000ce  9000              STR      r0,[sp,#0]
0000d0  8923              LDRH     r3,[r4,#8]
0000d2  88e2              LDRH     r2,[r4,#6]
0000d4  88a1              LDRH     r1,[r4,#4]
0000d6  8860              LDRH     r0,[r4,#2]
0000d8  f7fffffe          BL       LCD_DrawRect
;;;1136   			LCD_DrawRect(_pBtn->Left + 1, _pBtn->Top + 1, _pBtn->Height - 2, _pBtn->Width - 2, BUTTON_BORDER1_COLOR);
0000dc  f64f70ff          MOV      r0,#0xffff
0000e0  9000              STR      r0,[sp,#0]
0000e2  f8b4c008          LDRH     r12,[r4,#8]
0000e6  f1ac0c02          SUB      r12,r12,#2
0000ea  fa1ff38c          UXTH     r3,r12
0000ee  f8b4c006          LDRH     r12,[r4,#6]
0000f2  f1ac0c02          SUB      r12,r12,#2
0000f6  fa1ff28c          UXTH     r2,r12
0000fa  f8b4c004          LDRH     r12,[r4,#4]
0000fe  f10c0c01          ADD      r12,r12,#1
000102  fa1ff18c          UXTH     r1,r12
000106  f8b4c002          LDRH     r12,[r4,#2]
00010a  f10c0c01          ADD      r12,r12,#1
00010e  fa1ff08c          UXTH     r0,r12
000112  f7fffffe          BL       LCD_DrawRect
;;;1137   			LCD_DrawRect(_pBtn->Left + 2, _pBtn->Top + 2, _pBtn->Height - 4, _pBtn->Width - 4, BUTTON_BORDER2_COLOR);
000116  f24940b2          MOV      r0,#0x94b2
00011a  9000              STR      r0,[sp,#0]
00011c  f8b4c008          LDRH     r12,[r4,#8]
000120  f1ac0c04          SUB      r12,r12,#4
000124  fa1ff38c          UXTH     r3,r12
000128  f8b4c006          LDRH     r12,[r4,#6]
00012c  f1ac0c04          SUB      r12,r12,#4
000130  fa1ff28c          UXTH     r2,r12
000134  f8b4c004          LDRH     r12,[r4,#4]
000138  f10c0c02          ADD      r12,r12,#2
00013c  fa1ff18c          UXTH     r1,r12
000140  f8b4c002          LDRH     r12,[r4,#2]
000144  f10c0c02          ADD      r12,r12,#2
000148  fa1ff08c          UXTH     r0,r12
00014c  f7fffffe          BL       LCD_DrawRect
;;;1138   
;;;1139   			LCD_Fill_Rect(_pBtn->Left + 3, _pBtn->Top + 3, _pBtn->Height - 6, _pBtn->Width - 6, BUTTON_BACK_COLOR);		/* 未选中的底色 */
000150  f64c6059          MOV      r0,#0xce59
000154  9000              STR      r0,[sp,#0]
000156  f8b4c008          LDRH     r12,[r4,#8]
00015a  f1ac0c06          SUB      r12,r12,#6
00015e  fa1ff38c          UXTH     r3,r12
000162  f8b4c006          LDRH     r12,[r4,#6]
000166  f1ac0c06          SUB      r12,r12,#6
00016a  fa1ff28c          UXTH     r2,r12
00016e  f8b4c004          LDRH     r12,[r4,#4]
000172  f10c0c03          ADD      r12,r12,#3
000176  fa1ff18c          UXTH     r1,r12
00017a  f8b4c002          LDRH     r12,[r4,#2]
00017e  f10c0c03          ADD      r12,r12,#3
000182  fa1ff08c          UXTH     r0,r12
000186  f7fffffe          BL       LCD_Fill_Rect
                  |L11.394|
;;;1140   		}
;;;1141   
;;;1142   		/* 文字居中 */
;;;1143   		len = strlen(_pBtn->pCaption);
00018a  6920              LDR      r0,[r4,#0x10]
00018c  f7fffffe          BL       strlen
000190  b286              UXTH     r6,r0
;;;1144   
;;;1145   		if (_pBtn->Font->FontCode == FC_ST_16)
000192  68e0              LDR      r0,[r4,#0xc]
000194  8800              LDRH     r0,[r0,#0]
000196  b908              CBNZ     r0,|L11.412|
;;;1146   		{
;;;1147   			fwidth = 8;		/* 字体宽度 */
000198  2508              MOVS     r5,#8
00019a  e006              B        |L11.426|
                  |L11.412|
;;;1148   		}
;;;1149   		else if (_pBtn->Font->FontCode == FC_ST_12)
00019c  68e0              LDR      r0,[r4,#0xc]
00019e  8800              LDRH     r0,[r0,#0]
0001a0  2801              CMP      r0,#1
0001a2  d101              BNE      |L11.424|
;;;1150   		{
;;;1151   			fwidth = 6;		/* 字体宽度 */
0001a4  2506              MOVS     r5,#6
0001a6  e000              B        |L11.426|
                  |L11.424|
;;;1152   		}
;;;1153   		else
;;;1154   		{
;;;1155   			fwidth = 8;		/* 字体宽度 */
0001a8  2508              MOVS     r5,#8
                  |L11.426|
;;;1156   		}
;;;1157   		x = _pBtn->Left + _pBtn->Width / 2 - (len * fwidth) / 2;
0001aa  8921              LDRH     r1,[r4,#8]
0001ac  eb0172d1          ADD      r2,r1,r1,LSR #31
0001b0  8863              LDRH     r3,[r4,#2]
0001b2  eb030362          ADD      r3,r3,r2,ASR #1
0001b6  fb06f005          MUL      r0,r6,r5
0001ba  eb0072d0          ADD      r2,r0,r0,LSR #31
0001be  eba30262          SUB      r2,r3,r2,ASR #1
0001c2  b297              UXTH     r7,r2
;;;1158   		y = _pBtn->Top + _pBtn->Height / 2 - fwidth;
0001c4  88e0              LDRH     r0,[r4,#6]
0001c6  eb0071d0          ADD      r1,r0,r0,LSR #31
0001ca  88a2              LDRH     r2,[r4,#4]
0001cc  eb020161          ADD      r1,r2,r1,ASR #1
0001d0  1b49              SUBS     r1,r1,r5
0001d2  fa1ff881          UXTH     r8,r1
;;;1159   
;;;1160   		LCD_DispStr(x, y, _pBtn->pCaption, _pBtn->Font);
0001d6  4641              MOV      r1,r8
0001d8  4638              MOV      r0,r7
0001da  e9d43203          LDRD     r3,r2,[r4,#0xc]
0001de  f7fffffe          BL       LCD_DispStr
;;;1161   #else
;;;1162   	if (g_ChipID == IC_8875)
;;;1163   	{
;;;1164   		uint16_t len, x, y;
;;;1165   
;;;1166   		if (_pBtn->Focus == 1)
;;;1167   		{
;;;1168   			/* 仿XP风格，平面编辑框 */
;;;1169   			RA8875_DrawRect(_pBtn->Left, _pBtn->Top, _pBtn->Height, _pBtn->Width, BUTTON_BORDER_COLOR);
;;;1170   			RA8875_DrawRect(_pBtn->Left + 1, _pBtn->Top + 1, _pBtn->Height - 2, _pBtn->Width - 2, BUTTON_BORDER1_COLOR);
;;;1171   			RA8875_DrawRect(_pBtn->Left + 2, _pBtn->Top + 2, _pBtn->Height - 4, _pBtn->Width - 4, BUTTON_BORDER2_COLOR);
;;;1172   
;;;1173   			RA8875_FillRect(_pBtn->Left + 3, _pBtn->Top + 3, _pBtn->Height - 6, _pBtn->Width - 6, BUTTON_ACTIVE_COLOR);
;;;1174   
;;;1175   			RA8875_SetBackColor(BUTTON_ACTIVE_COLOR);
;;;1176   		}
;;;1177   		else
;;;1178   		{
;;;1179   			/* 仿XP风格，平面编辑框 */
;;;1180   			RA8875_DrawRect(_pBtn->Left, _pBtn->Top, _pBtn->Height, _pBtn->Width, BUTTON_BORDER_COLOR);
;;;1181   			RA8875_DrawRect(_pBtn->Left + 1, _pBtn->Top + 1, _pBtn->Height - 2, _pBtn->Width - 2, BUTTON_BORDER1_COLOR);
;;;1182   			RA8875_DrawRect(_pBtn->Left + 2, _pBtn->Top + 2, _pBtn->Height - 4, _pBtn->Width - 4, BUTTON_BORDER2_COLOR);
;;;1183   
;;;1184   			RA8875_FillRect(_pBtn->Left + 3, _pBtn->Top + 3, _pBtn->Height - 6, _pBtn->Width - 6, BUTTON_BACK_COLOR);
;;;1185   
;;;1186   			RA8875_SetBackColor(BUTTON_BACK_COLOR);
;;;1187   		}
;;;1188   
;;;1189   		#if 1	/* 按钮文字字体和颜色固定 */
;;;1190   			if (strcmp(_pBtn->Caption, "←") == 0)	/* 退格键特殊处理 */
;;;1191   			{
;;;1192   				/* 退格键符号是单像素笔画，太细了不协调，因此特殊处理 */
;;;1193   				RA8875_SetFont(RA_FONT_16, 0, 0);
;;;1194   				RA8875_SetFrontColor(CL_BLACK);
;;;1195   				RA8875_SetTextZoom(RA_SIZE_X2, RA_SIZE_X2);	/* 放大2倍 */
;;;1196   			}
;;;1197   			else
;;;1198   			{
;;;1199   				RA8875_SetFont(RA_FONT_16, 0, 0);
;;;1200   				RA8875_SetFrontColor(CL_BLACK);
;;;1201   				RA8875_SetTextZoom(RA_SIZE_X1, RA_SIZE_X1);	/* 放大1倍 */
;;;1202   			}
;;;1203   		#else	/* 按钮文字字体和颜色有应用程序指定 */
;;;1204   			RA8875_SetFont(_pBtn->Font.FontCode, 0, 0);
;;;1205   			RA8875_SetFrontColor(_pBtn->Font.FrontColor);
;;;1206   		#endif
;;;1207   
;;;1208   		/* 文字居中 */
;;;1209   		len = strlen(_pBtn->Caption);
;;;1210   
;;;1211   		/* 此处统计不等宽字符有问题。暂时特殊处理下 */
;;;1212   		if (len != 3)
;;;1213   		{
;;;1214   			x = _pBtn->Left + (_pBtn->Width - len * 16) / 2;
;;;1215   		}
;;;1216   		else
;;;1217   		{
;;;1218   			x = _pBtn->Left + (_pBtn->Width - len * 20) / 2;
;;;1219   		}
;;;1220   
;;;1221   		/* 对特殊字符特殊处理 */
;;;1222   		if ((len == 1) && (_pBtn->Caption[0] == '.'))
;;;1223   		{
;;;1224   			y = _pBtn->Top + 3;
;;;1225   			x += 3;
;;;1226   		}
;;;1227   		else
;;;1228   		{
;;;1229   			y = _pBtn->Top + 3;
;;;1230   		}
;;;1231   
;;;1232   		RA8875_DispStr(x, y, _pBtn->Caption);
;;;1233   
;;;1234   		RA8875_SetTextZoom(RA_SIZE_X1, RA_SIZE_X1);	/* 还原放大1倍 */
;;;1235   	}
;;;1236   #endif
;;;1237   }
0001e2  e8bd83f8          POP      {r3-r9,pc}
;;;1238   
                          ENDP


                          AREA ||i.LCD_DrawCheckBox||, CODE, READONLY, ALIGN=2

                  LCD_DrawCheckBox PROC
;;;984    */
;;;985    void LCD_DrawCheckBox(CHECK_T *_pCheckBox)
000000  b57c              PUSH     {r2-r6,lr}
;;;986    {
000002  4604              MOV      r4,r0
;;;987    #if 1
;;;988    	uint16_t x, y;
;;;989    
;;;990    	/* 目前只做了16点阵汉字的大小 */
;;;991    
;;;992    	/* 绘制外框 */
;;;993    	x = _pCheckBox->Left;
000004  8865              LDRH     r5,[r4,#2]
;;;994    	LCD_DrawRect(x, _pCheckBox->Top, CHECK_BOX_H, CHECK_BOX_W, CHECK_BOX_BORDER_COLOR);
000006  2010              MOVS     r0,#0x10
000008  9000              STR      r0,[sp,#0]
00000a  88a1              LDRH     r1,[r4,#4]
00000c  2318              MOVS     r3,#0x18
00000e  461a              MOV      r2,r3
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       LCD_DrawRect
;;;995    	LCD_DrawRect(x + 1, _pCheckBox->Top + 1, CHECK_BOX_H - 2, CHECK_BOX_W - 2, CHECK_BOX_BORDER_COLOR);
000016  2010              MOVS     r0,#0x10
000018  9000              STR      r0,[sp,#0]
00001a  88a2              LDRH     r2,[r4,#4]
00001c  1c52              ADDS     r2,r2,#1
00001e  b291              UXTH     r1,r2
000020  1c6a              ADDS     r2,r5,#1
000022  b290              UXTH     r0,r2
000024  2316              MOVS     r3,#0x16
000026  461a              MOV      r2,r3
000028  f7fffffe          BL       LCD_DrawRect
;;;996    	LCD_Fill_Rect(x + 2, _pCheckBox->Top + 2, CHECK_BOX_H - 4, CHECK_BOX_W - 4, CHECK_BOX_BACK_COLOR);
00002c  f64c6059          MOV      r0,#0xce59
000030  9000              STR      r0,[sp,#0]
000032  88a2              LDRH     r2,[r4,#4]
000034  1c92              ADDS     r2,r2,#2
000036  b291              UXTH     r1,r2
000038  1caa              ADDS     r2,r5,#2
00003a  b290              UXTH     r0,r2
00003c  2314              MOVS     r3,#0x14
00003e  461a              MOV      r2,r3
000040  f7fffffe          BL       LCD_Fill_Rect
;;;997    
;;;998    	/* 绘制文本标签 */
;;;999    	x = _pCheckBox->Left + CHECK_BOX_W + 2;
000044  8860              LDRH     r0,[r4,#2]
000046  301a              ADDS     r0,r0,#0x1a
000048  b285              UXTH     r5,r0
;;;1000   	y = _pCheckBox->Top + CHECK_BOX_H / 2 - 8;
00004a  88a0              LDRH     r0,[r4,#4]
00004c  1d00              ADDS     r0,r0,#4
00004e  b286              UXTH     r6,r0
;;;1001   	LCD_DispStr(x, y, _pCheckBox->pCaption, _pCheckBox->Font);
000050  4631              MOV      r1,r6
000052  4628              MOV      r0,r5
000054  e9d43203          LDRD     r3,r2,[r4,#0xc]
000058  f7fffffe          BL       LCD_DispStr
;;;1002   
;;;1003   	if (_pCheckBox->Checked)
00005c  7d20              LDRB     r0,[r4,#0x14]
00005e  b1c0              CBZ      r0,|L12.146|
;;;1004   	{
;;;1005   		FONT_T font;
;;;1006   
;;;1007   	    font.FontCode = FC_ST_16;
000060  2000              MOVS     r0,#0
000062  f8ad0000          STRH     r0,[sp,#0]
;;;1008   		font.BackColor = CL_MASK;
000066  f6491099          MOV      r0,#0x9999
00006a  f8ad0004          STRH     r0,[sp,#4]
;;;1009   		font.FrontColor = CHECK_BOX_CHECKED_COLOR;	/* 钩的颜色 */
00006e  f44f4078          MOV      r0,#0xf800
000072  f8ad0002          STRH     r0,[sp,#2]
;;;1010   		font.Space = 0;
000076  2000              MOVS     r0,#0
000078  f8ad0006          STRH     r0,[sp,#6]
;;;1011   		x = _pCheckBox->Left;
00007c  8865              LDRH     r5,[r4,#2]
;;;1012   		LCD_DispStr(x + 3, _pCheckBox->Top + 3, "√", &font);
00007e  88a2              LDRH     r2,[r4,#4]
000080  1cd2              ADDS     r2,r2,#3
000082  b291              UXTH     r1,r2
000084  1cea              ADDS     r2,r5,#3
000086  b290              UXTH     r0,r2
000088  466b              MOV      r3,sp
00008a  a202              ADR      r2,|L12.148|
00008c  f7fffffe          BL       LCD_DispStr
;;;1013   	}
000090  bf00              NOP      
                  |L12.146|
;;;1014   #else
;;;1015   	if (g_ChipID == IC_8875)
;;;1016   	{
;;;1017   		uint16_t x;
;;;1018   
;;;1019   		RA8875_SetFont(_pCheckBox->Font.FontCode, 0, 0);	/* 设置32点阵字体，行间距=0，字间距=0 */
;;;1020   
;;;1021   		/* 绘制标签 */
;;;1022   		//RA8875_SetBackColor(_pCheckBox->Font.BackColor);
;;;1023   		RA8875_SetBackColor(WIN_BODY_COLOR);
;;;1024   		RA8875_SetFrontColor(_pCheckBox->Font.FrontColor);
;;;1025   		RA8875_DispStr(_pCheckBox->Left, _pCheckBox->Top, _pCheckBox->Caption);
;;;1026   
;;;1027   		/* 绘制外框 */
;;;1028   		x = _pCheckBox->Left + _pCheckBox->Width - CHECK_BOX_W;
;;;1029   		RA8875_DrawRect(x, _pCheckBox->Top, CHECK_BOX_H, CHECK_BOX_W, CHECK_BOX_BORDER_COLOR);
;;;1030   		RA8875_DrawRect(x + 1, _pCheckBox->Top + 1, CHECK_BOX_H - 2, CHECK_BOX_W - 2, CHECK_BOX_BORDER_COLOR);
;;;1031   		RA8875_FillRect(x + 2, _pCheckBox->Top + 2, CHECK_BOX_H - 4, CHECK_BOX_W - 4, CHECK_BOX_BACK_COLOR);
;;;1032   
;;;1033   		if (_pCheckBox->Checked)
;;;1034   		{
;;;1035   			RA8875_SetBackColor(CHECK_BOX_BACK_COLOR);
;;;1036   			RA8875_SetFrontColor(CL_RED);
;;;1037   			RA8875_DispStr(x + 3, _pCheckBox->Top + 3, "√");
;;;1038   		}
;;;1039   	}
;;;1040   	else
;;;1041   	{
;;;1042   
;;;1043   	}
;;;1044   #endif
;;;1045   
;;;1046   }
000092  bd7c              POP      {r2-r6,pc}
;;;1047   
                          ENDP

                  |L12.148|
000094  a1cc00            DCB      161,204,0
000097  00                DCB      0

                          AREA ||i.LCD_DrawCircle||, CODE, READONLY, ALIGN=2

                  LCD_DrawCircle PROC
;;;539    */
;;;540    void LCD_DrawCircle(uint16_t _usX, uint16_t _usY, uint16_t _usRadius, uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;541    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;542    	if (g_ChipID == IC_8875)
00000c  4809              LDR      r0,|L13.52|
00000e  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000010  2875              CMP      r0,#0x75
000012  d106              BNE      |L13.34|
;;;543    	{
;;;544    		RA8875_DrawCircle(_usX, _usY, _usRadius, _usColor);
000014  463b              MOV      r3,r7
000016  4632              MOV      r2,r6
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       RA8875_DrawCircle
000020  e005              B        |L13.46|
                  |L13.34|
;;;545    	}
;;;546    	else
;;;547    	{
;;;548    		SPFD5420_DrawCircle(_usX, _usY, _usRadius, _usColor);
000022  463b              MOV      r3,r7
000024  4632              MOV      r2,r6
000026  4629              MOV      r1,r5
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       SPFD5420_DrawCircle
                  |L13.46|
;;;549    	}
;;;550    }
00002e  e8bd81f0          POP      {r4-r8,pc}
;;;551    
                          ENDP

000032  0000              DCW      0x0000
                  |L13.52|
                          DCD      g_ChipID

                          AREA ||i.LCD_DrawEdit||, CODE, READONLY, ALIGN=1

                  LCD_DrawEdit PROC
;;;1055   */
;;;1056   void LCD_DrawEdit(EDIT_T *_pEdit)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1057   {
000004  4604              MOV      r4,r0
;;;1058   #if 1
;;;1059   	uint16_t len, x, y;
;;;1060   	uint8_t width;
;;;1061   
;;;1062   	/* 仿XP风格，平面编辑框 */
;;;1063   	LCD_DrawRect(_pEdit->Left, _pEdit->Top, _pEdit->Height, _pEdit->Width, EDIT_BORDER_COLOR);
000006  2010              MOVS     r0,#0x10
000008  9000              STR      r0,[sp,#0]
00000a  8923              LDRH     r3,[r4,#8]
00000c  88e2              LDRH     r2,[r4,#6]
00000e  88a1              LDRH     r1,[r4,#4]
000010  8860              LDRH     r0,[r4,#2]
000012  f7fffffe          BL       LCD_DrawRect
;;;1064   	LCD_Fill_Rect(_pEdit->Left + 1, _pEdit->Top + 1, _pEdit->Height - 2, _pEdit->Width - 2, EDIT_BACK_COLOR);
000016  f64f70ff          MOV      r0,#0xffff
00001a  9000              STR      r0,[sp,#0]
00001c  f8b4c008          LDRH     r12,[r4,#8]
000020  f1ac0c02          SUB      r12,r12,#2
000024  fa1ff38c          UXTH     r3,r12
000028  f8b4c006          LDRH     r12,[r4,#6]
00002c  f1ac0c02          SUB      r12,r12,#2
000030  fa1ff28c          UXTH     r2,r12
000034  f8b4c004          LDRH     r12,[r4,#4]
000038  f10c0c01          ADD      r12,r12,#1
00003c  fa1ff18c          UXTH     r1,r12
000040  f8b4c002          LDRH     r12,[r4,#2]
000044  f10c0c01          ADD      r12,r12,#1
000048  fa1ff08c          UXTH     r0,r12
00004c  f7fffffe          BL       LCD_Fill_Rect
;;;1065   
;;;1066   	/* 文字居中 */
;;;1067   	if (_pEdit->Font->FontCode == FC_ST_12)
000050  68e0              LDR      r0,[r4,#0xc]
000052  8800              LDRH     r0,[r0,#0]
000054  2801              CMP      r0,#1
000056  d101              BNE      |L14.92|
;;;1068   	{
;;;1069   		width = 6;
000058  2506              MOVS     r5,#6
00005a  e000              B        |L14.94|
                  |L14.92|
;;;1070   	}
;;;1071   	else
;;;1072   	{
;;;1073   		width = 8;
00005c  2508              MOVS     r5,#8
                  |L14.94|
;;;1074   	}
;;;1075   	len = strlen(_pEdit->pCaption);
00005e  6920              LDR      r0,[r4,#0x10]
000060  f7fffffe          BL       strlen
000064  b286              UXTH     r6,r0
;;;1076   	x = _pEdit->Left +  (_pEdit->Width - len * width) / 2;
000066  8921              LDRH     r1,[r4,#8]
000068  fb061015          MLS      r0,r6,r5,r1
00006c  eb0071d0          ADD      r1,r0,r0,LSR #31
000070  8862              LDRH     r2,[r4,#2]
000072  eb020161          ADD      r1,r2,r1,ASR #1
000076  b28f              UXTH     r7,r1
;;;1077   	y = _pEdit->Top + _pEdit->Height / 2 - width;
000078  88e0              LDRH     r0,[r4,#6]
00007a  eb0071d0          ADD      r1,r0,r0,LSR #31
00007e  88a2              LDRH     r2,[r4,#4]
000080  eb020161          ADD      r1,r2,r1,ASR #1
000084  1b49              SUBS     r1,r1,r5
000086  fa1ff881          UXTH     r8,r1
;;;1078   
;;;1079   	LCD_DispStr(x, y, _pEdit->pCaption, _pEdit->Font);
00008a  4641              MOV      r1,r8
00008c  4638              MOV      r0,r7
00008e  e9d43203          LDRD     r3,r2,[r4,#0xc]
000092  f7fffffe          BL       LCD_DispStr
;;;1080   #else
;;;1081   	if (g_ChipID == IC_8875)
;;;1082   	{
;;;1083   		uint16_t len, x;
;;;1084   
;;;1085   		/* 仿XP风格，平面编辑框 */
;;;1086   		RA8875_DrawRect(_pEdit->Left, _pEdit->Top, _pEdit->Height, _pEdit->Width, EDIT_BORDER_COLOR);
;;;1087   		RA8875_FillRect(_pEdit->Left + 1, _pEdit->Top + 1, _pEdit->Height - 2, _pEdit->Width - 2, EDIT_BACK_COLOR);
;;;1088   
;;;1089   		RA8875_SetFont(_pEdit->Font.FontCode, 0, 0);	/* 设置32点阵字体，行间距=0，字间距=0 */
;;;1090   		RA8875_SetFrontColor(_pEdit->Font.FrontColor);
;;;1091   		RA8875_SetBackColor(EDIT_BACK_COLOR);
;;;1092   
;;;1093   		/* 文字居中 */
;;;1094   		len = strlen(_pEdit->Caption);
;;;1095   		x = (_pEdit->Width - len * 16) / 2;
;;;1096   
;;;1097   		RA8875_DispStr(_pEdit->Left + x, _pEdit->Top + 3, _pEdit->Caption);
;;;1098   	}
;;;1099   	else
;;;1100   	{
;;;1101   		//SPFD5420_DrawCircle(_usX, _usY, _usRadius, _usColor);
;;;1102   	}
;;;1103   #endif
;;;1104   }
000096  e8bd83f8          POP      {r3-r9,pc}
;;;1105   
                          ENDP


                          AREA ||i.LCD_DrawGroupBox||, CODE, READONLY, ALIGN=1

                  LCD_DrawGroupBox PROC
;;;1246   */
;;;1247   void LCD_DrawGroupBox(GROUP_T *_pBox)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1248   {
000002  4604              MOV      r4,r0
;;;1249   	uint16_t x, y;
;;;1250   
;;;1251   	/* 画阴影线 */
;;;1252   	LCD_DrawRect(_pBox->Left + 1, _pBox->Top + 5, _pBox->Height, _pBox->Width - 1, CL_BOX_BORDER2);
000004  f64f70ff          MOV      r0,#0xffff
000008  9000              STR      r0,[sp,#0]
00000a  8927              LDRH     r7,[r4,#8]
00000c  1e7f              SUBS     r7,r7,#1
00000e  b2bb              UXTH     r3,r7
000010  88e2              LDRH     r2,[r4,#6]
000012  88a7              LDRH     r7,[r4,#4]
000014  1d7f              ADDS     r7,r7,#5
000016  b2b9              UXTH     r1,r7
000018  8867              LDRH     r7,[r4,#2]
00001a  1c7f              ADDS     r7,r7,#1
00001c  b2b8              UXTH     r0,r7
00001e  f7fffffe          BL       LCD_DrawRect
;;;1253   
;;;1254   	/* 画主框线 */
;;;1255   	LCD_DrawRect(_pBox->Left, _pBox->Top + 4, _pBox->Height, _pBox->Width - 1, CL_BOX_BORDER1);
000022  f64a5053          MOV      r0,#0xad53
000026  9000              STR      r0,[sp,#0]
000028  8927              LDRH     r7,[r4,#8]
00002a  1e7f              SUBS     r7,r7,#1
00002c  b2bb              UXTH     r3,r7
00002e  88e2              LDRH     r2,[r4,#6]
000030  88a7              LDRH     r7,[r4,#4]
000032  1d3f              ADDS     r7,r7,#4
000034  b2b9              UXTH     r1,r7
000036  8860              LDRH     r0,[r4,#2]
000038  f7fffffe          BL       LCD_DrawRect
;;;1256   
;;;1257   	/* 显示分组框标题（文字在左上角） */
;;;1258   	x = _pBox->Left + 9;
00003c  8860              LDRH     r0,[r4,#2]
00003e  3009              ADDS     r0,r0,#9
000040  b285              UXTH     r5,r0
;;;1259   	y = _pBox->Top;
000042  88a6              LDRH     r6,[r4,#4]
;;;1260   	LCD_DispStr(x, y, _pBox->pCaption, _pBox->Font);
000044  4631              MOV      r1,r6
000046  4628              MOV      r0,r5
000048  e9d43203          LDRD     r3,r2,[r4,#0xc]
00004c  f7fffffe          BL       LCD_DispStr
;;;1261   }
000050  bdf8              POP      {r3-r7,pc}
;;;1262   
                          ENDP


                          AREA ||i.LCD_DrawHColorLine||, CODE, READONLY, ALIGN=2

                  LCD_DrawHColorLine PROC
;;;1342   */
;;;1343   void LCD_DrawHColorLine(uint16_t _usX1 , uint16_t _usY1, uint16_t _usWidth, uint16_t *_pColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1344   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1345   	if (g_ChipID == IC_8875)
00000c  4809              LDR      r0,|L16.52|
00000e  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000010  2875              CMP      r0,#0x75
000012  d106              BNE      |L16.34|
;;;1346   	{
;;;1347   		RA8875_DrawHColorLine(_usX1, _usY1, _usWidth, _pColor);
000014  463b              MOV      r3,r7
000016  4632              MOV      r2,r6
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       RA8875_DrawHColorLine
000020  e005              B        |L16.46|
                  |L16.34|
;;;1348   	}
;;;1349   	else
;;;1350   	{
;;;1351   		SPFD5420_DrawHColorLine(_usX1, _usY1, _usWidth, _pColor);
000022  463b              MOV      r3,r7
000024  4632              MOV      r2,r6
000026  4629              MOV      r1,r5
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       SPFD5420_DrawHColorLine
                  |L16.46|
;;;1352   	}
;;;1353   }
00002e  e8bd81f0          POP      {r4-r8,pc}
;;;1354   
                          ENDP

000032  0000              DCW      0x0000
                  |L16.52|
                          DCD      g_ChipID

                          AREA ||i.LCD_DrawIcon||, CODE, READONLY, ALIGN=1

                  LCD_DrawIcon PROC
;;;644    */
;;;645    void LCD_DrawIcon(const ICON_T *_tIcon, FONT_T *_tFont, uint8_t _ucFocusMode)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;646    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;647    	const uint16_t *p;
;;;648    	uint16_t usNewRGB;
;;;649    	uint16_t x, y;		/* 用于记录窗口内的相对坐标 */
;;;650    
;;;651    	p = _tIcon->pBmp;
000008  f8d4a00c          LDR      r10,[r4,#0xc]
;;;652    	for (y = 0; y < _tIcon->Height; y++)
00000c  2600              MOVS     r6,#0
00000e  e0ad              B        |L17.364|
                  |L17.16|
;;;653    	{
;;;654    		for (x = 0; x < _tIcon->Width; x++)
000010  2500              MOVS     r5,#0
000012  e0a5              B        |L17.352|
                  |L17.20|
;;;655    		{
;;;656    			usNewRGB = *p++;	/* 读取图标的颜色值后指针加1 */
000014  f83a8b02          LDRH     r8,[r10],#2
;;;657    			/* 将图标的4个直角切割为弧角，弧角外是背景图标 */
;;;658    			if ((y == 0 && (x < 6 || x > _tIcon->Width - 7)) ||
000018  b92e              CBNZ     r6,|L17.38|
00001a  2d06              CMP      r5,#6
                  |L17.28|
00001c  db77              BLT      |L17.270|
00001e  8920              LDRH     r0,[r4,#8]
000020  1fc0              SUBS     r0,r0,#7
000022  42a8              CMP      r0,r5
000024  dbfa              BLT      |L17.28|
                  |L17.38|
;;;659    				(y == 1 && (x < 4 || x > _tIcon->Width - 5)) ||
000026  2e01              CMP      r6,#1
000028  d105              BNE      |L17.54|
00002a  2d04              CMP      r5,#4
00002c  dbf6              BLT      |L17.28|
00002e  8920              LDRH     r0,[r4,#8]
000030  1f40              SUBS     r0,r0,#5
000032  42a8              CMP      r0,r5
000034  dbf2              BLT      |L17.28|
                  |L17.54|
;;;660    				(y == 2 && (x < 3 || x > _tIcon->Width - 4)) ||
000036  2e02              CMP      r6,#2
000038  d105              BNE      |L17.70|
00003a  2d03              CMP      r5,#3
00003c  dbee              BLT      |L17.28|
00003e  8920              LDRH     r0,[r4,#8]
000040  1f00              SUBS     r0,r0,#4
000042  42a8              CMP      r0,r5
000044  dbea              BLT      |L17.28|
                  |L17.70|
;;;661    				(y == 3 && (x < 2 || x > _tIcon->Width - 3)) ||
000046  2e03              CMP      r6,#3
000048  d105              BNE      |L17.86|
00004a  2d02              CMP      r5,#2
00004c  dbe6              BLT      |L17.28|
00004e  8920              LDRH     r0,[r4,#8]
000050  1ec0              SUBS     r0,r0,#3
000052  42a8              CMP      r0,r5
000054  dbe2              BLT      |L17.28|
                  |L17.86|
;;;662    				(y == 4 && (x < 1 || x > _tIcon->Width - 2)) ||
000056  2e04              CMP      r6,#4
000058  d105              BNE      |L17.102|
00005a  2d01              CMP      r5,#1
00005c  db7e              BLT      |L17.348|
00005e  8920              LDRH     r0,[r4,#8]
000060  1e80              SUBS     r0,r0,#2
000062  42a8              CMP      r0,r5
000064  db7a              BLT      |L17.348|
                  |L17.102|
;;;663    				(y == 5 && (x < 1 || x > _tIcon->Width - 2))	||
000066  2e05              CMP      r6,#5
000068  d105              BNE      |L17.118|
00006a  2d01              CMP      r5,#1
00006c  db76              BLT      |L17.348|
00006e  8920              LDRH     r0,[r4,#8]
000070  1e80              SUBS     r0,r0,#2
000072  42a8              CMP      r0,r5
000074  db72              BLT      |L17.348|
                  |L17.118|
;;;664    
;;;665    				(y == _tIcon->Height - 1 && (x < 6 || x > _tIcon->Width - 7)) ||
000076  88e0              LDRH     r0,[r4,#6]
000078  1e40              SUBS     r0,r0,#1
00007a  42b0              CMP      r0,r6
00007c  d105              BNE      |L17.138|
00007e  2d06              CMP      r5,#6
000080  db6c              BLT      |L17.348|
000082  8920              LDRH     r0,[r4,#8]
000084  1fc0              SUBS     r0,r0,#7
000086  42a8              CMP      r0,r5
000088  db68              BLT      |L17.348|
                  |L17.138|
;;;666    				(y == _tIcon->Height - 2 && (x < 4 || x > _tIcon->Width - 5)) ||
00008a  88e0              LDRH     r0,[r4,#6]
00008c  1e80              SUBS     r0,r0,#2
00008e  42b0              CMP      r0,r6
000090  d105              BNE      |L17.158|
000092  2d04              CMP      r5,#4
000094  db62              BLT      |L17.348|
000096  8920              LDRH     r0,[r4,#8]
000098  1f40              SUBS     r0,r0,#5
00009a  42a8              CMP      r0,r5
00009c  db5e              BLT      |L17.348|
                  |L17.158|
;;;667    				(y == _tIcon->Height - 3 && (x < 3 || x > _tIcon->Width - 4)) ||
00009e  88e0              LDRH     r0,[r4,#6]
0000a0  1ec0              SUBS     r0,r0,#3
0000a2  42b0              CMP      r0,r6
0000a4  d105              BNE      |L17.178|
0000a6  2d03              CMP      r5,#3
0000a8  db58              BLT      |L17.348|
0000aa  8920              LDRH     r0,[r4,#8]
0000ac  1f00              SUBS     r0,r0,#4
0000ae  42a8              CMP      r0,r5
0000b0  db54              BLT      |L17.348|
                  |L17.178|
;;;668    				(y == _tIcon->Height - 4 && (x < 2 || x > _tIcon->Width - 3)) ||
0000b2  88e0              LDRH     r0,[r4,#6]
0000b4  1f00              SUBS     r0,r0,#4
0000b6  42b0              CMP      r0,r6
0000b8  d105              BNE      |L17.198|
0000ba  2d02              CMP      r5,#2
0000bc  db4e              BLT      |L17.348|
0000be  8920              LDRH     r0,[r4,#8]
0000c0  1ec0              SUBS     r0,r0,#3
0000c2  42a8              CMP      r0,r5
0000c4  db4a              BLT      |L17.348|
                  |L17.198|
;;;669    				(y == _tIcon->Height - 5 && (x < 1 || x > _tIcon->Width - 2)) ||
0000c6  88e0              LDRH     r0,[r4,#6]
0000c8  1f40              SUBS     r0,r0,#5
0000ca  42b0              CMP      r0,r6
0000cc  d105              BNE      |L17.218|
0000ce  2d01              CMP      r5,#1
0000d0  db44              BLT      |L17.348|
0000d2  8920              LDRH     r0,[r4,#8]
0000d4  1e80              SUBS     r0,r0,#2
0000d6  42a8              CMP      r0,r5
0000d8  db40              BLT      |L17.348|
                  |L17.218|
;;;670    				(y == _tIcon->Height - 6 && (x < 1 || x > _tIcon->Width - 2))
0000da  88e0              LDRH     r0,[r4,#6]
0000dc  1f80              SUBS     r0,r0,#6
0000de  42b0              CMP      r0,r6
0000e0  d105              BNE      |L17.238|
0000e2  2d01              CMP      r5,#1
0000e4  db3a              BLT      |L17.348|
0000e6  8920              LDRH     r0,[r4,#8]
0000e8  1e80              SUBS     r0,r0,#2
0000ea  42a8              CMP      r0,r5
0000ec  db36              BLT      |L17.348|
                  |L17.238|
;;;671    				)
;;;672    			{
;;;673    				;
;;;674    			}
;;;675    			else
;;;676    			{
;;;677    				if (_ucFocusMode != 0)	/* 1表示选中的图标 */
0000ee  9802              LDR      r0,[sp,#8]
0000f0  b358              CBZ      r0,|L17.330|
;;;678    				{
;;;679    					/* 降低原始像素的亮度，实现图标被激活选中的效果 */
;;;680    					uint16_t R,G,B;
;;;681    					uint16_t bright = 15;
0000f2  200f              MOVS     r0,#0xf
;;;682    
;;;683    					/* rrrr rggg gggb bbbb */
;;;684    					R = (usNewRGB & 0xF800) >> 11;
0000f4  ea4f21d8          LSR      r1,r8,#11
;;;685    					G = (usNewRGB & 0x07E0) >> 5;
0000f8  f3c81245          UBFX     r2,r8,#5,#6
;;;686    					B =  usNewRGB & 0x001F;
0000fc  f008031f          AND      r3,r8,#0x1f
;;;687    					if (R > bright)
000100  4281              CMP      r1,r0
000102  dd05              BLE      |L17.272|
;;;688    					{
;;;689    						R -= bright;
000104  eba10c00          SUB      r12,r1,r0
000108  fa1ff18c          UXTH     r1,r12
00010c  e001              B        |L17.274|
                  |L17.270|
00010e  e025              B        |L17.348|
                  |L17.272|
;;;690    					}
;;;691    					else
;;;692    					{
;;;693    						R = 0;
000110  2100              MOVS     r1,#0
                  |L17.274|
;;;694    					}
;;;695    					if (G > 2 * bright)
000112  ea4f0c40          LSL      r12,r0,#1
000116  4594              CMP      r12,r2
000118  da06              BGE      |L17.296|
;;;696    					{
;;;697    						G -= 2 * bright;
00011a  f04f0c02          MOV      r12,#2
00011e  fb0c2c10          MLS      r12,r12,r0,r2
000122  fa1ff28c          UXTH     r2,r12
000126  e000              B        |L17.298|
                  |L17.296|
;;;698    					}
;;;699    					else
;;;700    					{
;;;701    						G = 0;
000128  2200              MOVS     r2,#0
                  |L17.298|
;;;702    					}
;;;703    					if (B > bright)
00012a  4283              CMP      r3,r0
00012c  dd04              BLE      |L17.312|
;;;704    					{
;;;705    						B -= bright;
00012e  eba30c00          SUB      r12,r3,r0
000132  fa1ff38c          UXTH     r3,r12
000136  e000              B        |L17.314|
                  |L17.312|
;;;706    					}
;;;707    					else
;;;708    					{
;;;709    						B = 0;
000138  2300              MOVS     r3,#0
                  |L17.314|
;;;710    					}
;;;711    					usNewRGB = (R << 11) + (G << 5) + B;
00013a  ea4f2cc1          LSL      r12,r1,#11
00013e  eb0c1c42          ADD      r12,r12,r2,LSL #5
000142  449c              ADD      r12,r12,r3
000144  fa1ff88c          UXTH     r8,r12
;;;712    				}
000148  bf00              NOP      
                  |L17.330|
;;;713    
;;;714    				LCD_PutPixel(x + _tIcon->Left, y + _tIcon->Top, usNewRGB);
00014a  88a2              LDRH     r2,[r4,#4]
00014c  4432              ADD      r2,r2,r6
00014e  b291              UXTH     r1,r2
000150  8862              LDRH     r2,[r4,#2]
000152  442a              ADD      r2,r2,r5
000154  b290              UXTH     r0,r2
000156  4642              MOV      r2,r8
000158  f7fffffe          BL       LCD_PutPixel
                  |L17.348|
00015c  1c68              ADDS     r0,r5,#1              ;654
00015e  b285              UXTH     r5,r0                 ;654
                  |L17.352|
000160  8920              LDRH     r0,[r4,#8]            ;654
000162  42a8              CMP      r0,r5                 ;654
000164  f73faf56          BGT      |L17.20|
000168  1c70              ADDS     r0,r6,#1              ;652
00016a  b286              UXTH     r6,r0                 ;652
                  |L17.364|
00016c  88e0              LDRH     r0,[r4,#6]            ;652
00016e  42b0              CMP      r0,r6                 ;652
000170  f73faf4e          BGT      |L17.16|
;;;715    			}
;;;716    		}
;;;717    	}
;;;718    
;;;719    	/* 绘制图标下的文字 */
;;;720    	{
;;;721    		uint16_t len;
;;;722    		uint16_t width;
;;;723    
;;;724    		len = strlen(_tIcon->Text);
000174  f1040010          ADD      r0,r4,#0x10
000178  f7fffffe          BL       strlen
00017c  fa1ffb80          UXTH     r11,r0
;;;725    
;;;726    		if  (len == 0)
000180  f1bb0f00          CMP      r11,#0
000184  d101              BNE      |L17.394|
                  |L17.390|
;;;727    		{
;;;728    			return;	/* 如果图标文本长度为0，则不显示 */
;;;729    		}
;;;730    
;;;731    		/* 计算文本的总宽度 */
;;;732    		if (_tFont->FontCode == FC_ST_12)		/* 12点阵 */
;;;733    		{
;;;734    			width = 6 * (len + _tFont->Space);
;;;735    		}
;;;736    		else	/* FC_ST_16 */
;;;737    		{
;;;738    			width = 8 * (len + _tFont->Space);
;;;739    		}
;;;740    
;;;741    
;;;742    		/* 水平居中 */
;;;743    		x = (_tIcon->Left + _tIcon->Width / 2) - width / 2;
;;;744    		y = _tIcon->Top + _tIcon->Height + 2;
;;;745    		LCD_DispStr(x, y, (char *)_tIcon->Text, _tFont);
;;;746    	}
;;;747    }
000186  e8bd8ffe          POP      {r1-r11,pc}
                  |L17.394|
00018a  8838              LDRH     r0,[r7,#0]            ;732
00018c  2801              CMP      r0,#1                 ;732
00018e  d107              BNE      |L17.416|
000190  88f8              LDRH     r0,[r7,#6]            ;734
000192  4458              ADD      r0,r0,r11             ;734
000194  eb000040          ADD      r0,r0,r0,LSL #1       ;734
000198  0440              LSLS     r0,r0,#17             ;734
00019a  ea4f4910          LSR      r9,r0,#16             ;734
00019e  e004              B        |L17.426|
                  |L17.416|
0001a0  88f8              LDRH     r0,[r7,#6]            ;738
0001a2  4458              ADD      r0,r0,r11             ;738
0001a4  04c0              LSLS     r0,r0,#19             ;738
0001a6  ea4f4910          LSR      r9,r0,#16             ;738
                  |L17.426|
0001aa  8920              LDRH     r0,[r4,#8]            ;743
0001ac  eb0072d0          ADD      r2,r0,r0,LSR #31      ;743
0001b0  8863              LDRH     r3,[r4,#2]            ;743
0001b2  eb030262          ADD      r2,r3,r2,ASR #1       ;743
0001b6  4649              MOV      r1,r9                 ;743
0001b8  eb0973d1          ADD      r3,r9,r1,LSR #31      ;743
0001bc  eba20263          SUB      r2,r2,r3,ASR #1       ;743
0001c0  b295              UXTH     r5,r2                 ;743
0001c2  88a0              LDRH     r0,[r4,#4]            ;744
0001c4  88e1              LDRH     r1,[r4,#6]            ;744
0001c6  4408              ADD      r0,r0,r1              ;744
0001c8  1c80              ADDS     r0,r0,#2              ;744
0001ca  b286              UXTH     r6,r0                 ;744
0001cc  463b              MOV      r3,r7                 ;745
0001ce  f1040210          ADD      r2,r4,#0x10           ;745
0001d2  4631              MOV      r1,r6                 ;745
0001d4  4628              MOV      r0,r5                 ;745
0001d6  f7fffffe          BL       LCD_DispStr
0001da  bf00              NOP      
0001dc  e7d3              B        |L17.390|
;;;748    
                          ENDP


                          AREA ||i.LCD_DrawIcon32||, CODE, READONLY, ALIGN=1

                  LCD_DrawIcon32 PROC
;;;773    */
;;;774    void LCD_DrawIcon32(const ICON_T *_tIcon, FONT_T *_tFont, uint8_t _ucFocusMode)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;775    {
000004  b088              SUB      sp,sp,#0x20
000006  4604              MOV      r4,r0
000008  4689              MOV      r9,r1
;;;776    	const uint8_t *p;
;;;777    	uint16_t usOldRGB, usNewRGB;
;;;778    	int16_t x, y;		/* 用于记录窗口内的相对坐标 */
;;;779    	uint8_t R1,G1,B1,A;	/* 新像素色彩分量 */
;;;780    	uint8_t R0,G0,B0;	/* 旧像素色彩分量 */
;;;781    
;;;782    	p = (const uint8_t *)_tIcon->pBmp;
00000a  68e5              LDR      r5,[r4,#0xc]
;;;783    	p += 54;		/* 直接指向图像数据区 */
00000c  3536              ADDS     r5,r5,#0x36
;;;784    
;;;785    	/* 按照BMP位图次序，从左至右，从上至下扫描 */
;;;786    	for (y = _tIcon->Height - 1; y >= 0; y--)
00000e  88e0              LDRH     r0,[r4,#6]
000010  1e40              SUBS     r0,r0,#1
000012  fa0ff880          SXTH     r8,r0
000016  e099              B        |L18.332|
                  |L18.24|
;;;787    	{
;;;788    		for (x = 0; x < _tIcon->Width; x++)
000018  2700              MOVS     r7,#0
00001a  e08f              B        |L18.316|
                  |L18.28|
;;;789    		{
;;;790    			B1 = *p++;
00001c  f8150b01          LDRB     r0,[r5],#1
000020  9004              STR      r0,[sp,#0x10]
;;;791    			G1 = *p++;
000022  f8150b01          LDRB     r0,[r5],#1
000026  9005              STR      r0,[sp,#0x14]
;;;792    			R1 = *p++;
000028  f8150b01          LDRB     r0,[r5],#1
00002c  9006              STR      r0,[sp,#0x18]
;;;793    			A = *p++;	/* Alpha 值(透明度)，0-255, 0表示透明，1表示不透明, 中间值表示透明度 */
00002e  f8156b01          LDRB     r6,[r5],#1
;;;794    
;;;795    			if (A == 0x00)	/* 需要透明,显示背景 */
000032  2e00              CMP      r6,#0
000034  d01f              BEQ      |L18.118|
;;;796    			{
;;;797    				;	/* 不用刷新背景 */
;;;798    			}
;;;799    			else if (A == 0xFF)	/* 完全不透明， 显示新像素 */
000036  2eff              CMP      r6,#0xff
000038  d11e              BNE      |L18.120|
;;;800    			{
;;;801    				usNewRGB = RGB(R1, G1, B1);
00003a  9806              LDR      r0,[sp,#0x18]
00003c  10c0              ASRS     r0,r0,#3
00003e  02c1              LSLS     r1,r0,#11
000040  9805              LDR      r0,[sp,#0x14]
000042  1080              ASRS     r0,r0,#2
000044  ea411140          ORR      r1,r1,r0,LSL #5
000048  9804              LDR      r0,[sp,#0x10]
00004a  ea4100e0          ORR      r0,r1,r0,ASR #3
00004e  9007              STR      r0,[sp,#0x1c]
;;;802    				if (_ucFocusMode == 1)
000050  980a              LDR      r0,[sp,#0x28]
000052  2801              CMP      r0,#1
000054  d106              BNE      |L18.100|
;;;803    				{
;;;804    					usNewRGB = Blend565(usNewRGB, CL_YELLOW, 10);
000056  220a              MOVS     r2,#0xa
000058  f64f71e0          MOV      r1,#0xffe0
00005c  9807              LDR      r0,[sp,#0x1c]
00005e  f7fffffe          BL       Blend565
000062  9007              STR      r0,[sp,#0x1c]
                  |L18.100|
;;;805    				}
;;;806    				LCD_PutPixel(x + _tIcon->Left, y + _tIcon->Top, usNewRGB);
000064  88a2              LDRH     r2,[r4,#4]
000066  4442              ADD      r2,r2,r8
000068  b291              UXTH     r1,r2
00006a  8862              LDRH     r2,[r4,#2]
00006c  443a              ADD      r2,r2,r7
00006e  b290              UXTH     r0,r2
000070  9a07              LDR      r2,[sp,#0x1c]
000072  f7fffffe          BL       LCD_PutPixel
                  |L18.118|
000076  e05f              B        |L18.312|
                  |L18.120|
;;;807    			}
;;;808    			else 	/* 半透明 */
;;;809    			{
;;;810    				/* 计算公式： 实际显示颜色 = 前景颜色 * Alpha / 255 + 背景颜色 * (255-Alpha) / 255 */
;;;811    				usOldRGB = LCD_GetPixel(x + _tIcon->Left, y + _tIcon->Top);
000078  88a2              LDRH     r2,[r4,#4]
00007a  4442              ADD      r2,r2,r8
00007c  b291              UXTH     r1,r2
00007e  8862              LDRH     r2,[r4,#2]
000080  443a              ADD      r2,r2,r7
000082  b290              UXTH     r0,r2
000084  f7fffffe          BL       LCD_GetPixel
000088  4682              MOV      r10,r0
;;;812    				R0 = RGB565_R(usOldRGB);
00008a  21f8              MOVS     r1,#0xf8
00008c  ea01202a          AND      r0,r1,r10,ASR #8
000090  9003              STR      r0,[sp,#0xc]
;;;813    				G0 = RGB565_G(usOldRGB);
000092  21fc              MOVS     r1,#0xfc
000094  ea0100ea          AND      r0,r1,r10,ASR #3
000098  9002              STR      r0,[sp,#8]
;;;814    				B0 = RGB565_B(usOldRGB);
00009a  21f8              MOVS     r1,#0xf8
00009c  ea0100ca          AND      r0,r1,r10,LSL #3
0000a0  9001              STR      r0,[sp,#4]
;;;815    
;;;816    				R1 = (R1 * A) / 255 + R0 * (255 - A) / 255;
0000a2  9806              LDR      r0,[sp,#0x18]
0000a4  4370              MULS     r0,r6,r0
0000a6  21ff              MOVS     r1,#0xff
0000a8  fb90f2f1          SDIV     r2,r0,r1
0000ac  f1c601ff          RSB      r1,r6,#0xff
0000b0  9803              LDR      r0,[sp,#0xc]
0000b2  4341              MULS     r1,r0,r1
0000b4  20ff              MOVS     r0,#0xff
0000b6  fb91f0f0          SDIV     r0,r1,r0
0000ba  4410              ADD      r0,r0,r2
0000bc  b2c0              UXTB     r0,r0
0000be  9006              STR      r0,[sp,#0x18]
;;;817    				G1 = (G1 * A) / 255 + G0 * (255 - A) / 255;
0000c0  9805              LDR      r0,[sp,#0x14]
0000c2  4370              MULS     r0,r6,r0
0000c4  21ff              MOVS     r1,#0xff
0000c6  fb90f2f1          SDIV     r2,r0,r1
0000ca  f1c601ff          RSB      r1,r6,#0xff
0000ce  9802              LDR      r0,[sp,#8]
0000d0  4341              MULS     r1,r0,r1
0000d2  20ff              MOVS     r0,#0xff
0000d4  fb91f0f0          SDIV     r0,r1,r0
0000d8  4410              ADD      r0,r0,r2
0000da  b2c0              UXTB     r0,r0
0000dc  9005              STR      r0,[sp,#0x14]
;;;818    				B1 = (B1 * A) / 255 + B0 * (255 - A) / 255;
0000de  9804              LDR      r0,[sp,#0x10]
0000e0  4370              MULS     r0,r6,r0
0000e2  21ff              MOVS     r1,#0xff
0000e4  fb90f2f1          SDIV     r2,r0,r1
0000e8  f1c601ff          RSB      r1,r6,#0xff
0000ec  9801              LDR      r0,[sp,#4]
0000ee  4341              MULS     r1,r0,r1
0000f0  20ff              MOVS     r0,#0xff
0000f2  fb91f0f0          SDIV     r0,r1,r0
0000f6  4410              ADD      r0,r0,r2
0000f8  b2c0              UXTB     r0,r0
0000fa  9004              STR      r0,[sp,#0x10]
;;;819    				usNewRGB = RGB(R1, G1, B1);
0000fc  9806              LDR      r0,[sp,#0x18]
0000fe  10c0              ASRS     r0,r0,#3
000100  02c1              LSLS     r1,r0,#11
000102  9805              LDR      r0,[sp,#0x14]
000104  1080              ASRS     r0,r0,#2
000106  ea411140          ORR      r1,r1,r0,LSL #5
00010a  9804              LDR      r0,[sp,#0x10]
00010c  ea4100e0          ORR      r0,r1,r0,ASR #3
000110  9007              STR      r0,[sp,#0x1c]
;;;820    				if (_ucFocusMode == 1)
000112  980a              LDR      r0,[sp,#0x28]
000114  2801              CMP      r0,#1
000116  d106              BNE      |L18.294|
;;;821    				{
;;;822    					usNewRGB = Blend565(usNewRGB, CL_YELLOW, 10);
000118  220a              MOVS     r2,#0xa
00011a  f64f71e0          MOV      r1,#0xffe0
00011e  9807              LDR      r0,[sp,#0x1c]
000120  f7fffffe          BL       Blend565
000124  9007              STR      r0,[sp,#0x1c]
                  |L18.294|
;;;823    				}
;;;824    				LCD_PutPixel(x + _tIcon->Left, y + _tIcon->Top, usNewRGB);
000126  88a2              LDRH     r2,[r4,#4]
000128  4442              ADD      r2,r2,r8
00012a  b291              UXTH     r1,r2
00012c  8862              LDRH     r2,[r4,#2]
00012e  443a              ADD      r2,r2,r7
000130  b290              UXTH     r0,r2
000132  9a07              LDR      r2,[sp,#0x1c]
000134  f7fffffe          BL       LCD_PutPixel
                  |L18.312|
000138  1c78              ADDS     r0,r7,#1              ;788
00013a  b207              SXTH     r7,r0                 ;788
                  |L18.316|
00013c  8920              LDRH     r0,[r4,#8]            ;788
00013e  42b8              CMP      r0,r7                 ;788
000140  f73faf6c          BGT      |L18.28|
000144  f1a80001          SUB      r0,r8,#1              ;786
000148  fa0ff880          SXTH     r8,r0                 ;786
                  |L18.332|
00014c  f1b80f00          CMP      r8,#0                 ;786
000150  f6bfaf62          BGE      |L18.24|
;;;825    			}
;;;826    		}
;;;827    	}
;;;828    
;;;829    	/* 绘制图标下的文字 */
;;;830    	{
;;;831    		uint16_t len;
;;;832    		uint16_t width;
;;;833    
;;;834    		len = strlen(_tIcon->Text);
000154  f1040010          ADD      r0,r4,#0x10
000158  f7fffffe          BL       strlen
00015c  b280              UXTH     r0,r0
00015e  9000              STR      r0,[sp,#0]
;;;835    
;;;836    		if  (len == 0)
000160  9800              LDR      r0,[sp,#0]
000162  b910              CBNZ     r0,|L18.362|
                  |L18.356|
;;;837    		{
;;;838    			return;	/* 如果图标文本长度为0，则不显示 */
;;;839    		}
;;;840    
;;;841    		/* 计算文本的总宽度 */
;;;842    		if (_tFont->FontCode == FC_ST_12)		/* 12点阵 */
;;;843    		{
;;;844    			width = 6 * (len + _tFont->Space);
;;;845    		}
;;;846    		else	/* FC_ST_16 */
;;;847    		{
;;;848    			width = 8 * (len + _tFont->Space);
;;;849    		}
;;;850    
;;;851    
;;;852    		/* 水平居中 */
;;;853    		x = (_tIcon->Left + _tIcon->Width / 2) - width / 2;
;;;854    		y = _tIcon->Top + _tIcon->Height + 2;
;;;855    		LCD_DispStr(x, y, (char *)_tIcon->Text, _tFont);
;;;856    	}
;;;857    }
000164  b00b              ADD      sp,sp,#0x2c
000166  e8bd8ff0          POP      {r4-r11,pc}
                  |L18.362|
00016a  f8b90000          LDRH     r0,[r9,#0]            ;842
00016e  2801              CMP      r0,#1                 ;842
000170  d109              BNE      |L18.390|
000172  f8b91006          LDRH     r1,[r9,#6]            ;844
000176  9800              LDR      r0,[sp,#0]            ;844
000178  4408              ADD      r0,r0,r1              ;844
00017a  eb000040          ADD      r0,r0,r0,LSL #1       ;844
00017e  0440              LSLS     r0,r0,#17             ;844
000180  ea4f4b10          LSR      r11,r0,#16            ;844
000184  e006              B        |L18.404|
                  |L18.390|
000186  f8b91006          LDRH     r1,[r9,#6]            ;848
00018a  9800              LDR      r0,[sp,#0]            ;848
00018c  4408              ADD      r0,r0,r1              ;848
00018e  04c0              LSLS     r0,r0,#19             ;848
000190  ea4f4b10          LSR      r11,r0,#16            ;848
                  |L18.404|
000194  8920              LDRH     r0,[r4,#8]            ;853
000196  eb0072d0          ADD      r2,r0,r0,LSR #31      ;853
00019a  8863              LDRH     r3,[r4,#2]            ;853
00019c  eb030262          ADD      r2,r3,r2,ASR #1       ;853
0001a0  4659              MOV      r1,r11                ;853
0001a2  eb0b73d1          ADD      r3,r11,r1,LSR #31     ;853
0001a6  eba20263          SUB      r2,r2,r3,ASR #1       ;853
0001aa  b217              SXTH     r7,r2                 ;853
0001ac  88a0              LDRH     r0,[r4,#4]            ;854
0001ae  88e1              LDRH     r1,[r4,#6]            ;854
0001b0  4408              ADD      r0,r0,r1              ;854
0001b2  1c80              ADDS     r0,r0,#2              ;854
0001b4  fa0ff880          SXTH     r8,r0                 ;854
0001b8  fa1ff188          UXTH     r1,r8                 ;855
0001bc  b2b8              UXTH     r0,r7                 ;855
0001be  464b              MOV      r3,r9                 ;855
0001c0  f1040210          ADD      r2,r4,#0x10           ;855
0001c4  f7fffffe          BL       LCD_DispStr
0001c8  bf00              NOP      
0001ca  e7cb              B        |L18.356|
;;;858    
                          ENDP


                          AREA ||i.LCD_DrawLabel||, CODE, READONLY, ALIGN=1

                  LCD_DrawLabel PROC
;;;932    */
;;;933    void LCD_DrawLabel(LABEL_T *_pLabel)
000000  b5f0              PUSH     {r4-r7,lr}
;;;934    {
000002  b0c1              SUB      sp,sp,#0x104
000004  4604              MOV      r4,r0
;;;935    #if 1
;;;936    	char dispbuf[256];
;;;937    	uint16_t i;
;;;938    	uint16_t NewLen;
;;;939    
;;;940    	NewLen = strlen(_pLabel->pCaption);
000006  6920              LDR      r0,[r4,#0x10]
000008  f7fffffe          BL       strlen
00000c  b286              UXTH     r6,r0
;;;941    
;;;942    	if (NewLen > _pLabel->MaxLen)
00000e  8960              LDRH     r0,[r4,#0xa]
000010  42b0              CMP      r0,r6
000012  da07              BGE      |L19.36|
;;;943    	{
;;;944    		LCD_DispStr(_pLabel->Left, _pLabel->Top, _pLabel->pCaption, _pLabel->Font);
000014  88a1              LDRH     r1,[r4,#4]
000016  8860              LDRH     r0,[r4,#2]
000018  e9d43203          LDRD     r3,r2,[r4,#0xc]
00001c  f7fffffe          BL       LCD_DispStr
;;;945    		_pLabel->MaxLen = NewLen;
000020  8166              STRH     r6,[r4,#0xa]
000022  e01b              B        |L19.92|
                  |L19.36|
;;;946    	}
;;;947    	else
;;;948    	{
;;;949    		for (i = 0; i < NewLen; i++)
000024  2500              MOVS     r5,#0
000026  e005              B        |L19.52|
                  |L19.40|
;;;950    		{
;;;951    			dispbuf[i] = _pLabel->pCaption[i];
000028  6920              LDR      r0,[r4,#0x10]
00002a  5d40              LDRB     r0,[r0,r5]
00002c  a901              ADD      r1,sp,#4
00002e  5548              STRB     r0,[r1,r5]
000030  1c68              ADDS     r0,r5,#1              ;949
000032  b285              UXTH     r5,r0                 ;949
                  |L19.52|
000034  42b5              CMP      r5,r6                 ;949
000036  dbf7              BLT      |L19.40|
;;;952    		}
;;;953    		for (; i < _pLabel->MaxLen; i++)
000038  e004              B        |L19.68|
                  |L19.58|
;;;954    		{
;;;955    			dispbuf[i] = ' ';		/* 末尾填充空格 */
00003a  2020              MOVS     r0,#0x20
00003c  a901              ADD      r1,sp,#4
00003e  5548              STRB     r0,[r1,r5]
000040  1c68              ADDS     r0,r5,#1              ;953
000042  b285              UXTH     r5,r0                 ;953
                  |L19.68|
000044  8960              LDRH     r0,[r4,#0xa]          ;953
000046  42a8              CMP      r0,r5                 ;953
000048  dcf7              BGT      |L19.58|
;;;956    		}
;;;957    		dispbuf[i] = 0;
00004a  2000              MOVS     r0,#0
00004c  a901              ADD      r1,sp,#4
00004e  5548              STRB     r0,[r1,r5]
;;;958    		LCD_DispStr(_pLabel->Left, _pLabel->Top, dispbuf, _pLabel->Font);
000050  88a1              LDRH     r1,[r4,#4]
000052  8860              LDRH     r0,[r4,#2]
000054  aa01              ADD      r2,sp,#4
000056  68e3              LDR      r3,[r4,#0xc]
000058  f7fffffe          BL       LCD_DispStr
                  |L19.92|
;;;959    	}
;;;960    #else
;;;961    	if (g_ChipID == IC_8875)
;;;962    	{
;;;963    		RA8875_SetFont(_pLabel->Font->FontCode, 0, 0);	/* 设置32点阵字体，行间距=0，字间距=0 */
;;;964    
;;;965    		RA8875_SetBackColor(_pLabel->Font->BackColor);
;;;966    		RA8875_SetFrontColor(_pLabel->Font->FrontColor);
;;;967    
;;;968    		RA8875_DispStr(_pLabel->Left, _pLabel->Top, _pLabel->Caption);
;;;969    	}
;;;970    	else
;;;971    	{
;;;972    
;;;973    	}
;;;974    #endif
;;;975    }
00005c  b041              ADD      sp,sp,#0x104
00005e  bdf0              POP      {r4-r7,pc}
;;;976    
                          ENDP


                          AREA ||i.LCD_DrawLine||, CODE, READONLY, ALIGN=2

                  LCD_DrawLine PROC
;;;446    */
;;;447    void LCD_DrawLine(uint16_t _usX1 , uint16_t _usY1 , uint16_t _usX2 , uint16_t _usY2 , uint16_t _usColor)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;448    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9c08              LDR      r4,[sp,#0x20]
;;;449    	if (g_ChipID == IC_8875)
00000e  480a              LDR      r0,|L20.56|
000010  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000012  2875              CMP      r0,#0x75
000014  d107              BNE      |L20.38|
;;;450    	{
;;;451    		RA8875_DrawLine(_usX1 , _usY1 , _usX2, _usY2 , _usColor);
000016  4643              MOV      r3,r8
000018  463a              MOV      r2,r7
00001a  4631              MOV      r1,r6
00001c  4628              MOV      r0,r5
00001e  9400              STR      r4,[sp,#0]
000020  f7fffffe          BL       RA8875_DrawLine
000024  e006              B        |L20.52|
                  |L20.38|
;;;452    	}
;;;453    	else
;;;454    	{
;;;455    		SPFD5420_DrawLine(_usX1 , _usY1 , _usX2, _usY2 , _usColor);
000026  4643              MOV      r3,r8
000028  463a              MOV      r2,r7
00002a  4631              MOV      r1,r6
00002c  4628              MOV      r0,r5
00002e  9400              STR      r4,[sp,#0]
000030  f7fffffe          BL       SPFD5420_DrawLine
                  |L20.52|
;;;456    	}
;;;457    }
000034  e8bd83f8          POP      {r3-r9,pc}
;;;458    
                          ENDP

                  |L20.56|
                          DCD      g_ChipID

                          AREA ||i.LCD_DrawLineH||, CODE, READONLY, ALIGN=2

                  LCD_DrawLineH PROC
;;;1319   */
;;;1320   void LCD_DrawLineH(uint16_t _usX1 , uint16_t _usY1 , uint16_t _usX2, uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1321   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1322   	if (g_ChipID == IC_8875)
00000c  4809              LDR      r0,|L21.52|
00000e  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000010  2875              CMP      r0,#0x75
000012  d106              BNE      |L21.34|
;;;1323   	{
;;;1324   		RA8875_DrawHLine(_usX1, _usY1, _usX2, _usColor);
000014  463b              MOV      r3,r7
000016  4632              MOV      r2,r6
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       RA8875_DrawHLine
000020  e005              B        |L21.46|
                  |L21.34|
;;;1325   	}
;;;1326   	else
;;;1327   	{
;;;1328   		SPFD5420_DrawHLine(_usX1, _usY1, _usX2, _usColor);
000022  463b              MOV      r3,r7
000024  4632              MOV      r2,r6
000026  4629              MOV      r1,r5
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       SPFD5420_DrawHLine
                  |L21.46|
;;;1329   	}
;;;1330   }
00002e  e8bd81f0          POP      {r4-r8,pc}
;;;1331   
                          ENDP

000032  0000              DCW      0x0000
                  |L21.52|
                          DCD      g_ChipID

                          AREA ||i.LCD_DrawLineV||, CODE, READONLY, ALIGN=2

                  LCD_DrawLineV PROC
;;;1365   */
;;;1366   void LCD_DrawLineV(uint16_t _usX1 , uint16_t _usY1 , uint16_t _usY2, uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1367   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1368   	if (g_ChipID == IC_8875)
00000c  4809              LDR      r0,|L22.52|
00000e  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000010  2875              CMP      r0,#0x75
000012  d106              BNE      |L22.34|
;;;1369   	{
;;;1370   		RA8875_DrawVLine(_usX1 , _usY1 , _usY2 , _usColor);
000014  463b              MOV      r3,r7
000016  4632              MOV      r2,r6
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       RA8875_DrawVLine
000020  e005              B        |L22.46|
                  |L22.34|
;;;1371   	}
;;;1372   	else
;;;1373   	{
;;;1374   		SPFD5420_DrawVLine(_usX1 , _usY1 , _usY2, _usColor);
000022  463b              MOV      r3,r7
000024  4632              MOV      r2,r6
000026  4629              MOV      r1,r5
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       SPFD5420_DrawVLine
                  |L22.46|
;;;1375   	}
;;;1376   }
00002e  e8bd81f0          POP      {r4-r8,pc}
;;;1377   
                          ENDP

000032  0000              DCW      0x0000
                  |L22.52|
                          DCD      g_ChipID

                          AREA ||i.LCD_DrawPoints||, CODE, READONLY, ALIGN=1

                  LCD_DrawPoints PROC
;;;468    */
;;;469    void LCD_DrawPoints(uint16_t *x, uint16_t *y, uint16_t _usSize, uint16_t _usColor)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;470    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;471    	uint16_t i;
;;;472    
;;;473    	for (i = 0 ; i < _usSize - 1; i++)
00000c  2400              MOVS     r4,#0
00000e  e00f              B        |L23.48|
                  |L23.16|
;;;474    	{
;;;475    		LCD_DrawLine(x[i], y[i], x[i + 1], y[i + 1], _usColor);
000010  f1040c01          ADD      r12,r4,#1
000014  f8cd8000          STR      r8,[sp,#0]
000018  f836301c          LDRH     r3,[r6,r12,LSL #1]
00001c  f835201c          LDRH     r2,[r5,r12,LSL #1]
000020  f8361014          LDRH     r1,[r6,r4,LSL #1]
000024  f8350014          LDRH     r0,[r5,r4,LSL #1]
000028  f7fffffe          BL       LCD_DrawLine
00002c  1c60              ADDS     r0,r4,#1              ;473
00002e  b284              UXTH     r4,r0                 ;473
                  |L23.48|
000030  1e78              SUBS     r0,r7,#1              ;473
000032  42a0              CMP      r0,r4                 ;473
000034  dcec              BGT      |L23.16|
;;;476    	}
;;;477    }
000036  e8bd83f8          POP      {r3-r9,pc}
;;;478    
                          ENDP


                          AREA ||i.LCD_DrawRect||, CODE, READONLY, ALIGN=2

                  LCD_DrawRect PROC
;;;489    */
;;;490    void LCD_DrawRect(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint16_t _usColor)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;491    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  4698              MOV      r8,r3
00000c  9d08              LDR      r5,[sp,#0x20]
;;;492    	if (g_ChipID == IC_8875)
00000e  480a              LDR      r0,|L24.56|
000010  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000012  2875              CMP      r0,#0x75
000014  d107              BNE      |L24.38|
;;;493    	{
;;;494    		RA8875_DrawRect(_usX, _usY, _usHeight, _usWidth, _usColor);
000016  4643              MOV      r3,r8
000018  4622              MOV      r2,r4
00001a  4639              MOV      r1,r7
00001c  4630              MOV      r0,r6
00001e  9500              STR      r5,[sp,#0]
000020  f7fffffe          BL       RA8875_DrawRect
000024  e006              B        |L24.52|
                  |L24.38|
;;;495    	}
;;;496    	else
;;;497    	{
;;;498    		SPFD5420_DrawRect(_usX, _usY, _usHeight, _usWidth, _usColor);
000026  b2e2              UXTB     r2,r4
000028  4643              MOV      r3,r8
00002a  4639              MOV      r1,r7
00002c  4630              MOV      r0,r6
00002e  9500              STR      r5,[sp,#0]
000030  f7fffffe          BL       SPFD5420_DrawRect
                  |L24.52|
;;;499    	}
;;;500    }
000034  e8bd83f8          POP      {r3-r9,pc}
;;;501    
                          ENDP

                  |L24.56|
                          DCD      g_ChipID

                          AREA ||i.LCD_DrawWin||, CODE, READONLY, ALIGN=1

                  LCD_DrawWin PROC
;;;583    */
;;;584    void LCD_DrawWin(WIN_T *_pWin)
000000  b5f8              PUSH     {r3-r7,lr}
;;;585    {
000002  4604              MOV      r4,r0
;;;586    #if 1
;;;587    	uint16_t TitleHegiht;
;;;588    
;;;589    	TitleHegiht = 20;
000004  2514              MOVS     r5,#0x14
;;;590    
;;;591    	/* 绘制窗口外框 */
;;;592    	LCD_DrawRect(_pWin->Left, _pWin->Top, _pWin->Height, _pWin->Width, WIN_BORDER_COLOR);
000006  f44f7004          MOV      r0,#0x210
00000a  9000              STR      r0,[sp,#0]
00000c  8923              LDRH     r3,[r4,#8]
00000e  88e2              LDRH     r2,[r4,#6]
000010  88a1              LDRH     r1,[r4,#4]
000012  8860              LDRH     r0,[r4,#2]
000014  f7fffffe          BL       LCD_DrawRect
;;;593    	LCD_DrawRect(_pWin->Left + 1, _pWin->Top + 1, _pWin->Height - 2, _pWin->Width - 2, WIN_BORDER_COLOR);
000018  f44f7004          MOV      r0,#0x210
00001c  9000              STR      r0,[sp,#0]
00001e  8926              LDRH     r6,[r4,#8]
000020  1eb6              SUBS     r6,r6,#2
000022  b2b3              UXTH     r3,r6
000024  88e6              LDRH     r6,[r4,#6]
000026  1eb6              SUBS     r6,r6,#2
000028  b2b2              UXTH     r2,r6
00002a  88a6              LDRH     r6,[r4,#4]
00002c  1c76              ADDS     r6,r6,#1
00002e  b2b1              UXTH     r1,r6
000030  8866              LDRH     r6,[r4,#2]
000032  1c76              ADDS     r6,r6,#1
000034  b2b0              UXTH     r0,r6
000036  f7fffffe          BL       LCD_DrawRect
;;;594    
;;;595    	/* 窗口标题栏 */
;;;596    	LCD_Fill_Rect(_pWin->Left + 2, _pWin->Top + 2, TitleHegiht, _pWin->Width - 4, WIN_TITLE_COLOR);
00003a  f244203f          MOV      r0,#0x423f
00003e  9000              STR      r0,[sp,#0]
000040  8922              LDRH     r2,[r4,#8]
000042  1f12              SUBS     r2,r2,#4
000044  b293              UXTH     r3,r2
000046  88a2              LDRH     r2,[r4,#4]
000048  1c92              ADDS     r2,r2,#2
00004a  b291              UXTH     r1,r2
00004c  8862              LDRH     r2,[r4,#2]
00004e  1c92              ADDS     r2,r2,#2
000050  b290              UXTH     r0,r2
000052  462a              MOV      r2,r5
000054  f7fffffe          BL       LCD_Fill_Rect
;;;597    
;;;598    	/* 窗体填充 */
;;;599    	LCD_Fill_Rect(_pWin->Left + 2, _pWin->Top + TitleHegiht + 2, _pWin->Height - 4 - TitleHegiht,
000058  f24b50b6          MOV      r0,#0xb5b6
00005c  9000              STR      r0,[sp,#0]
00005e  8926              LDRH     r6,[r4,#8]
000060  1f36              SUBS     r6,r6,#4
000062  b2b3              UXTH     r3,r6
000064  88e6              LDRH     r6,[r4,#6]
000066  1f36              SUBS     r6,r6,#4
000068  1b76              SUBS     r6,r6,r5
00006a  b2b2              UXTH     r2,r6
00006c  88a6              LDRH     r6,[r4,#4]
00006e  442e              ADD      r6,r6,r5
000070  1cb6              ADDS     r6,r6,#2
000072  b2b1              UXTH     r1,r6
000074  8866              LDRH     r6,[r4,#2]
000076  1cb6              ADDS     r6,r6,#2
000078  b2b0              UXTH     r0,r6
00007a  f7fffffe          BL       LCD_Fill_Rect
;;;600    		_pWin->Width - 4, WIN_BODY_COLOR);
;;;601    
;;;602    	LCD_DispStr(_pWin->Left + 3, _pWin->Top + 2, _pWin->pCaption, _pWin->Font);
00007e  88a6              LDRH     r6,[r4,#4]
000080  1cb6              ADDS     r6,r6,#2
000082  b2b1              UXTH     r1,r6
000084  8866              LDRH     r6,[r4,#2]
000086  1cf6              ADDS     r6,r6,#3
000088  b2b0              UXTH     r0,r6
00008a  e9d43203          LDRD     r3,r2,[r4,#0xc]
00008e  f7fffffe          BL       LCD_DispStr
;;;603    #else
;;;604    	if (g_ChipID == IC_8875)
;;;605    	{
;;;606    		uint16_t TitleHegiht;
;;;607    
;;;608    		TitleHegiht = 28;
;;;609    
;;;610    		/* 绘制窗口外框 */
;;;611    		RA8875_DrawRect(_pWin->Left, _pWin->Top, _pWin->Height, _pWin->Width, WIN_BORDER_COLOR);
;;;612    		RA8875_DrawRect(_pWin->Left + 1, _pWin->Top + 1, _pWin->Height - 2, _pWin->Width - 2, WIN_BORDER_COLOR);
;;;613    
;;;614    		/* 窗口标题栏 */
;;;615    		RA8875_FillRect(_pWin->Left + 2, _pWin->Top + 2, TitleHegiht, _pWin->Width - 4, WIN_TITLE_COLOR);
;;;616    
;;;617    		/* 窗体填充 */
;;;618    		RA8875_FillRect(_pWin->Left + 2, _pWin->Top + TitleHegiht + 2, _pWin->Height - 4 - TitleHegiht, _pWin->Width - 4, WIN_BODY_COLOR);
;;;619    
;;;620    		//RA8875_SetFont(_pWin->Font.FontCode, 0, 0);
;;;621    		RA8875_SetFont(RA_FONT_24, 0, 0);
;;;622    
;;;623    		RA8875_SetBackColor(WIN_TITLE_COLOR);
;;;624    		RA8875_SetFrontColor(WIN_CAPTION_COLOR);
;;;625    		RA8875_DispStr(_pWin->Left + 3, _pWin->Top + 2, _pWin->Caption);
;;;626    	}
;;;627    	else
;;;628    	{
;;;629    		;
;;;630    	}
;;;631    #endif
;;;632    }
000092  bdf8              POP      {r3-r7,pc}
;;;633    
                          ENDP


                          AREA ||i.LCD_FSMCConfig||, CODE, READONLY, ALIGN=1

                  LCD_FSMCConfig PROC
;;;1485   */
;;;1486   static void LCD_FSMCConfig(void)
000000  b500              PUSH     {lr}
;;;1487   {
000002  b097              SUB      sp,sp,#0x5c
;;;1488   	FSMC_NORSRAMInitTypeDef  init;
;;;1489   	FSMC_NORSRAMTimingInitTypeDef  timing;
;;;1490   
;;;1491   	/*-- FSMC Configuration ------------------------------------------------------*/
;;;1492   	/*----------------------- SRAM Bank 4 ----------------------------------------*/
;;;1493   	/* FSMC_Bank1_NORSRAM4 configuration */
;;;1494   	timing.FSMC_AddressSetupTime = 5;
000004  2005              MOVS     r0,#5
000006  9001              STR      r0,[sp,#4]
;;;1495   	timing.FSMC_AddressHoldTime = 0;
000008  2000              MOVS     r0,#0
00000a  9002              STR      r0,[sp,#8]
;;;1496   	timing.FSMC_DataSetupTime = 9;
00000c  2009              MOVS     r0,#9
00000e  9003              STR      r0,[sp,#0xc]
;;;1497   	timing.FSMC_BusTurnAroundDuration = 0;
000010  2000              MOVS     r0,#0
000012  9004              STR      r0,[sp,#0x10]
;;;1498   	timing.FSMC_CLKDivision = 0;
000014  9005              STR      r0,[sp,#0x14]
;;;1499   	timing.FSMC_DataLatency = 0;
000016  9006              STR      r0,[sp,#0x18]
;;;1500   	timing.FSMC_AccessMode = FSMC_AccessMode_A;
000018  9007              STR      r0,[sp,#0x1c]
;;;1501   
;;;1502   	/*
;;;1503   	 LCD configured as follow:
;;;1504   	    - Data/Address MUX = Disable
;;;1505   	    - Memory Type = SRAM
;;;1506   	    - Data Width = 16bit
;;;1507   	    - Write Operation = Enable
;;;1508   	    - Extended Mode = Enable
;;;1509   	    - Asynchronous Wait = Disable
;;;1510   	*/
;;;1511   	init.FSMC_Bank = FSMC_Bank1_NORSRAM1;
00001a  9008              STR      r0,[sp,#0x20]
;;;1512   	init.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable;
00001c  9009              STR      r0,[sp,#0x24]
;;;1513   	init.FSMC_MemoryType = FSMC_MemoryType_SRAM;
00001e  900a              STR      r0,[sp,#0x28]
;;;1514   	init.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;
000020  2010              MOVS     r0,#0x10
000022  900b              STR      r0,[sp,#0x2c]
;;;1515   	init.FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
000024  2000              MOVS     r0,#0
000026  900c              STR      r0,[sp,#0x30]
;;;1516   	init.FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;	/* 注意旧库无这个成员 */
000028  900d              STR      r0,[sp,#0x34]
;;;1517   	init.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
00002a  900e              STR      r0,[sp,#0x38]
;;;1518   	init.FSMC_WrapMode = FSMC_WrapMode_Disable;
00002c  900f              STR      r0,[sp,#0x3c]
;;;1519   	init.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
00002e  9010              STR      r0,[sp,#0x40]
;;;1520   	init.FSMC_WriteOperation = FSMC_WriteOperation_Enable;
000030  f44f5080          MOV      r0,#0x1000
000034  9011              STR      r0,[sp,#0x44]
;;;1521   	init.FSMC_WaitSignal = FSMC_WaitSignal_Disable;
000036  2000              MOVS     r0,#0
000038  9012              STR      r0,[sp,#0x48]
;;;1522   	init.FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
00003a  9013              STR      r0,[sp,#0x4c]
;;;1523   	init.FSMC_WriteBurst = FSMC_WriteBurst_Disable;
00003c  9014              STR      r0,[sp,#0x50]
;;;1524   
;;;1525   	init.FSMC_ReadWriteTimingStruct = &timing;
00003e  a801              ADD      r0,sp,#4
000040  9015              STR      r0,[sp,#0x54]
;;;1526   	init.FSMC_WriteTimingStruct = &timing;
000042  9016              STR      r0,[sp,#0x58]
;;;1527   
;;;1528   	FSMC_NORSRAMInit(&init);
000044  a808              ADD      r0,sp,#0x20
000046  f7fffffe          BL       FSMC_NORSRAMInit
;;;1529   
;;;1530   	/* - BANK 1 (of NOR/SRAM Bank 1~4) is enabled */
;;;1531   	FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM1, ENABLE);
00004a  2101              MOVS     r1,#1
00004c  2000              MOVS     r0,#0
00004e  f7fffffe          BL       FSMC_NORSRAMCmd
;;;1532   }
000052  b017              ADD      sp,sp,#0x5c
000054  bd00              POP      {pc}
;;;1533   
                          ENDP


                          AREA ||i.LCD_Fill_Rect||, CODE, READONLY, ALIGN=2

                  LCD_Fill_Rect PROC
;;;512    */
;;;513    void LCD_Fill_Rect(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint16_t _usColor)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;514    {
000004  4605              MOV      r5,r0
000006  4689              MOV      r9,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;515    	uint16_t i;
;;;516    
;;;517    	if (g_ChipID == IC_8875)
000010  480e              LDR      r0,|L27.76|
000012  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000014  2875              CMP      r0,#0x75
000016  d108              BNE      |L27.42|
;;;518    	{
;;;519    		RA8875_FillRect(_usX, _usY, _usHeight, _usWidth, _usColor);
000018  463b              MOV      r3,r7
00001a  4632              MOV      r2,r6
00001c  4649              MOV      r1,r9
00001e  4628              MOV      r0,r5
000020  f8cd8000          STR      r8,[sp,#0]
000024  f7fffffe          BL       RA8875_FillRect
000028  e00d              B        |L27.70|
                  |L27.42|
;;;520    	}
;;;521    	else
;;;522    	{
;;;523    		for (i = 0; i < _usHeight; i++)
00002a  2400              MOVS     r4,#0
00002c  e009              B        |L27.66|
                  |L27.46|
;;;524    		{
;;;525    			SPFD5420_DrawHLine(_usX, _usY, _usX + _usWidth - 1, _usColor);
00002e  19e8              ADDS     r0,r5,r7
000030  1e40              SUBS     r0,r0,#1
000032  b282              UXTH     r2,r0
000034  4643              MOV      r3,r8
000036  4649              MOV      r1,r9
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       SPFD5420_DrawHLine
00003e  1c60              ADDS     r0,r4,#1              ;523
000040  b284              UXTH     r4,r0                 ;523
                  |L27.66|
000042  42b4              CMP      r4,r6                 ;523
000044  dbf3              BLT      |L27.46|
                  |L27.70|
;;;526    		}
;;;527    	}
;;;528    }
000046  e8bd83f8          POP      {r3-r9,pc}
;;;529    
                          ENDP

00004a  0000              DCW      0x0000
                  |L27.76|
                          DCD      g_ChipID

                          AREA ||i.LCD_GetBackLight||, CODE, READONLY, ALIGN=2

                  LCD_GetBackLight PROC
;;;1564   */
;;;1565   uint8_t LCD_GetBackLight(void)
000000  4801              LDR      r0,|L28.8|
;;;1566   {
;;;1567   	return s_ucBright;
000002  7800              LDRB     r0,[r0,#0]  ; s_ucBright
;;;1568   }
000004  4770              BX       lr
;;;1569   
                          ENDP

000006  0000              DCW      0x0000
                  |L28.8|
                          DCD      s_ucBright

                          AREA ||i.LCD_GetChipDescribe||, CODE, READONLY, ALIGN=2

                  LCD_GetChipDescribe PROC
;;;125    */
;;;126    void LCD_GetChipDescribe(char *_str)
000000  b510              PUSH     {r4,lr}
;;;127    {
000002  4604              MOV      r4,r0
;;;128    	switch (g_ChipID)
000004  4815              LDR      r0,|L29.92|
000006  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000008  2875              CMP      r0,#0x75
00000a  d01b              BEQ      |L29.68|
00000c  f46f4180          MVN      r1,#0x4000
000010  1840              ADDS     r0,r0,r1
000012  d00d              BEQ      |L29.48|
000014  f5a050a0          SUB      r0,r0,#0x1400
000018  381f              SUBS     r0,r0,#0x1f
00001a  d004              BEQ      |L29.38|
00001c  f5a040c0          SUB      r0,r0,#0x6000
000020  38e9              SUBS     r0,r0,#0xe9
000022  d114              BNE      |L29.78|
000024  e009              B        |L29.58|
                  |L29.38|
;;;129    	{
;;;130    		case IC_5420:
;;;131    			strcpy(_str, CHIP_STR_5420);
000026  a10e              ADR      r1,|L29.96|
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       strcpy
;;;132    			break;
00002e  e013              B        |L29.88|
                  |L29.48|
;;;133    
;;;134    		case IC_4001:
;;;135    			strcpy(_str, CHIP_STR_4001);
000030  a10e              ADR      r1,|L29.108|
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       strcpy
;;;136    			break;
000038  e00e              B        |L29.88|
                  |L29.58|
;;;137    
;;;138    		case IC_61509:
;;;139    			strcpy(_str, CHIP_STR_61509);
00003a  a10f              ADR      r1,|L29.120|
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       strcpy
;;;140    			break;
000042  e009              B        |L29.88|
                  |L29.68|
;;;141    
;;;142    		case IC_8875:
;;;143    			strcpy(_str, CHIP_STR_8875);
000044  a10e              ADR      r1,|L29.128|
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       strcpy
;;;144    			break;
00004c  e004              B        |L29.88|
                  |L29.78|
;;;145    
;;;146    		default:
;;;147    			strcpy(_str, "Unknow");
00004e  a10e              ADR      r1,|L29.136|
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       strcpy
;;;148    			break;
000056  bf00              NOP      
                  |L29.88|
000058  bf00              NOP                            ;132
;;;149    	}
;;;150    }
00005a  bd10              POP      {r4,pc}
;;;151    
                          ENDP

                  |L29.92|
                          DCD      g_ChipID
                  |L29.96|
000060  53504644          DCB      "SPFD5420A",0
000064  35343230
000068  4100    
00006a  00                DCB      0
00006b  00                DCB      0
                  |L29.108|
00006c  4f544d34          DCB      "OTM4001A",0
000070  30303141
000074  00      
000075  00                DCB      0
000076  00                DCB      0
000077  00                DCB      0
                  |L29.120|
000078  52363135          DCB      "R61509V",0
00007c  30395600
                  |L29.128|
000080  52413838          DCB      "RA8875",0
000084  373500  
000087  00                DCB      0
                  |L29.136|
000088  556e6b6e          DCB      "Unknow",0
00008c  6f7700  
00008f  00                DCB      0

                          AREA ||i.LCD_GetHeight||, CODE, READONLY, ALIGN=2

                  LCD_GetHeight PROC
;;;159    */
;;;160    uint16_t LCD_GetHeight(void)
000000  4801              LDR      r0,|L30.8|
;;;161    {
;;;162    	return g_LcdHeight;
000002  8800              LDRH     r0,[r0,#0]  ; g_LcdHeight
;;;163    }
000004  4770              BX       lr
;;;164    
                          ENDP

000006  0000              DCW      0x0000
                  |L30.8|
                          DCD      g_LcdHeight

                          AREA ||i.LCD_GetPixel||, CODE, READONLY, ALIGN=2

                  LCD_GetPixel PROC
;;;419    */
;;;420    uint16_t LCD_GetPixel(uint16_t _usX, uint16_t _usY)
000000  b570              PUSH     {r4-r6,lr}
;;;421    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;422    	uint16_t usRGB;
;;;423    
;;;424    	if (g_ChipID == IC_8875)
000006  4808              LDR      r0,|L31.40|
000008  8800              LDRH     r0,[r0,#0]  ; g_ChipID
00000a  2875              CMP      r0,#0x75
00000c  d105              BNE      |L31.26|
;;;425    	{
;;;426    		usRGB = RA8875_GetPixel(_usX, _usY);
00000e  4631              MOV      r1,r6
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       RA8875_GetPixel
000016  4604              MOV      r4,r0
000018  e004              B        |L31.36|
                  |L31.26|
;;;427    	}
;;;428    	else
;;;429    	{
;;;430    		usRGB = SPFD5420_GetPixel(_usX, _usY);
00001a  4631              MOV      r1,r6
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       SPFD5420_GetPixel
000022  4604              MOV      r4,r0
                  |L31.36|
;;;431    	}
;;;432    
;;;433    	return usRGB;
000024  4620              MOV      r0,r4
;;;434    }
000026  bd70              POP      {r4-r6,pc}
;;;435    
                          ENDP

                  |L31.40|
                          DCD      g_ChipID

                          AREA ||i.LCD_GetWidth||, CODE, READONLY, ALIGN=2

                  LCD_GetWidth PROC
;;;172    */
;;;173    uint16_t LCD_GetWidth(void)
000000  4801              LDR      r0,|L32.8|
;;;174    {
;;;175    	return g_LcdWidth;
000002  8800              LDRH     r0,[r0,#0]  ; g_LcdWidth
;;;176    }
000004  4770              BX       lr
;;;177    
                          ENDP

000006  0000              DCW      0x0000
                  |L32.8|
                          DCD      g_LcdWidth

                          AREA ||i.LCD_InitHard||, CODE, READONLY, ALIGN=2

                  LCD_InitHard PROC
;;;71     */
;;;72     void LCD_InitHard(void)
000000  b510              PUSH     {r4,lr}
;;;73     {
;;;74     	uint16_t id;
;;;75     
;;;76     	/* 配置LCD控制口线GPIO */
;;;77     	LCD_CtrlLinesConfig();
000002  f7fffffe          BL       LCD_CtrlLinesConfig
;;;78     
;;;79     	/* 配置FSMC接口，数据总线 */
;;;80     	LCD_FSMCConfig();
000006  f7fffffe          BL       LCD_FSMCConfig
;;;81     
;;;82     	#ifdef IF_SPI_EN
;;;83     		RA8875_InitSPI();
;;;84     	#endif
;;;85     
;;;86     	/* FSMC重置后必须加延迟才能访问总线设备  */
;;;87     //	bsp_DelayMS(20);
;;;88     	Bus_Delay(1000000);
00000a  4818              LDR      r0,|L33.108|
00000c  f7fffffe          BL       Bus_Delay
;;;89     	
;;;90     	id = SPFD5420_ReadID();  	/* 读取LCD驱动芯片ID */
000010  f7fffffe          BL       SPFD5420_ReadID
000014  4604              MOV      r4,r0
;;;91     	if ((id == 0x5420) || (id ==  0xB509) || (id == 0x5520))
000016  f5a440a8          SUB      r0,r4,#0x5400
00001a  3820              SUBS     r0,r0,#0x20
00001c  d007              BEQ      |L33.46|
00001e  f5a44035          SUB      r0,r4,#0xb500
000022  3809              SUBS     r0,r0,#9
000024  d003              BEQ      |L33.46|
000026  f5a440aa          SUB      r0,r4,#0x5500
00002a  3820              SUBS     r0,r0,#0x20
00002c  d102              BNE      |L33.52|
                  |L33.46|
;;;92     	{
;;;93     		SPFD5420_InitHard();	/* 初始化5420和4001屏硬件 */
00002e  f7fffffe          BL       SPFD5420_InitHard
000032  e013              B        |L33.92|
                  |L33.52|
;;;94     		/* g_ChipID 在函数内部设置了 */
;;;95     	}
;;;96     	else
;;;97     	{
;;;98     		if (RA8875_ReadID() == 0x75)
000034  f7fffffe          BL       RA8875_ReadID
000038  2875              CMP      r0,#0x75
00003a  d104              BNE      |L33.70|
;;;99     		{
;;;100    			g_ChipID = IC_8875;
00003c  490c              LDR      r1,|L33.112|
00003e  8008              STRH     r0,[r1,#0]
;;;101    			RA8875_InitHard();	/* 初始化RA8875芯片 */
000040  f7fffffe          BL       RA8875_InitHard
000044  e00a              B        |L33.92|
                  |L33.70|
;;;102    		}
;;;103    		else
;;;104    		{
;;;105    			/* 如果未能成功识别，则缺省按4001屏处理 */
;;;106    			g_ChipID = IC_4001;
000046  f2440001          MOV      r0,#0x4001
00004a  4909              LDR      r1,|L33.112|
00004c  8008              STRH     r0,[r1,#0]
;;;107    			g_LcdHeight = LCD_30_HEIGHT;
00004e  20f0              MOVS     r0,#0xf0
000050  4908              LDR      r1,|L33.116|
000052  8008              STRH     r0,[r1,#0]
;;;108    			g_LcdWidth = LCD_30_WIDTH;
000054  f44f70c8          MOV      r0,#0x190
000058  4907              LDR      r1,|L33.120|
00005a  8008              STRH     r0,[r1,#0]
                  |L33.92|
;;;109    		}
;;;110    	}
;;;111    
;;;112    	LCD_ClrScr(CL_BLACK);	/* 清屏，显示全黑 */
00005c  2000              MOVS     r0,#0
00005e  f7fffffe          BL       LCD_ClrScr
;;;113    
;;;114    	LCD_SetBackLight(BRIGHT_MAX);	 /* 打开背光，设置为缺省亮度 */
000062  20ff              MOVS     r0,#0xff
000064  f7fffffe          BL       LCD_SetBackLight
;;;115    }
000068  bd10              POP      {r4,pc}
;;;116    
                          ENDP

00006a  0000              DCW      0x0000
                  |L33.108|
                          DCD      0x000f4240
                  |L33.112|
                          DCD      g_ChipID
                  |L33.116|
                          DCD      g_LcdHeight
                  |L33.120|
                          DCD      g_LcdWidth

                          AREA ||i.LCD_PutPixel||, CODE, READONLY, ALIGN=2

                  LCD_PutPixel PROC
;;;397    */
;;;398    void LCD_PutPixel(uint16_t _usX, uint16_t _usY, uint16_t _usColor)
000000  b570              PUSH     {r4-r6,lr}
;;;399    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;400    	if (g_ChipID == IC_8875)
000008  4807              LDR      r0,|L34.40|
00000a  8800              LDRH     r0,[r0,#0]  ; g_ChipID
00000c  2875              CMP      r0,#0x75
00000e  d105              BNE      |L34.28|
;;;401    	{
;;;402    		RA8875_PutPixel(_usX, _usY, _usColor);
000010  4632              MOV      r2,r6
000012  4629              MOV      r1,r5
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       RA8875_PutPixel
00001a  e004              B        |L34.38|
                  |L34.28|
;;;403    	}
;;;404    	else
;;;405    	{
;;;406    		SPFD5420_PutPixel(_usX, _usY, _usColor);
00001c  4632              MOV      r2,r6
00001e  4629              MOV      r1,r5
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       SPFD5420_PutPixel
                  |L34.38|
;;;407    	}
;;;408    }
000026  bd70              POP      {r4-r6,pc}
;;;409    
                          ENDP

                  |L34.40|
                          DCD      g_ChipID

                          AREA ||i.LCD_SetBackLight||, CODE, READONLY, ALIGN=2

                  LCD_SetBackLight PROC
;;;1542   */
;;;1543   void LCD_SetBackLight(uint8_t _bright)
000000  b510              PUSH     {r4,lr}
;;;1544   {
000002  4604              MOV      r4,r0
;;;1545   	s_ucBright =  _bright;	/* 保存背光值 */
000004  4806              LDR      r0,|L35.32|
000006  7004              STRB     r4,[r0,#0]
;;;1546   
;;;1547   	if (g_ChipID == IC_8875)
000008  4806              LDR      r0,|L35.36|
00000a  8800              LDRH     r0,[r0,#0]  ; g_ChipID
00000c  2875              CMP      r0,#0x75
00000e  d103              BNE      |L35.24|
;;;1548   	{
;;;1549   		RA8875_SetBackLight(_bright);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       RA8875_SetBackLight
000016  e002              B        |L35.30|
                  |L35.24|
;;;1550   	}
;;;1551   	else
;;;1552   	{
;;;1553   		SPFD5420_SetBackLight(_bright);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       SPFD5420_SetBackLight
                  |L35.30|
;;;1554   	}
;;;1555   }
00001e  bd10              POP      {r4,pc}
;;;1556   
                          ENDP

                  |L35.32|
                          DCD      s_ucBright
                  |L35.36|
                          DCD      g_ChipID

                          AREA ||.data||, DATA, ALIGN=1

                  g_ChipID
000000  4001              DCW      0x4001
                  g_LcdHeight
000002  00f0              DCW      0x00f0
                  g_LcdWidth
000004  0190              DCW      0x0190
                  s_ucBright
000006  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_tft_lcd.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___13_bsp_tft_lcd_c_g_ChipID____REV16|
#line 129 "D:\\Keil_v4\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_bsp_tft_lcd_c_g_ChipID____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___13_bsp_tft_lcd_c_g_ChipID____REVSH|
#line 144
|__asm___13_bsp_tft_lcd_c_g_ChipID____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
