; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\bsp_key.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=..\output\bsp_key.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=870 -I..\..\User -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\User\fonts -I..\..\emWin\GUI_X -I..\..\emWin\Config -I..\..\emWin\Include -I..\..\emWin\emWinTask -I..\..\User\fatfs\src -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM4F -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -ID:\Keil_v4\ARM\RV31\INC -ID:\Keil_v4\ARM\CMSIS\Include -ID:\Keil_v4\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F4XX -DARM_MATH_CM4 -D__CC_ARM ..\..\User\bsp_stm32f4xx\src\bsp_key.c]
                          THUMB

                          AREA ||i.IsKeyDown1||, CODE, READONLY, ALIGN=2

                  IsKeyDown1 PROC
;;;129    #ifdef STM32_X4		/* 安富莱 STM32-X4 开发板 */
;;;130    	static uint8_t IsKeyDown1(void) {if ((GPIO_PORT_K1->IDR & GPIO_PIN_K1) == 0) return 1;else return 0;}
000000  4804              LDR      r0,|L1.20|
000002  6800              LDR      r0,[r0,#0]
000004  f4105f00          TST      r0,#0x2000
000008  d101              BNE      |L1.14|
00000a  2001              MOVS     r0,#1
                  |L1.12|
00000c  4770              BX       lr
                  |L1.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L1.12|
;;;131    	static uint8_t IsKeyDown2(void) {if ((GPIO_PORT_K2->IDR & GPIO_PIN_K2) == 0) return 1;else return 0;}
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      0x40020810

                          AREA ||i.IsKeyDown10||, CODE, READONLY, ALIGN=1

                  IsKeyDown10 PROC
;;;148    	static uint8_t IsKeyDown9(void) {if (IsKeyDown1() && IsKeyDown2()) return 1;else return 0;}
;;;149    	static uint8_t IsKeyDown10(void) {if (IsKeyDown1() && IsKeyDown2()) return 1;else return 0;}	
000000  b510              PUSH     {r4,lr}
000002  f7fffffe          BL       IsKeyDown1
000006  b120              CBZ      r0,|L2.18|
000008  f7fffffe          BL       IsKeyDown2
00000c  b108              CBZ      r0,|L2.18|
00000e  2001              MOVS     r0,#1
                  |L2.16|
000010  bd10              POP      {r4,pc}
                  |L2.18|
000012  2000              MOVS     r0,#0
000014  e7fc              B        |L2.16|
;;;150    
                          ENDP


                          AREA ||i.IsKeyDown2||, CODE, READONLY, ALIGN=2

                  IsKeyDown2 PROC
;;;130    	static uint8_t IsKeyDown1(void) {if ((GPIO_PORT_K1->IDR & GPIO_PIN_K1) == 0) return 1;else return 0;}
;;;131    	static uint8_t IsKeyDown2(void) {if ((GPIO_PORT_K2->IDR & GPIO_PIN_K2) == 0) return 1;else return 0;}
000000  4804              LDR      r0,|L3.20|
000002  6800              LDR      r0,[r0,#0]
000004  f0100f01          TST      r0,#1
000008  d101              BNE      |L3.14|
00000a  2001              MOVS     r0,#1
                  |L3.12|
00000c  4770              BX       lr
                  |L3.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L3.12|
;;;132    	static uint8_t IsKeyDown3(void) {if ((GPIO_PORT_K3->IDR & GPIO_PIN_K3) == 0) return 1;else return 0;}
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40020810

                          AREA ||i.IsKeyDown3||, CODE, READONLY, ALIGN=2

                  IsKeyDown3 PROC
;;;131    	static uint8_t IsKeyDown2(void) {if ((GPIO_PORT_K2->IDR & GPIO_PIN_K2) == 0) return 1;else return 0;}
;;;132    	static uint8_t IsKeyDown3(void) {if ((GPIO_PORT_K3->IDR & GPIO_PIN_K3) == 0) return 1;else return 0;}
000000  4804              LDR      r0,|L4.20|
000002  6800              LDR      r0,[r0,#0]
000004  f0100f02          TST      r0,#2
000008  d101              BNE      |L4.14|
00000a  2001              MOVS     r0,#1
                  |L4.12|
00000c  4770              BX       lr
                  |L4.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L4.12|
;;;133    	static uint8_t IsKeyDown4(void) {if ((GPIO_PORT_K4->IDR & GPIO_PIN_K4) == 0) return 1;else return 0;}
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x40020810

                          AREA ||i.IsKeyDown4||, CODE, READONLY, ALIGN=2

                  IsKeyDown4 PROC
;;;132    	static uint8_t IsKeyDown3(void) {if ((GPIO_PORT_K3->IDR & GPIO_PIN_K3) == 0) return 1;else return 0;}
;;;133    	static uint8_t IsKeyDown4(void) {if ((GPIO_PORT_K4->IDR & GPIO_PIN_K4) == 0) return 1;else return 0;}
000000  4804              LDR      r0,|L5.20|
000002  6800              LDR      r0,[r0,#0]
000004  f0100f08          TST      r0,#8
000008  d101              BNE      |L5.14|
00000a  2001              MOVS     r0,#1
                  |L5.12|
00000c  4770              BX       lr
                  |L5.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L5.12|
;;;134    	static uint8_t IsKeyDown5(void) {if ((GPIO_PORT_K5->IDR & GPIO_PIN_K5) == 0) return 1;else return 0;}
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x40020810

                          AREA ||i.IsKeyDown5||, CODE, READONLY, ALIGN=2

                  IsKeyDown5 PROC
;;;133    	static uint8_t IsKeyDown4(void) {if ((GPIO_PORT_K4->IDR & GPIO_PIN_K4) == 0) return 1;else return 0;}
;;;134    	static uint8_t IsKeyDown5(void) {if ((GPIO_PORT_K5->IDR & GPIO_PIN_K5) == 0) return 1;else return 0;}
000000  4804              LDR      r0,|L6.20|
000002  6800              LDR      r0,[r0,#0]
000004  f0100f10          TST      r0,#0x10
000008  d101              BNE      |L6.14|
00000a  2001              MOVS     r0,#1
                  |L6.12|
00000c  4770              BX       lr
                  |L6.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L6.12|
;;;135    	static uint8_t IsKeyDown6(void) {if ((GPIO_PORT_K6->IDR & GPIO_PIN_K6) == 0) return 1;else return 0;}
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0x40020810

                          AREA ||i.IsKeyDown6||, CODE, READONLY, ALIGN=2

                  IsKeyDown6 PROC
;;;134    	static uint8_t IsKeyDown5(void) {if ((GPIO_PORT_K5->IDR & GPIO_PIN_K5) == 0) return 1;else return 0;}
;;;135    	static uint8_t IsKeyDown6(void) {if ((GPIO_PORT_K6->IDR & GPIO_PIN_K6) == 0) return 1;else return 0;}
000000  4804              LDR      r0,|L7.20|
000002  6800              LDR      r0,[r0,#0]
000004  f0100f04          TST      r0,#4
000008  d101              BNE      |L7.14|
00000a  2001              MOVS     r0,#1
                  |L7.12|
00000c  4770              BX       lr
                  |L7.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L7.12|
;;;136    	static uint8_t IsKeyDown7(void) {if ((GPIO_PORT_K7->IDR & GPIO_PIN_K7) == 0) return 1;else return 0;}
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      0x40020810

                          AREA ||i.IsKeyDown7||, CODE, READONLY, ALIGN=2

                  IsKeyDown7 PROC
;;;135    	static uint8_t IsKeyDown6(void) {if ((GPIO_PORT_K6->IDR & GPIO_PIN_K6) == 0) return 1;else return 0;}
;;;136    	static uint8_t IsKeyDown7(void) {if ((GPIO_PORT_K7->IDR & GPIO_PIN_K7) == 0) return 1;else return 0;}
000000  4804              LDR      r0,|L8.20|
000002  6900              LDR      r0,[r0,#0x10]
000004  f0100f02          TST      r0,#2
000008  d101              BNE      |L8.14|
00000a  2001              MOVS     r0,#1
                  |L8.12|
00000c  4770              BX       lr
                  |L8.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L8.12|
;;;137    	static uint8_t IsKeyDown8(void) {if ((GPIO_PORT_K8->IDR & GPIO_PIN_K8) == 0) return 1;else return 0;}
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0x40020000

                          AREA ||i.IsKeyDown8||, CODE, READONLY, ALIGN=2

                  IsKeyDown8 PROC
;;;136    	static uint8_t IsKeyDown7(void) {if ((GPIO_PORT_K7->IDR & GPIO_PIN_K7) == 0) return 1;else return 0;}
;;;137    	static uint8_t IsKeyDown8(void) {if ((GPIO_PORT_K8->IDR & GPIO_PIN_K8) == 0) return 1;else return 0;}
000000  4804              LDR      r0,|L9.20|
000002  6900              LDR      r0,[r0,#0x10]
000004  f0100f01          TST      r0,#1
000008  d101              BNE      |L9.14|
00000a  2001              MOVS     r0,#1
                  |L9.12|
00000c  4770              BX       lr
                  |L9.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L9.12|
;;;138    #else				/* 安富莱 STM32-V5 开发板 */
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      0x40020000

                          AREA ||i.IsKeyDown9||, CODE, READONLY, ALIGN=1

                  IsKeyDown9 PROC
;;;147    #endif
;;;148    	static uint8_t IsKeyDown9(void) {if (IsKeyDown1() && IsKeyDown2()) return 1;else return 0;}
000000  b510              PUSH     {r4,lr}
000002  f7fffffe          BL       IsKeyDown1
000006  b120              CBZ      r0,|L10.18|
000008  f7fffffe          BL       IsKeyDown2
00000c  b108              CBZ      r0,|L10.18|
00000e  2001              MOVS     r0,#1
                  |L10.16|
000010  bd10              POP      {r4,pc}
                  |L10.18|
000012  2000              MOVS     r0,#0
000014  e7fc              B        |L10.16|
;;;149    	static uint8_t IsKeyDown10(void) {if (IsKeyDown1() && IsKeyDown2()) return 1;else return 0;}	
                          ENDP


                          AREA ||i.bsp_DetectKey||, CODE, READONLY, ALIGN=2

                  bsp_DetectKey PROC
;;;364    */
;;;365    static void bsp_DetectKey(uint8_t i)
000000  b570              PUSH     {r4-r6,lr}
;;;366    {
000002  4605              MOV      r5,r0
;;;367    	KEY_T *pBtn;
;;;368    
;;;369    	/*
;;;370    		如果没有初始化按键函数，则报错
;;;371    		if (s_tBtn[i].IsKeyDownFunc == 0)
;;;372    		{
;;;373    			printf("Fault : DetectButton(), s_tBtn[i].IsKeyDownFunc undefine");
;;;374    		}
;;;375    	*/
;;;376    
;;;377    	pBtn = &s_tBtn[i];
000004  4830              LDR      r0,|L11.200|
000006  eb001405          ADD      r4,r0,r5,LSL #4
;;;378    	if (pBtn->IsKeyDownFunc())
00000a  6820              LDR      r0,[r4,#0]
00000c  4780              BLX      r0
00000e  2800              CMP      r0,#0
000010  d03e              BEQ      |L11.144|
;;;379    	{
;;;380    		if (pBtn->Count < KEY_FILTER_TIME)
000012  7920              LDRB     r0,[r4,#4]
000014  2805              CMP      r0,#5
000016  da02              BGE      |L11.30|
;;;381    		{
;;;382    			pBtn->Count = KEY_FILTER_TIME;
000018  2005              MOVS     r0,#5
00001a  7120              STRB     r0,[r4,#4]
00001c  e052              B        |L11.196|
                  |L11.30|
;;;383    		}
;;;384    		else if(pBtn->Count < 2 * KEY_FILTER_TIME)
00001e  7920              LDRB     r0,[r4,#4]
000020  280a              CMP      r0,#0xa
000022  da03              BGE      |L11.44|
;;;385    		{
;;;386    			pBtn->Count++;
000024  7920              LDRB     r0,[r4,#4]
000026  1c40              ADDS     r0,r0,#1
000028  7120              STRB     r0,[r4,#4]
00002a  e04b              B        |L11.196|
                  |L11.44|
;;;387    		}
;;;388    		else
;;;389    		{
;;;390    			if (pBtn->State == 0)
00002c  7aa0              LDRB     r0,[r4,#0xa]
00002e  b938              CBNZ     r0,|L11.64|
;;;391    			{
;;;392    				pBtn->State = 1;
000030  2001              MOVS     r0,#1
000032  72a0              STRB     r0,[r4,#0xa]
;;;393    
;;;394    				/* 发送按钮按下的消息 */
;;;395    				bsp_PutKey((uint8_t)(3 * i + 1));
000034  eb050145          ADD      r1,r5,r5,LSL #1
000038  1c49              ADDS     r1,r1,#1
00003a  b2c8              UXTB     r0,r1
00003c  f7fffffe          BL       bsp_PutKey
                  |L11.64|
;;;396    			}
;;;397    
;;;398    			if (pBtn->LongTime > 0)
000040  8920              LDRH     r0,[r4,#8]
000042  2800              CMP      r0,#0
000044  dd3e              BLE      |L11.196|
;;;399    			{
;;;400    				if (pBtn->LongCount < pBtn->LongTime)
000046  88e0              LDRH     r0,[r4,#6]
000048  8921              LDRH     r1,[r4,#8]
00004a  4288              CMP      r0,r1
00004c  da0d              BGE      |L11.106|
;;;401    				{
;;;402    					/* 发送按钮持续按下的消息 */
;;;403    					if (++pBtn->LongCount == pBtn->LongTime)
00004e  88e0              LDRH     r0,[r4,#6]
000050  1c40              ADDS     r0,r0,#1
000052  b280              UXTH     r0,r0
000054  80e0              STRH     r0,[r4,#6]
000056  8921              LDRH     r1,[r4,#8]
000058  4288              CMP      r0,r1
00005a  d133              BNE      |L11.196|
;;;404    					{
;;;405    						/* 键值放入按键FIFO */
;;;406    						bsp_PutKey((uint8_t)(3 * i + 3));
00005c  eb050145          ADD      r1,r5,r5,LSL #1
000060  1cc9              ADDS     r1,r1,#3
000062  b2c8              UXTB     r0,r1
000064  f7fffffe          BL       bsp_PutKey
000068  e02c              B        |L11.196|
                  |L11.106|
;;;407    					}
;;;408    				}
;;;409    				else
;;;410    				{
;;;411    					if (pBtn->RepeatSpeed > 0)
00006a  7ae0              LDRB     r0,[r4,#0xb]
00006c  2800              CMP      r0,#0
00006e  dd29              BLE      |L11.196|
;;;412    					{
;;;413    						if (++pBtn->RepeatCount >= pBtn->RepeatSpeed)
000070  7b20              LDRB     r0,[r4,#0xc]
000072  1c40              ADDS     r0,r0,#1
000074  b2c0              UXTB     r0,r0
000076  7320              STRB     r0,[r4,#0xc]
000078  7ae1              LDRB     r1,[r4,#0xb]
00007a  4288              CMP      r0,r1
00007c  db22              BLT      |L11.196|
;;;414    						{
;;;415    							pBtn->RepeatCount = 0;
00007e  2000              MOVS     r0,#0
000080  7320              STRB     r0,[r4,#0xc]
;;;416    							/* 常按键后，每隔10ms发送1个按键 */
;;;417    							bsp_PutKey((uint8_t)(3 * i + 1));
000082  eb050145          ADD      r1,r5,r5,LSL #1
000086  1c49              ADDS     r1,r1,#1
000088  b2c8              UXTB     r0,r1
00008a  f7fffffe          BL       bsp_PutKey
00008e  e019              B        |L11.196|
                  |L11.144|
;;;418    						}
;;;419    					}
;;;420    				}
;;;421    			}
;;;422    		}
;;;423    	}
;;;424    	else
;;;425    	{
;;;426    		if(pBtn->Count > KEY_FILTER_TIME)
000090  7920              LDRB     r0,[r4,#4]
000092  2805              CMP      r0,#5
000094  dd02              BLE      |L11.156|
;;;427    		{
;;;428    			pBtn->Count = KEY_FILTER_TIME;
000096  2005              MOVS     r0,#5
000098  7120              STRB     r0,[r4,#4]
00009a  e010              B        |L11.190|
                  |L11.156|
;;;429    		}
;;;430    		else if(pBtn->Count != 0)
00009c  7920              LDRB     r0,[r4,#4]
00009e  b118              CBZ      r0,|L11.168|
;;;431    		{
;;;432    			pBtn->Count--;
0000a0  7920              LDRB     r0,[r4,#4]
0000a2  1e40              SUBS     r0,r0,#1
0000a4  7120              STRB     r0,[r4,#4]
0000a6  e00a              B        |L11.190|
                  |L11.168|
;;;433    		}
;;;434    		else
;;;435    		{
;;;436    			if (pBtn->State == 1)
0000a8  7aa0              LDRB     r0,[r4,#0xa]
0000aa  2801              CMP      r0,#1
0000ac  d107              BNE      |L11.190|
;;;437    			{
;;;438    				pBtn->State = 0;
0000ae  2000              MOVS     r0,#0
0000b0  72a0              STRB     r0,[r4,#0xa]
;;;439    
;;;440    				/* 发送按钮弹起的消息 */
;;;441    				bsp_PutKey((uint8_t)(3 * i + 2));
0000b2  eb050145          ADD      r1,r5,r5,LSL #1
0000b6  1c89              ADDS     r1,r1,#2
0000b8  b2c8              UXTB     r0,r1
0000ba  f7fffffe          BL       bsp_PutKey
                  |L11.190|
;;;442    			}
;;;443    		}
;;;444    
;;;445    		pBtn->LongCount = 0;
0000be  2000              MOVS     r0,#0
0000c0  80e0              STRH     r0,[r4,#6]
;;;446    		pBtn->RepeatCount = 0;
0000c2  7320              STRB     r0,[r4,#0xc]
                  |L11.196|
;;;447    	}
;;;448    }
0000c4  bd70              POP      {r4-r6,pc}
;;;449    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L11.200|
                          DCD      s_tBtn

                          AREA ||i.bsp_GetKey||, CODE, READONLY, ALIGN=2

                  bsp_GetKey PROC
;;;190    */
;;;191    uint8_t bsp_GetKey(void)
000000  480b              LDR      r0,|L12.48|
;;;192    {
;;;193    	uint8_t ret;
;;;194    
;;;195    	if (s_tKey.Read == s_tKey.Write)
000002  7a80              LDRB     r0,[r0,#0xa]  ; s_tKey
000004  4a0a              LDR      r2,|L12.48|
000006  7ad2              LDRB     r2,[r2,#0xb]  ; s_tKey
000008  4290              CMP      r0,r2
00000a  d101              BNE      |L12.16|
;;;196    	{
;;;197    		return KEY_NONE;
00000c  2000              MOVS     r0,#0
                  |L12.14|
;;;198    	}
;;;199    	else
;;;200    	{
;;;201    		ret = s_tKey.Buf[s_tKey.Read];
;;;202    
;;;203    		if (++s_tKey.Read >= KEY_FIFO_SIZE)
;;;204    		{
;;;205    			s_tKey.Read = 0;
;;;206    		}
;;;207    		return ret;
;;;208    	}
;;;209    }
00000e  4770              BX       lr
                  |L12.16|
000010  4807              LDR      r0,|L12.48|
000012  7a80              LDRB     r0,[r0,#0xa]          ;201  ; s_tKey
000014  4a06              LDR      r2,|L12.48|
000016  5c11              LDRB     r1,[r2,r0]            ;201
000018  4610              MOV      r0,r2                 ;203
00001a  7a80              LDRB     r0,[r0,#0xa]          ;203  ; s_tKey
00001c  1c40              ADDS     r0,r0,#1              ;203
00001e  b2c0              UXTB     r0,r0                 ;203
000020  7290              STRB     r0,[r2,#0xa]          ;203
000022  280a              CMP      r0,#0xa               ;203
000024  db01              BLT      |L12.42|
000026  2000              MOVS     r0,#0                 ;205
000028  7290              STRB     r0,[r2,#0xa]          ;205
                  |L12.42|
00002a  4608              MOV      r0,r1                 ;207
00002c  e7ef              B        |L12.14|
;;;210    
                          ENDP

00002e  0000              DCW      0x0000
                  |L12.48|
                          DCD      s_tKey

                          AREA ||i.bsp_GetKey2||, CODE, READONLY, ALIGN=2

                  bsp_GetKey2 PROC
;;;218    */
;;;219    uint8_t bsp_GetKey2(void)
000000  480b              LDR      r0,|L13.48|
;;;220    {
;;;221    	uint8_t ret;
;;;222    
;;;223    	if (s_tKey.Read2 == s_tKey.Write)
000002  7b00              LDRB     r0,[r0,#0xc]  ; s_tKey
000004  4a0a              LDR      r2,|L13.48|
000006  7ad2              LDRB     r2,[r2,#0xb]  ; s_tKey
000008  4290              CMP      r0,r2
00000a  d101              BNE      |L13.16|
;;;224    	{
;;;225    		return KEY_NONE;
00000c  2000              MOVS     r0,#0
                  |L13.14|
;;;226    	}
;;;227    	else
;;;228    	{
;;;229    		ret = s_tKey.Buf[s_tKey.Read2];
;;;230    
;;;231    		if (++s_tKey.Read2 >= KEY_FIFO_SIZE)
;;;232    		{
;;;233    			s_tKey.Read2 = 0;
;;;234    		}
;;;235    		return ret;
;;;236    	}
;;;237    }
00000e  4770              BX       lr
                  |L13.16|
000010  4807              LDR      r0,|L13.48|
000012  7b00              LDRB     r0,[r0,#0xc]          ;229  ; s_tKey
000014  4a06              LDR      r2,|L13.48|
000016  5c11              LDRB     r1,[r2,r0]            ;229
000018  4610              MOV      r0,r2                 ;231
00001a  7b00              LDRB     r0,[r0,#0xc]          ;231  ; s_tKey
00001c  1c40              ADDS     r0,r0,#1              ;231
00001e  b2c0              UXTB     r0,r0                 ;231
000020  7310              STRB     r0,[r2,#0xc]          ;231
000022  280a              CMP      r0,#0xa               ;231
000024  db01              BLT      |L13.42|
000026  2000              MOVS     r0,#0                 ;233
000028  7310              STRB     r0,[r2,#0xc]          ;233
                  |L13.42|
00002a  4608              MOV      r0,r1                 ;235
00002c  e7ef              B        |L13.14|
;;;238    
                          ENDP

00002e  0000              DCW      0x0000
                  |L13.48|
                          DCD      s_tKey

                          AREA ||i.bsp_GetKeyState||, CODE, READONLY, ALIGN=2

                  bsp_GetKeyState PROC
;;;246    */
;;;247    uint8_t bsp_GetKeyState(KEY_ID_E _ucKeyID)
000000  4601              MOV      r1,r0
;;;248    {
;;;249    	return s_tBtn[_ucKeyID].State;
000002  4802              LDR      r0,|L14.12|
000004  eb001001          ADD      r0,r0,r1,LSL #4
000008  7a80              LDRB     r0,[r0,#0xa]
;;;250    }
00000a  4770              BX       lr
;;;251    
                          ENDP

                  |L14.12|
                          DCD      s_tBtn

                          AREA ||i.bsp_InitKey||, CODE, READONLY, ALIGN=1

                  bsp_InitKey PROC
;;;158    */
;;;159    void bsp_InitKey(void)
000000  b510              PUSH     {r4,lr}
;;;160    {
;;;161    	bsp_InitKeyVar();		/* 初始化按键变量 */
000002  f7fffffe          BL       bsp_InitKeyVar
;;;162    	bsp_InitKeyHard();		/* 初始化按键硬件 */
000006  f7fffffe          BL       bsp_InitKeyHard
;;;163    }
00000a  bd10              POP      {r4,pc}
;;;164    
                          ENDP


                          AREA ||i.bsp_InitKeyHard||, CODE, READONLY, ALIGN=2

                  bsp_InitKeyHard PROC
;;;259    */
;;;260    static void bsp_InitKeyHard(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;261    {
;;;262    	GPIO_InitTypeDef GPIO_InitStructure;
;;;263    
;;;264    	/* 第1步：打开GPIO时钟 */
;;;265    	RCC_AHB1PeriphClockCmd(RCC_ALL_KEY, ENABLE);
000002  2101              MOVS     r1,#1
000004  2005              MOVS     r0,#5
000006  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;266    
;;;267    	/* 第2步：配置所有的按键GPIO为浮动输入模式(实际上CPU复位后就是输入状态) */
;;;268    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;		/* 设为输入口 */
00000a  2000              MOVS     r0,#0
00000c  f88d0004          STRB     r0,[sp,#4]
;;;269    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽模式 */
000010  f88d0006          STRB     r0,[sp,#6]
;;;270    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 无需上下拉电阻 */
000014  f88d0007          STRB     r0,[sp,#7]
;;;271    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	/* IO口最大速度 */
000018  2002              MOVS     r0,#2
00001a  f88d0005          STRB     r0,[sp,#5]
;;;272    
;;;273    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K1;
00001e  0300              LSLS     r0,r0,#12
000020  9000              STR      r0,[sp,#0]
;;;274    	GPIO_Init(GPIO_PORT_K1, &GPIO_InitStructure);
000022  4669              MOV      r1,sp
000024  4816              LDR      r0,|L16.128|
000026  f7fffffe          BL       GPIO_Init
;;;275    
;;;276    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K2;
00002a  2001              MOVS     r0,#1
00002c  9000              STR      r0,[sp,#0]
;;;277    	GPIO_Init(GPIO_PORT_K2, &GPIO_InitStructure);
00002e  4669              MOV      r1,sp
000030  4813              LDR      r0,|L16.128|
000032  f7fffffe          BL       GPIO_Init
;;;278    
;;;279    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K3;
000036  2002              MOVS     r0,#2
000038  9000              STR      r0,[sp,#0]
;;;280    	GPIO_Init(GPIO_PORT_K3, &GPIO_InitStructure);
00003a  4669              MOV      r1,sp
00003c  4810              LDR      r0,|L16.128|
00003e  f7fffffe          BL       GPIO_Init
;;;281    
;;;282    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K4;
000042  2008              MOVS     r0,#8
000044  9000              STR      r0,[sp,#0]
;;;283    	GPIO_Init(GPIO_PORT_K4, &GPIO_InitStructure);
000046  4669              MOV      r1,sp
000048  480d              LDR      r0,|L16.128|
00004a  f7fffffe          BL       GPIO_Init
;;;284    
;;;285    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K5;
00004e  2010              MOVS     r0,#0x10
000050  9000              STR      r0,[sp,#0]
;;;286    	GPIO_Init(GPIO_PORT_K5, &GPIO_InitStructure);
000052  4669              MOV      r1,sp
000054  480a              LDR      r0,|L16.128|
000056  f7fffffe          BL       GPIO_Init
;;;287    
;;;288    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K6;
00005a  2004              MOVS     r0,#4
00005c  9000              STR      r0,[sp,#0]
;;;289    	GPIO_Init(GPIO_PORT_K6, &GPIO_InitStructure);
00005e  4669              MOV      r1,sp
000060  4807              LDR      r0,|L16.128|
000062  f7fffffe          BL       GPIO_Init
;;;290    
;;;291    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K7;
000066  2002              MOVS     r0,#2
000068  9000              STR      r0,[sp,#0]
;;;292    	GPIO_Init(GPIO_PORT_K7, &GPIO_InitStructure);
00006a  4669              MOV      r1,sp
00006c  4805              LDR      r0,|L16.132|
00006e  f7fffffe          BL       GPIO_Init
;;;293    
;;;294    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K8;
000072  2001              MOVS     r0,#1
000074  9000              STR      r0,[sp,#0]
;;;295    	GPIO_Init(GPIO_PORT_K8, &GPIO_InitStructure);
000076  4669              MOV      r1,sp
000078  4802              LDR      r0,|L16.132|
00007a  f7fffffe          BL       GPIO_Init
;;;296    }
00007e  bd1c              POP      {r2-r4,pc}
;;;297    
                          ENDP

                  |L16.128|
                          DCD      0x40020800
                  |L16.132|
                          DCD      0x40020000

                          AREA ||i.bsp_InitKeyVar||, CODE, READONLY, ALIGN=2

                  bsp_InitKeyVar PROC
;;;305    */
;;;306    static void bsp_InitKeyVar(void)
000000  2100              MOVS     r1,#0
;;;307    {
;;;308    	uint8_t i;
;;;309    
;;;310    	/* 对按键FIFO读写指针清零 */
;;;311    	s_tKey.Read = 0;
000002  4a28              LDR      r2,|L17.164|
000004  7291              STRB     r1,[r2,#0xa]
;;;312    	s_tKey.Write = 0;
000006  72d1              STRB     r1,[r2,#0xb]
;;;313    	s_tKey.Read2 = 0;
000008  7311              STRB     r1,[r2,#0xc]
;;;314    	
;;;315    	/* 给每个按键结构体成员变量赋一组缺省值 */
;;;316    	for (i = 0; i < KEY_COUNT; i++)
00000a  2000              MOVS     r0,#0
00000c  e018              B        |L17.64|
                  |L17.14|
;;;317    	{
;;;318    		s_tBtn[i].LongTime = KEY_LONG_TIME;			/* 长按时间 0 表示不检测长按键事件 */
00000e  2164              MOVS     r1,#0x64
000010  4a25              LDR      r2,|L17.168|
000012  eb021200          ADD      r2,r2,r0,LSL #4
000016  8111              STRH     r1,[r2,#8]
;;;319    		s_tBtn[i].Count = KEY_FILTER_TIME / 2;		/* 计数器设置为滤波时间的一半 */
000018  2102              MOVS     r1,#2
00001a  4a23              LDR      r2,|L17.168|
00001c  eb021200          ADD      r2,r2,r0,LSL #4
000020  7111              STRB     r1,[r2,#4]
;;;320    		s_tBtn[i].State = 0;							/* 按键缺省状态，0为未按下 */
000022  2100              MOVS     r1,#0
000024  4a20              LDR      r2,|L17.168|
000026  eb021200          ADD      r2,r2,r0,LSL #4
00002a  7291              STRB     r1,[r2,#0xa]
;;;321    		//s_tBtn[i].KeyCodeDown = 3 * i + 1;				/* 按键按下的键值代码 */
;;;322    		//s_tBtn[i].KeyCodeUp   = 3 * i + 2;				/* 按键弹起的键值代码 */
;;;323    		//s_tBtn[i].KeyCodeLong = 3 * i + 3;				/* 按键被持续按下的键值代码 */
;;;324    		s_tBtn[i].RepeatSpeed = 0;						/* 按键连发的速度，0表示不支持连发 */
00002c  4a1e              LDR      r2,|L17.168|
00002e  eb021200          ADD      r2,r2,r0,LSL #4
000032  72d1              STRB     r1,[r2,#0xb]
;;;325    		s_tBtn[i].RepeatCount = 0;						/* 连发计数器 */
000034  4a1c              LDR      r2,|L17.168|
000036  eb021200          ADD      r2,r2,r0,LSL #4
00003a  7311              STRB     r1,[r2,#0xc]
00003c  1c41              ADDS     r1,r0,#1              ;316
00003e  b2c8              UXTB     r0,r1                 ;316
                  |L17.64|
000040  280a              CMP      r0,#0xa               ;316
000042  dbe4              BLT      |L17.14|
;;;326    	}
;;;327    
;;;328    	/* 如果需要单独更改某个按键的参数，可以在此单独重新赋值 */
;;;329    	/* 比如，我们希望按键1按下超过1秒后，自动重发相同键值 */
;;;330    	s_tBtn[KID_JOY_U].LongTime = 100;
000044  2264              MOVS     r2,#0x64
000046  4918              LDR      r1,|L17.168|
000048  870a              STRH     r2,[r1,#0x38]
;;;331    	s_tBtn[KID_JOY_U].RepeatSpeed = 5;	/* 每隔50ms自动发送键值 */
00004a  2205              MOVS     r2,#5
00004c  f881203b          STRB     r2,[r1,#0x3b]
;;;332    
;;;333    	s_tBtn[KID_JOY_D].LongTime = 100;
000050  2264              MOVS     r2,#0x64
000052  f8a12048          STRH     r2,[r1,#0x48]
;;;334    	s_tBtn[KID_JOY_D].RepeatSpeed = 5;	/* 每隔50ms自动发送键值 */
000056  2205              MOVS     r2,#5
000058  f881204b          STRB     r2,[r1,#0x4b]
;;;335    
;;;336    	s_tBtn[KID_JOY_L].LongTime = 100;
00005c  2264              MOVS     r2,#0x64
00005e  f8a12058          STRH     r2,[r1,#0x58]
;;;337    	s_tBtn[KID_JOY_L].RepeatSpeed = 5;	/* 每隔50ms自动发送键值 */
000062  2205              MOVS     r2,#5
000064  f881205b          STRB     r2,[r1,#0x5b]
;;;338    
;;;339    	s_tBtn[KID_JOY_R].LongTime = 100;
000068  2264              MOVS     r2,#0x64
00006a  f8a12068          STRH     r2,[r1,#0x68]
;;;340    	s_tBtn[KID_JOY_R].RepeatSpeed = 5;	/* 每隔50ms自动发送键值 */
00006e  2205              MOVS     r2,#5
000070  f881206b          STRB     r2,[r1,#0x6b]
;;;341    
;;;342    	/* 判断按键按下的函数 */
;;;343    	s_tBtn[0].IsKeyDownFunc = IsKeyDown1;
000074  490d              LDR      r1,|L17.172|
000076  4a0c              LDR      r2,|L17.168|
000078  6011              STR      r1,[r2,#0]  ; s_tBtn
;;;344    	s_tBtn[1].IsKeyDownFunc = IsKeyDown2;
00007a  490d              LDR      r1,|L17.176|
00007c  6111              STR      r1,[r2,#0x10]  ; s_tBtn
;;;345    	s_tBtn[2].IsKeyDownFunc = IsKeyDown3;
00007e  490d              LDR      r1,|L17.180|
000080  6211              STR      r1,[r2,#0x20]  ; s_tBtn
;;;346    	s_tBtn[3].IsKeyDownFunc = IsKeyDown4;
000082  490d              LDR      r1,|L17.184|
000084  6311              STR      r1,[r2,#0x30]  ; s_tBtn
;;;347    	s_tBtn[4].IsKeyDownFunc = IsKeyDown5;
000086  490d              LDR      r1,|L17.188|
000088  6411              STR      r1,[r2,#0x40]  ; s_tBtn
;;;348    	s_tBtn[5].IsKeyDownFunc = IsKeyDown6;
00008a  490d              LDR      r1,|L17.192|
00008c  6511              STR      r1,[r2,#0x50]  ; s_tBtn
;;;349    	s_tBtn[6].IsKeyDownFunc = IsKeyDown7;
00008e  490d              LDR      r1,|L17.196|
000090  6611              STR      r1,[r2,#0x60]  ; s_tBtn
;;;350    	s_tBtn[7].IsKeyDownFunc = IsKeyDown8;
000092  490d              LDR      r1,|L17.200|
000094  6711              STR      r1,[r2,#0x70]  ; s_tBtn
;;;351    	
;;;352    	/* 组合键 */
;;;353    	s_tBtn[8].IsKeyDownFunc = IsKeyDown9;
000096  490d              LDR      r1,|L17.204|
000098  f8c21080          STR      r1,[r2,#0x80]  ; s_tBtn
;;;354    	s_tBtn[9].IsKeyDownFunc = IsKeyDown10;
00009c  490c              LDR      r1,|L17.208|
00009e  f8c21090          STR      r1,[r2,#0x90]  ; s_tBtn
;;;355    }
0000a2  4770              BX       lr
;;;356    
                          ENDP

                  |L17.164|
                          DCD      s_tKey
                  |L17.168|
                          DCD      s_tBtn
                  |L17.172|
                          DCD      IsKeyDown1
                  |L17.176|
                          DCD      IsKeyDown2
                  |L17.180|
                          DCD      IsKeyDown3
                  |L17.184|
                          DCD      IsKeyDown4
                  |L17.188|
                          DCD      IsKeyDown5
                  |L17.192|
                          DCD      IsKeyDown6
                  |L17.196|
                          DCD      IsKeyDown7
                  |L17.200|
                          DCD      IsKeyDown8
                  |L17.204|
                          DCD      IsKeyDown9
                  |L17.208|
                          DCD      IsKeyDown10

                          AREA ||i.bsp_KeyScan||, CODE, READONLY, ALIGN=1

                  bsp_KeyScan PROC
;;;457    */
;;;458    void bsp_KeyScan(void)
000000  b510              PUSH     {r4,lr}
;;;459    {
;;;460    	uint8_t i;
;;;461    
;;;462    	for (i = 0; i < KEY_COUNT; i++)
000002  2400              MOVS     r4,#0
000004  e004              B        |L18.16|
                  |L18.6|
;;;463    	{
;;;464    		bsp_DetectKey(i);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       bsp_DetectKey
00000c  1c60              ADDS     r0,r4,#1              ;462
00000e  b2c4              UXTB     r4,r0                 ;462
                  |L18.16|
000010  2c0a              CMP      r4,#0xa               ;462
000012  dbf8              BLT      |L18.6|
;;;465    	}
;;;466    }
000014  bd10              POP      {r4,pc}
;;;467    
                          ENDP


                          AREA ||i.bsp_PutKey||, CODE, READONLY, ALIGN=2

                  bsp_PutKey PROC
;;;172    */
;;;173    void bsp_PutKey(uint8_t _KeyCode)
000000  4906              LDR      r1,|L19.28|
;;;174    {
;;;175    	s_tKey.Buf[s_tKey.Write] = _KeyCode;
000002  7ac9              LDRB     r1,[r1,#0xb]  ; s_tKey
000004  4a05              LDR      r2,|L19.28|
000006  5450              STRB     r0,[r2,r1]
;;;176    
;;;177    	if (++s_tKey.Write  >= KEY_FIFO_SIZE)
000008  4611              MOV      r1,r2
00000a  7ac9              LDRB     r1,[r1,#0xb]  ; s_tKey
00000c  1c49              ADDS     r1,r1,#1
00000e  b2c9              UXTB     r1,r1
000010  72d1              STRB     r1,[r2,#0xb]
000012  290a              CMP      r1,#0xa
000014  db01              BLT      |L19.26|
;;;178    	{
;;;179    		s_tKey.Write = 0;
000016  2100              MOVS     r1,#0
000018  72d1              STRB     r1,[r2,#0xb]
                  |L19.26|
;;;180    	}
;;;181    }
00001a  4770              BX       lr
;;;182    
                          ENDP

                  |L19.28|
                          DCD      s_tKey

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  s_tBtn
                          %        160
                  s_tKey
                          %        13

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_key.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_bsp_key_c_dc6aca1d____REV16|
#line 129 "D:\\Keil_v4\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_bsp_key_c_dc6aca1d____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_bsp_key_c_dc6aca1d____REVSH|
#line 144
|__asm___9_bsp_key_c_dc6aca1d____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
