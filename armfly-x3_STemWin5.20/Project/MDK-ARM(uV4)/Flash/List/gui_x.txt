; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\gui_x.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=..\output\gui_x.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=870 -I..\..\User -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\User\fonts -I..\..\emWin\GUI_X -I..\..\emWin\Config -I..\..\emWin\Include -I..\..\emWin\emWinTask -I..\..\User\fatfs\src -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM4F -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -ID:\Keil_v4\ARM\RV31\INC -ID:\Keil_v4\ARM\CMSIS\Include -ID:\Keil_v4\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F4XX -DARM_MATH_CM4 -D__CC_ARM ..\..\emWin\GUI_X\GUI_X.c]
                          THUMB

                          AREA ||i.CheckInit||, CODE, READONLY, ALIGN=1

                  CheckInit PROC
;;;136    
;;;137    void CheckInit(void)
000000  4770              BX       lr
;;;138    {
;;;139    //  if(KeyIsInited==0)
;;;140    //    {
;;;141    //      KeyIsInited = 1;
;;;142    //      GUI_X_Init();
;;;143    //    }
;;;144    }
;;;145    
                          ENDP


                          AREA ||i.GUI_X_Delay||, CODE, READONLY, ALIGN=2

                  GUI_X_Delay PROC
;;;49     
;;;50     void GUI_X_Delay(int ms)
000000  4a04              LDR      r2,|L2.20|
;;;51     {
;;;52     	int tEnd = g_iRunTime + ms;
000002  6812              LDR      r2,[r2,#0]  ; g_iRunTime
000004  1811              ADDS     r1,r2,r0
;;;53     	while ((tEnd - g_iRunTime) > 0);
000006  bf00              NOP      
                  |L2.8|
000008  4a02              LDR      r2,|L2.20|
00000a  6812              LDR      r2,[r2,#0]  ; g_iRunTime
00000c  1a8a              SUBS     r2,r1,r2
00000e  2a00              CMP      r2,#0
000010  dcfa              BGT      |L2.8|
;;;54     }
000012  4770              BX       lr
;;;55     
                          ENDP

                  |L2.20|
                          DCD      g_iRunTime

                          AREA ||i.GUI_X_ErrorOut||, CODE, READONLY, ALIGN=1

                  GUI_X_ErrorOut PROC
;;;194    
;;;195    void GUI_X_ErrorOut(const char *s)
000000  4770              BX       lr
;;;196    { 
;;;197    	GUI_USE_PARA(s); 
;;;198    }
                          ENDP


                          AREA ||i.GUI_X_ExecIdle||, CODE, READONLY, ALIGN=1

                  GUI_X_ExecIdle PROC
;;;61     /*WM空闲时调用*/
;;;62     void GUI_X_ExecIdle(void) 
000000  b500              PUSH     {lr}
;;;63     {
;;;64       GUI_X_Delay(1);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       GUI_X_Delay
;;;65     }
000008  bd00              POP      {pc}
;;;66     
                          ENDP


                          AREA ||i.GUI_X_GetKey||, CODE, READONLY, ALIGN=1

                  GUI_X_GetKey PROC
;;;153    
;;;154    int GUI_X_GetKey(void)
000000  4770              BX       lr
;;;155    {
;;;156        int r;
;;;157    //    r = KeyPressed;
;;;158    //    CheckInit();
;;;159    //    KeyPressed = 0;
;;;160        return (r);
;;;161    }
;;;162    
                          ENDP


                          AREA ||i.GUI_X_GetTaskId||, CODE, READONLY, ALIGN=1

                  GUI_X_GetTaskId PROC
;;;97     
;;;98     U32 GUI_X_GetTaskId(void)
000000  2000              MOVS     r0,#0
;;;99     { 
;;;100    //  return ((U32)(OSTCBCur->OSTCBPrio));
;;;101    	return 0;
;;;102    }
000002  4770              BX       lr
;;;103    
                          ENDP


                          AREA ||i.GUI_X_GetTime||, CODE, READONLY, ALIGN=2

                  GUI_X_GetTime PROC
;;;43     extern __IO int32_t g_iRunTime;
;;;44     int GUI_X_GetTime(void)
000000  4801              LDR      r0,|L7.8|
;;;45     {
;;;46     
;;;47     	return g_iRunTime;
000002  6800              LDR      r0,[r0,#0]  ; g_iRunTime
;;;48     }
000004  4770              BX       lr
;;;49     
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      g_iRunTime

                          AREA ||i.GUI_X_Init||, CODE, READONLY, ALIGN=1

                  GUI_X_Init PROC
;;;147    /*被GUI_Init()调用,用来初始化一些GUI运行之前需要用的硬件,如键盘或者鼠标之类的.如果不需要的话,可以为空*/
;;;148    void GUI_X_Init(void)
000000  4770              BX       lr
;;;149    {
;;;150    //  KeySem = OSSemCreate(0);
;;;151    }
;;;152    
                          ENDP


                          AREA ||i.GUI_X_InitOS||, CODE, READONLY, ALIGN=1

                  GUI_X_InitOS PROC
;;;77     
;;;78     void GUI_X_InitOS (void)
000000  4770              BX       lr
;;;79     { 
;;;80     //  DispSem = OSSemCreate(1);              //建立一个互斥型信号量
;;;81     //  EventMbox = OSMboxCreate((void *)0);	//建立一个邮箱
;;;82     }
;;;83     
                          ENDP


                          AREA ||i.GUI_X_Lock||, CODE, READONLY, ALIGN=1

                  GUI_X_Lock PROC
;;;84     
;;;85     void GUI_X_Lock(void)
000000  4770              BX       lr
;;;86     { 
;;;87     //  INT8U err;
;;;88     //  OSSemPend(DispSem,0,&err);
;;;89     }
;;;90     
                          ENDP


                          AREA ||i.GUI_X_Log||, CODE, READONLY, ALIGN=1

                  GUI_X_Log PROC
;;;184    
;;;185    void GUI_X_Log(const char *s) 
000000  4770              BX       lr
;;;186    { 
;;;187    	GUI_USE_PARA(s); 
;;;188    }
;;;189    
                          ENDP


                          AREA ||i.GUI_X_SignalEvent||, CODE, READONLY, ALIGN=1

                  GUI_X_SignalEvent PROC
;;;118    
;;;119    void GUI_X_SignalEvent(void)
000000  4770              BX       lr
;;;120    {
;;;121    //  (void)OSMboxPost(EventMbox,(void *)1);
;;;122    }
;;;123    
                          ENDP


                          AREA ||i.GUI_X_StoreKey||, CODE, READONLY, ALIGN=1

                  GUI_X_StoreKey PROC
;;;178    
;;;179    void GUI_X_StoreKey(int k)
000000  4770              BX       lr
;;;180    {
;;;181    //    KeyPressed = k;
;;;182    //    OSSemPost(KeySem); //释放信号量
;;;183    }
;;;184    
                          ENDP


                          AREA ||i.GUI_X_Unlock||, CODE, READONLY, ALIGN=1

                  GUI_X_Unlock PROC
;;;91     
;;;92     void GUI_X_Unlock(void)
000000  4770              BX       lr
;;;93     { 
;;;94     //  OSSemPost(DispSem);
;;;95     }
;;;96     
                          ENDP


                          AREA ||i.GUI_X_WaitEvent||, CODE, READONLY, ALIGN=1

                  GUI_X_WaitEvent PROC
;;;111    
;;;112    void GUI_X_WaitEvent(void)
000000  4770              BX       lr
;;;113    {
;;;114    //   INT8U err;
;;;115    //   (void)OSMboxPend(EventMbox,0,&err);
;;;116    }
;;;117    
                          ENDP


                          AREA ||i.GUI_X_WaitKey||, CODE, READONLY, ALIGN=1

                  GUI_X_WaitKey PROC
;;;163    
;;;164    int GUI_X_WaitKey(void)
000000  4770              BX       lr
;;;165    {
;;;166         int  r;
;;;167    //    INT8U  err;
;;;168    //    CheckInit();
;;;169    //    if(KeyPressed==0)
;;;170    //      {
;;;171    //        OSSemPend(KeySem,0,&err); //等待信号量
;;;172    //      }
;;;173    //    r= KeyPressed;
;;;174    //    KeyPressed = 0;
;;;175        return (r);
;;;176    }
;;;177    
                          ENDP


                          AREA ||i.GUI_X_Warn||, CODE, READONLY, ALIGN=1

                  GUI_X_Warn PROC
;;;189    
;;;190    void GUI_X_Warn(const char *s) 
000000  4770              BX       lr
;;;191    {
;;;192    	GUI_USE_PARA(s); 
;;;193    }
;;;194    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\emWin\\GUI_X\\GUI_X.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___7_GUI_X_c_f0e17fb0____REV16|
#line 129 "D:\\Keil_v4\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___7_GUI_X_c_f0e17fb0____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___7_GUI_X_c_f0e17fb0____REVSH|
#line 144
|__asm___7_GUI_X_c_f0e17fb0____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
