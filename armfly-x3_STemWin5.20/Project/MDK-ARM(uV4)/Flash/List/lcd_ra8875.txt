; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\lcd_ra8875.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=..\output\lcd_ra8875.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=870 -I..\..\User -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\User\fonts -I..\..\emWin\GUI_X -I..\..\emWin\Config -I..\..\emWin\Include -I..\..\emWin\emWinTask -I..\..\User\fatfs\src -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM4F -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -ID:\Keil_v4\ARM\RV31\INC -ID:\Keil_v4\ARM\CMSIS\Include -ID:\Keil_v4\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F4XX -DARM_MATH_CM4 -D__CC_ARM ..\..\User\bsp_stm32f4xx\src\LCD_RA8875.c]
                          THUMB

                          AREA ||i.BTE_SetOperateCode||, CODE, READONLY, ALIGN=1

                  BTE_SetOperateCode PROC
;;;646    */
;;;647    void BTE_SetOperateCode(uint8_t _ucOperate)
000000  b510              PUSH     {r4,lr}
;;;648    {
000002  4604              MOV      r4,r0
;;;649    	/*  设定BTE 操作码和光栅运算码  */
;;;650    	RA8875_WriteReg(0x51, _ucOperate);
000004  4621              MOV      r1,r4
000006  2051              MOVS     r0,#0x51
000008  f7fffffe          BL       RA8875_WriteReg
;;;651    }
00000c  bd10              POP      {r4,pc}
;;;652    
                          ENDP


                          AREA ||i.BTE_SetTarBlock||, CODE, READONLY, ALIGN=1

                  BTE_SetTarBlock PROC
;;;613    */
;;;614    void BTE_SetTarBlock(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint8_t _ucLayer)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;615    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;616    	/* 设置起点坐标 */
;;;617    	RA8875_WriteReg(0x58, _usX);
000010  b2e9              UXTB     r1,r5
000012  2058              MOVS     r0,#0x58
000014  f7fffffe          BL       RA8875_WriteReg
;;;618    	RA8875_WriteReg(0x59, _usX >> 8);
000018  1229              ASRS     r1,r5,#8
00001a  2059              MOVS     r0,#0x59
00001c  f7fffffe          BL       RA8875_WriteReg
;;;619    
;;;620    	RA8875_WriteReg(0x5A, _usY);
000020  b2e1              UXTB     r1,r4
000022  205a              MOVS     r0,#0x5a
000024  f7fffffe          BL       RA8875_WriteReg
;;;621    	if (_ucLayer == 0)	/* 图层2 */
000028  f1b80f00          CMP      r8,#0
00002c  d104              BNE      |L2.56|
;;;622    	{
;;;623    		RA8875_WriteReg(0x5B, _usY >> 8);
00002e  1221              ASRS     r1,r4,#8
000030  205b              MOVS     r0,#0x5b
000032  f7fffffe          BL       RA8875_WriteReg
000036  e005              B        |L2.68|
                  |L2.56|
;;;624    	}
;;;625    	else
;;;626    	{
;;;627    		RA8875_WriteReg(0x5B, (1 << 7) | (_usY >> 8));	/* Bit7 表示图层， 0 图层1； 1 图层2*/
000038  2080              MOVS     r0,#0x80
00003a  ea402124          ORR      r1,r0,r4,ASR #8
00003e  205b              MOVS     r0,#0x5b
000040  f7fffffe          BL       RA8875_WriteReg
                  |L2.68|
;;;628    	}
;;;629    
;;;630    	/* 设置区块宽度 */
;;;631    	RA8875_WriteReg(0x5C, _usWidth);
000044  b2f9              UXTB     r1,r7
000046  205c              MOVS     r0,#0x5c
000048  f7fffffe          BL       RA8875_WriteReg
;;;632    	RA8875_WriteReg(0x5D, _usWidth >> 8);
00004c  1239              ASRS     r1,r7,#8
00004e  205d              MOVS     r0,#0x5d
000050  f7fffffe          BL       RA8875_WriteReg
;;;633    
;;;634    	/* 设置区块高度 */
;;;635    	RA8875_WriteReg(0x5E, _usHeight);
000054  b2f1              UXTB     r1,r6
000056  205e              MOVS     r0,#0x5e
000058  f7fffffe          BL       RA8875_WriteReg
;;;636    	RA8875_WriteReg(0x5F, _usHeight >> 8);
00005c  1231              ASRS     r1,r6,#8
00005e  205f              MOVS     r0,#0x5f
000060  f7fffffe          BL       RA8875_WriteReg
;;;637    }
000064  e8bd81f0          POP      {r4-r8,pc}
;;;638    
                          ENDP


                          AREA ||i.BTE_Start||, CODE, READONLY, ALIGN=2

                  BTE_Start PROC
;;;695    */
;;;696    void BTE_Start(void)
000000  b510              PUSH     {r4,lr}
;;;697    {
;;;698    	s_ucRA8875Busy = 1;
000002  2001              MOVS     r0,#1
000004  4904              LDR      r1,|L3.24|
000006  7008              STRB     r0,[r1,#0]
;;;699    	/* RA8875_WriteReg(0x50, 0x80);  不能使用这个函数，因为内部已经操作了 s_ucRA8875Busy 标志 */
;;;700    	RA8875_WriteCmd(0x50);	/* 设置寄存器地址 */
000008  2050              MOVS     r0,#0x50
00000a  f7fffffe          BL       RA8875_WriteCmd
;;;701    	RA8875_WriteData(0x80);	/* 写入寄存器值 */
00000e  2080              MOVS     r0,#0x80
000010  f7fffffe          BL       RA8875_WriteData
;;;702    }
000014  bd10              POP      {r4,pc}
;;;703    
                          ENDP

000016  0000              DCW      0x0000
                  |L3.24|
                          DCD      s_ucRA8875Busy

                          AREA ||i.BTE_Wait||, CODE, READONLY, ALIGN=2

                  BTE_Wait PROC
;;;711    */
;;;712    void BTE_Wait(void)
000000  b510              PUSH     {r4,lr}
;;;713    {
;;;714    	while ((RA8875_ReadStatus() & 0x40) == 0x40);
000002  bf00              NOP      
                  |L4.4|
000004  f7fffffe          BL       RA8875_ReadStatus
000008  f0000040          AND      r0,r0,#0x40
00000c  2840              CMP      r0,#0x40
00000e  d0f9              BEQ      |L4.4|
;;;715    	s_ucRA8875Busy = 0;
000010  2000              MOVS     r0,#0
000012  4901              LDR      r1,|L4.24|
000014  7008              STRB     r0,[r1,#0]
;;;716    }
000016  bd10              POP      {r4,pc}
;;;717    
                          ENDP

                  |L4.24|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_ClrScr||, CODE, READONLY, ALIGN=2

                  RA8875_ClrScr PROC
;;;1051   */
;;;1052   void RA8875_ClrScr(uint16_t _usColor)
000000  b538              PUSH     {r3-r5,lr}
;;;1053   {
000002  4604              MOV      r4,r0
;;;1054   	/* 也可以通过0x30-0x37寄存器获得获得当前激活的显示窗口 */
;;;1055   
;;;1056   	/* 单色填满功能, 中文pdf 第162页
;;;1057   	此功能使用于将选定特定区域画面清除或是\入给定某种前景色，R8875 填入的单色设定为BTE 前景色。
;;;1058   
;;;1059   	操作步骤：
;;;1060   		1. 设定目的图层和位置 REG[58h], [59h], [5Ah], [5Bh]
;;;1061   		2. 设定BTE 宽度和高度 REG[5Ch], [5Dh], [5Eh], [5Fh]
;;;1062   		3. 设定BTE 操作码和光栅运算码  REG[51h] Bit[3:0] = 0Ch
;;;1063   		4. 设定前景色  REG[63h], [64h], [65h]
;;;1064   		5. 开启BTE 功能  REG[50h] Bit7 = 1
;;;1065   		6. 检查状态缓存器 STSR Bit6，确认BTE 是否完成
;;;1066   	*/
;;;1067   	BTE_SetTarBlock(s_WinX, s_WinY, s_WinHeight, s_WinWidth, 0);	/* 设置BTE位置和宽度高度以及目标图层（0或1） */
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  480a              LDR      r0,|L5.52|
00000a  8803              LDRH     r3,[r0,#0]  ; s_WinWidth
00000c  480a              LDR      r0,|L5.56|
00000e  8802              LDRH     r2,[r0,#0]  ; s_WinHeight
000010  480a              LDR      r0,|L5.60|
000012  8801              LDRH     r1,[r0,#0]  ; s_WinY
000014  480a              LDR      r0,|L5.64|
000016  8800              LDRH     r0,[r0,#0]  ; s_WinX
000018  f7fffffe          BL       BTE_SetTarBlock
;;;1068   	BTE_SetOperateCode(0x0C);		/* 设定BTE 操作码和光栅运算码  REG[51h] Bit[3:0] = 0Ch */
00001c  200c              MOVS     r0,#0xc
00001e  f7fffffe          BL       BTE_SetOperateCode
;;;1069   	RA8875_SetFrontColor(_usColor);	/* 设置BTE前景色 */
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       RA8875_SetFrontColor
;;;1070   	BTE_Start();					/* 开启BTE 功能 */
000028  f7fffffe          BL       BTE_Start
;;;1071   	BTE_Wait();						/* 等待操作结束 */
00002c  f7fffffe          BL       BTE_Wait
;;;1072   }
000030  bd38              POP      {r3-r5,pc}
;;;1073   
                          ENDP

000032  0000              DCW      0x0000
                  |L5.52|
                          DCD      s_WinWidth
                  |L5.56|
                          DCD      s_WinHeight
                  |L5.60|
                          DCD      s_WinY
                  |L5.64|
                          DCD      s_WinX

                          AREA ||i.RA8875_CtrlGPO||, CODE, READONLY, ALIGN=1

                  RA8875_CtrlGPO PROC
;;;1755   */
;;;1756   void RA8875_CtrlGPO(uint8_t _pin, uint8_t _value)
000000  b570              PUSH     {r4-r6,lr}
;;;1757   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1758   	RA8875_WriteReg(0x13, _value << _pin);
000006  fa05f004          LSL      r0,r5,r4
00000a  b2c1              UXTB     r1,r0
00000c  2013              MOVS     r0,#0x13
00000e  f7fffffe          BL       RA8875_WriteReg
;;;1759   }
000012  bd70              POP      {r4-r6,pc}
;;;1760   
                          ENDP


                          AREA ||i.RA8875_Delaly1ms||, CODE, READONLY, ALIGN=1

                  RA8875_Delaly1ms PROC
;;;65     
;;;66     static void RA8875_Delaly1ms(void)
000000  2000              MOVS     r0,#0
;;;67     {
;;;68     	uint16_t i;
;;;69     
;;;70     	for (i = 0; i < 5000; i++);	/* 延迟1us, 不准 */
000002  e001              B        |L7.8|
                  |L7.4|
000004  1c41              ADDS     r1,r0,#1
000006  b288              UXTH     r0,r1
                  |L7.8|
000008  f2413188          MOV      r1,#0x1388
00000c  4288              CMP      r0,r1
00000e  dbf9              BLT      |L7.4|
;;;71     }
000010  4770              BX       lr
;;;72     
                          ENDP


                          AREA ||i.RA8875_Delaly1us||, CODE, READONLY, ALIGN=1

                  RA8875_Delaly1us PROC
;;;58     
;;;59     static void RA8875_Delaly1us(void)
000000  2000              MOVS     r0,#0
;;;60     {
;;;61     	uint8_t i;
;;;62     
;;;63     	for (i = 0; i < 10; i++);	/* 延迟, 不准 */
000002  e001              B        |L8.8|
                  |L8.4|
000004  1c41              ADDS     r1,r0,#1
000006  b2c8              UXTB     r0,r1
                  |L8.8|
000008  280a              CMP      r0,#0xa
00000a  dbfb              BLT      |L8.4|
;;;64     }
00000c  4770              BX       lr
;;;65     
                          ENDP


                          AREA ||i.RA8875_Delaly200us||, CODE, READONLY, ALIGN=1

                  RA8875_Delaly200us PROC
;;;72     
;;;73     static void RA8875_Delaly200us(void)
000000  2000              MOVS     r0,#0
;;;74     {
;;;75     	uint16_t i;
;;;76     
;;;77     	for (i = 0; i < 1000; i++);	/* 延迟1us, 不准 */
000002  e001              B        |L9.8|
                  |L9.4|
000004  1c41              ADDS     r1,r0,#1
000006  b288              UXTH     r0,r1
                  |L9.8|
000008  f5b07f7a          CMP      r0,#0x3e8
00000c  dbfa              BLT      |L9.4|
;;;78     }
00000e  4770              BX       lr
;;;79     
                          ENDP


                          AREA ||i.RA8875_DispAscii||, CODE, READONLY, ALIGN=2

                  RA8875_DispAscii PROC
;;;1476   */
;;;1477   void RA8875_DispAscii(uint16_t _usX, uint16_t _usY, char *_ptr)
000000  b570              PUSH     {r4-r6,lr}
;;;1478   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;1479   	/*
;;;1480   		RA8875 内建8x16 点的ASCII 字型ROM，提供使用者更方便的方式用特定编码 (Code) 输入文
;;;1481   		字。内建的字集支持ISO/IEC 8859-1~4 编码标准，此外，使用者可以透过REG[60h~62h] 选择
;;;1482   		文字前景颜色，以及透过REG[63h~65h] 选择背景颜色.
;;;1483   
;;;1484   		ISO/IEC 8859-1，又称Latin-1或“西欧语言”，是国际标准化组织内ISO/IEC 8859的第一个8位字符集。
;;;1485   		它以ASCII为基础，在空置的0xA0-0xFF的范围内，加入192个字母及符号，藉以供使用变音符号的拉丁字母语言使用。
;;;1486   
;;;1487   		ISO/IEC 8859-2 Latin-2或“中欧语言”，是国际标准化组织内ISO/IEC 8859的其中一个8位字符集 .
;;;1488   		ISO/IEC 8859-3 南欧语言字符集
;;;1489   		ISO/IEC 8859-4 北欧语言字符集
;;;1490   	*/
;;;1491   
;;;1492   	/*
;;;1493   	(1) Text mode  REG[40h] bit7=1
;;;1494   	(2) Internal Font ROM Select   REG[21h] bit7=0, bit5=0
;;;1495   	(3) Font foreground and background color Select  REG[63h~65h], REG[60h~62h]
;;;1496   	(4) Write the font Code  CMD_WR[02h]    DATA_WR[font_code]
;;;1497   	*/
;;;1498   
;;;1499   	RA8875_SetTextCursor(_usX, _usY);
000008  4631              MOV      r1,r6
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       RA8875_SetTextCursor
;;;1500   
;;;1501   	RA8875_WriteReg(0x40, (1 << 7));	/* 设置为文本模式 */
000010  2180              MOVS     r1,#0x80
000012  2040              MOVS     r0,#0x40
000014  f7fffffe          BL       RA8875_WriteReg
;;;1502   
;;;1503   	/* 选择CGROM font; 选择内部CGROM; 内部CGROM 编码选择ISO/IEC 8859-1. */
;;;1504   	RA8875_WriteReg(0x2F, 0x00);
000018  2100              MOVS     r1,#0
00001a  202f              MOVS     r0,#0x2f
00001c  f7fffffe          BL       RA8875_WriteReg
;;;1505   	RA8875_WriteReg(0x21, (0 << 7) | (0 << 5) | (0 << 1) | (0 << 0));
000020  2100              MOVS     r1,#0
000022  2021              MOVS     r0,#0x21
000024  f7fffffe          BL       RA8875_WriteReg
;;;1506   
;;;1507   	s_ucRA8875Busy = 1;
000028  2001              MOVS     r0,#1
00002a  490d              LDR      r1,|L10.96|
00002c  7008              STRB     r0,[r1,#0]
;;;1508   
;;;1509   
;;;1510   	RA8875_WriteCmd(0x02); 			/* 用于设定RA8875 进入内存(DDRAM或CGRAM)读取/写入模式 */
00002e  2002              MOVS     r0,#2
000030  f7fffffe          BL       RA8875_WriteCmd
;;;1511   
;;;1512   	/* 开始循环处理字符 */
;;;1513   	while (*_ptr != 0)
000034  e00a              B        |L10.76|
                  |L10.54|
;;;1514   	{
;;;1515   		RA8875_WriteData(*_ptr);
000036  7820              LDRB     r0,[r4,#0]
000038  f7fffffe          BL       RA8875_WriteData
;;;1516   		while ((RA8875_ReadStatus() & 0x80) == 0x80);	/* 必须等待内部写屏操作完成 */
00003c  bf00              NOP      
                  |L10.62|
00003e  f7fffffe          BL       RA8875_ReadStatus
000042  f0000080          AND      r0,r0,#0x80
000046  2880              CMP      r0,#0x80
000048  d0f9              BEQ      |L10.62|
;;;1517   		_ptr++;
00004a  1c64              ADDS     r4,r4,#1
                  |L10.76|
00004c  7820              LDRB     r0,[r4,#0]            ;1513
00004e  2800              CMP      r0,#0                 ;1513
000050  d1f1              BNE      |L10.54|
;;;1518   	}
;;;1519   	s_ucRA8875Busy = 0;
000052  4903              LDR      r1,|L10.96|
000054  7008              STRB     r0,[r1,#0]
;;;1520   
;;;1521   	RA8875_WriteReg(0x40, (0 << 7));	/* 还原为图形模式 */
000056  2100              MOVS     r1,#0
000058  2040              MOVS     r0,#0x40
00005a  f7fffffe          BL       RA8875_WriteReg
;;;1522   }
00005e  bd70              POP      {r4-r6,pc}
;;;1523   
                          ENDP

                  |L10.96|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_DispOff||, CODE, READONLY, ALIGN=1

                  RA8875_DispOff PROC
;;;960    */
;;;961    void RA8875_DispOff(void)
000000  b510              PUSH     {r4,lr}
;;;962    {
;;;963    	RA8875_WriteReg(0x01, 0x00);
000002  2100              MOVS     r1,#0
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       RA8875_WriteReg
;;;964    }
00000a  bd10              POP      {r4,pc}
;;;965    
                          ENDP


                          AREA ||i.RA8875_DispOn||, CODE, READONLY, ALIGN=1

                  RA8875_DispOn PROC
;;;947    */
;;;948    void RA8875_DispOn(void)
000000  b510              PUSH     {r4,lr}
;;;949    {
;;;950    	RA8875_WriteReg(0x01, 0x80);
000002  2180              MOVS     r1,#0x80
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       RA8875_WriteReg
;;;951    }
00000a  bd10              POP      {r4,pc}
;;;952    
                          ENDP


                          AREA ||i.RA8875_DispStr||, CODE, READONLY, ALIGN=2

                  RA8875_DispStr PROC
;;;1535   */
;;;1536   void RA8875_DispStr(uint16_t _usX, uint16_t _usY, char *_ptr)
000000  b570              PUSH     {r4-r6,lr}
;;;1537   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;1538   	/*
;;;1539   		RA8875 透过使用 ― 上海集通公司 (Genitop Inc) 外部串行式字体内存 (Font ROM)，可支持各样
;;;1540   		的文字写入到DDRAM 中。RA8875 与上海集通公司 (Genitop Inc) 兼容的产品包含 :
;;;1541   		GT21L16TW/GT21H16T1W 、GT23L16U2W 、GT23L24T3Y/GT23H24T3Y 、GT23L24M1Z 、
;;;1542   		及 GT23L32S4W/GT23H32S4W。这些字体包含16x16, 24x24, 32x32 点 (Dot) 与不同的字
;;;1543   
;;;1544   		安富莱RA8875驱动板集成的字库芯片为 集通字库芯片_GT23l32S4W
;;;1545   
;;;1546   		GT23L32S4W是一款内含11X12点阵、15X16点、24X24点阵、32X32点阵的汉字库芯片，支持GB2312
;;;1547   		国标汉字（含有国家信标委合法授权）及SCII字符。排列格式为横置横排。用户通过字符内码，利用本手
;;;1548   		册提供的方法计算出该字符点阵在芯片中的地址，可从该地址连续读出字符点阵信息。
;;;1549   	*/
;;;1550   
;;;1551   	/* 设置文本显示位置，注意文本模式的写入光标和图形模式的写入光标是不同的寄存器 */
;;;1552   	RA8875_SetTextCursor(_usX, _usY);
000008  4631              MOV      r1,r6
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       RA8875_SetTextCursor
;;;1553   
;;;1554   	RA8875_WriteReg(0x40, (1 << 7));	/* 设置为文本模式 */
000010  2180              MOVS     r1,#0x80
000012  2040              MOVS     r0,#0x40
000014  f7fffffe          BL       RA8875_WriteReg
;;;1555   
;;;1556   	/*
;;;1557   		Serial Flash/ROM 频率频率设定
;;;1558   			0xb: SFCL 频率 = 系统频率频率(当DMA 为致能状态，并且色彩深度为256 色，则SFCL 频率
;;;1559   				固定为=系统频率频率/ 2)
;;;1560   			10b: SFCL 频率 =系统频率频率/ 2
;;;1561   			11b: SFCL 频率 =系统频率频率/ 4
;;;1562   
;;;1563   		安富莱驱动板系统频率为 68MHz
;;;1564   
;;;1565   		GT23L32S4W的访问速度：SPI 时钟频率：20MHz(max.)
;;;1566   
;;;1567   		因此需要设置 4 分频, 17MHz
;;;1568   	*/
;;;1569   	RA8875_WriteReg(0x06, (3 << 0));	/* 设置为文本模式 */
000018  2103              MOVS     r1,#3
00001a  2006              MOVS     r0,#6
00001c  f7fffffe          BL       RA8875_WriteReg
;;;1570   
;;;1571   	/* 选择外部字体ROM */
;;;1572   	RA8875_WriteReg(0x21, (0 << 7) | (1 << 5));
000020  2120              MOVS     r1,#0x20
000022  2021              MOVS     r0,#0x21
000024  f7fffffe          BL       RA8875_WriteReg
;;;1573   
;;;1574   	/* 05H  REG[05h] Serial Flash/ROM Configuration Register (SROC)
;;;1575   		7	Serial Flash/ROM I/F # 选择
;;;1576   				0:选择Serial Flash/ROM 0 接口。[安富莱RA8875驱动板字库芯片接在 0 接口]
;;;1577   				1:选择Serial Flash/ROM 1 接口。
;;;1578   		6	Serial Flash/ROM 寻址模式
;;;1579   				0: 24 位寻址模式。
;;;1580   				此位必须设为0。
;;;1581   		5	Serial Flash/ROM 波形模式
;;;1582   				0: 波形模式 0。
;;;1583   				1: 波形模式 3。
;;;1584   		4-3	Serial Flash /ROM 读取周期 (Read Cycle)
;;;1585   			00b: 4 bus ?? 无空周期 (No Dummy Cycle)。
;;;1586   			01b: 5 bus ??1 byte 空周期。
;;;1587   			1Xb: 6 bus ??2 byte 空周期。
;;;1588   		2	Serial Flash /ROM 存取模式 (Access Mode)
;;;1589   			0: 字型模式 。
;;;1590   			1: DMA 模式。
;;;1591   		1-0	Serial Flash /ROM I/F Data Latch 选择模式
;;;1592   			0Xb: 单一模式。
;;;1593   			10b: 双倍模式0。
;;;1594   			11b: 双倍模式1。
;;;1595   	*/
;;;1596   	RA8875_WriteReg(0x05, (0 << 7) | (0 << 6) | (1 << 5) | (1 << 3) | (0 << 2) | (0 << 1));
000028  2128              MOVS     r1,#0x28
00002a  2005              MOVS     r0,#5
00002c  f7fffffe          BL       RA8875_WriteReg
;;;1597   
;;;1598   	/*
;;;1599   		设置外部字体芯片型号为 GT23L32S4W, 编码为GB2312,
;;;1600   
;;;1601   		Bit1:0 决定ASCII字符的格式：
;;;1602   			0 = NORMAL		 [笔画细, 和汉字顶部对齐]
;;;1603   			1 = Arial		 [笔画粗，和汉字底部对齐]
;;;1604   			2 = Roman		 [笔画细, 和汉字底部对齐]
;;;1605   			3 = Bold		 [乱码,不可用]
;;;1606   	 */
;;;1607   	RA8875_WriteReg(0x2F, (4 << 5) | (0 << 2) | (1 << 0));
000030  2181              MOVS     r1,#0x81
000032  202f              MOVS     r0,#0x2f
000034  f7fffffe          BL       RA8875_WriteReg
;;;1608   
;;;1609   	s_ucRA8875Busy = 1;
000038  2001              MOVS     r0,#1
00003a  490d              LDR      r1,|L13.112|
00003c  7008              STRB     r0,[r1,#0]
;;;1610   	RA8875_WriteCmd(0x02); 			/* 用于设定RA8875 进入内存(DDRAM或CGRAM)读取/写入模式 */
00003e  2002              MOVS     r0,#2
000040  f7fffffe          BL       RA8875_WriteCmd
;;;1611   
;;;1612   	/* 开始循环处理字符 */
;;;1613   	while (*_ptr != 0)
000044  e00a              B        |L13.92|
                  |L13.70|
;;;1614   	{
;;;1615   		RA8875_WriteData(*_ptr);
000046  7820              LDRB     r0,[r4,#0]
000048  f7fffffe          BL       RA8875_WriteData
;;;1616   		while ((RA8875_ReadStatus() & 0x80) == 0x80);
00004c  bf00              NOP      
                  |L13.78|
00004e  f7fffffe          BL       RA8875_ReadStatus
000052  f0000080          AND      r0,r0,#0x80
000056  2880              CMP      r0,#0x80
000058  d0f9              BEQ      |L13.78|
;;;1617   		_ptr++;
00005a  1c64              ADDS     r4,r4,#1
                  |L13.92|
00005c  7820              LDRB     r0,[r4,#0]            ;1613
00005e  2800              CMP      r0,#0                 ;1613
000060  d1f1              BNE      |L13.70|
;;;1618   	}
;;;1619   	s_ucRA8875Busy = 0;
000062  4903              LDR      r1,|L13.112|
000064  7008              STRB     r0,[r1,#0]
;;;1620   
;;;1621   	RA8875_WriteReg(0x40, (0 << 7));	/* 还原为图形模式 */
000066  2100              MOVS     r1,#0
000068  2040              MOVS     r0,#0x40
00006a  f7fffffe          BL       RA8875_WriteReg
;;;1622   }
00006e  bd70              POP      {r4-r6,pc}
;;;1623   
                          ENDP

                  |L13.112|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_DrawBMP||, CODE, READONLY, ALIGN=2

                  RA8875_DrawBMP PROC
;;;1085   */
;;;1086   void RA8875_DrawBMP(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint16_t *_ptr)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1087   {
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
00000c  f8dda020          LDR      r10,[sp,#0x20]
;;;1088   	uint32_t index = 0;
000010  2600              MOVS     r6,#0
;;;1089   	const uint16_t *p;
;;;1090   
;;;1091   	/* 设置图片的位置和大小， 即设置显示窗口 */
;;;1092   	RA8875_SetDispWin(_usX, _usY, _usHeight, _usWidth);
000012  462b              MOV      r3,r5
000014  4622              MOV      r2,r4
000016  4649              MOV      r1,r9
000018  4640              MOV      r0,r8
00001a  f7fffffe          BL       RA8875_SetDispWin
;;;1093   
;;;1094   	s_ucRA8875Busy = 1;
00001e  2001              MOVS     r0,#1
000020  490b              LDR      r1,|L14.80|
000022  7008              STRB     r0,[r1,#0]
;;;1095   
;;;1096   	RA8875_WriteCmd(0x02); 		/* 准备读写显存 */
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       RA8875_WriteCmd
;;;1097   
;;;1098   	p = _ptr;
00002a  4657              MOV      r7,r10
;;;1099   	for (index = 0; index < _usHeight * _usWidth; index++)
00002c  bf00              NOP      
00002e  e004              B        |L14.58|
                  |L14.48|
;;;1100   	{
;;;1101   		/*
;;;1102   			armfly : 进行优化, 函数就地展开
;;;1103   			RA8875_WriteRAM(_ptr[index]);
;;;1104   
;;;1105   			此处可考虑用DMA操作
;;;1106   		*/
;;;1107   		RA8875_WriteData16(*p++);
000030  f8370b02          LDRH     r0,[r7],#2
000034  f7fffffe          BL       RA8875_WriteData16
000038  1c76              ADDS     r6,r6,#1              ;1099
                  |L14.58|
00003a  fb04f005          MUL      r0,r4,r5              ;1099
00003e  42b0              CMP      r0,r6                 ;1099
000040  d8f6              BHI      |L14.48|
;;;1108   	}
;;;1109   	s_ucRA8875Busy = 0;
000042  2000              MOVS     r0,#0
000044  4902              LDR      r1,|L14.80|
000046  7008              STRB     r0,[r1,#0]
;;;1110   
;;;1111   	/* 退出窗口绘图模式 */
;;;1112   	RA8875_QuitWinMode();
000048  f7fffffe          BL       RA8875_QuitWinMode
;;;1113   }
00004c  e8bd87f0          POP      {r4-r10,pc}
;;;1114   
                          ENDP

                  |L14.80|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_DrawCircle||, CODE, READONLY, ALIGN=2

                  RA8875_DrawCircle PROC
;;;1327   */
;;;1328   void RA8875_DrawCircle(uint16_t _usX, uint16_t _usY, uint16_t _usRadius, uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1329   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1330   	/*
;;;1331   		RA8875 支持圆形绘图功能，让使用者以简易或低速的MCU 就可以在TFT 模块上画圆。先设定
;;;1332   		圆的中心点REG[99h~9Ch]，圆的半径REG[9Dh]，圆的颜色REG[63h~65h]，然后启动绘图
;;;1333   		REG[90h] Bit6 = 1，RA8875 就会将圆的图形写入DDRAM，相对的在TFT 模块上就可以显示所
;;;1334   		画的圆。若设定REG[90h] Bit5 = 1，则可画出一实心圆 (Fill)；若设定REG[90h] Bit5 = 0，则可
;;;1335   		画出空心圆 (Not Fill
;;;1336   	*/
;;;1337   	/* 设置圆的半径 */
;;;1338   	if (_usRadius > 255)
00000c  2eff              CMP      r6,#0xff
00000e  dd01              BLE      |L15.20|
                  |L15.16|
;;;1339   	{
;;;1340   		return;
;;;1341   	}
;;;1342   
;;;1343   	/* 设置圆心坐标 */
;;;1344   	RA8875_WriteReg(0x99, _usX);
;;;1345   	RA8875_WriteReg(0x9A, _usX >> 8);
;;;1346   	RA8875_WriteReg(0x9B, _usY);
;;;1347   	RA8875_WriteReg(0x9C, _usY >> 8);
;;;1348   
;;;1349   	RA8875_WriteReg(0x9D, _usRadius);	/* 设置圆的半径 */
;;;1350   
;;;1351   	RA8875_SetFrontColor(_usColor);	/* 设置颜色 */
;;;1352   
;;;1353   	s_ucRA8875Busy = 1;
;;;1354   	RA8875_WriteReg(0x90, (1 << 6) | (0 << 5));				/* 开始画圆, 不填充  */
;;;1355   //	while (RA8875_ReadReg(0x90) & (1 << 6));				/* 等待结束 */
;;;1356   	RA8875_WaitBusy();
;;;1357   	s_ucRA8875Busy = 0;
;;;1358   }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L15.20|
000014  b2e1              UXTB     r1,r4                 ;1344
000016  2099              MOVS     r0,#0x99              ;1344
000018  f7fffffe          BL       RA8875_WriteReg
00001c  1221              ASRS     r1,r4,#8              ;1345
00001e  209a              MOVS     r0,#0x9a              ;1345
000020  f7fffffe          BL       RA8875_WriteReg
000024  b2e9              UXTB     r1,r5                 ;1346
000026  209b              MOVS     r0,#0x9b              ;1346
000028  f7fffffe          BL       RA8875_WriteReg
00002c  1229              ASRS     r1,r5,#8              ;1347
00002e  209c              MOVS     r0,#0x9c              ;1347
000030  f7fffffe          BL       RA8875_WriteReg
000034  b2f1              UXTB     r1,r6                 ;1349
000036  209d              MOVS     r0,#0x9d              ;1349
000038  f7fffffe          BL       RA8875_WriteReg
00003c  4638              MOV      r0,r7                 ;1351
00003e  f7fffffe          BL       RA8875_SetFrontColor
000042  2001              MOVS     r0,#1                 ;1353
000044  4906              LDR      r1,|L15.96|
000046  7008              STRB     r0,[r1,#0]            ;1353
000048  2140              MOVS     r1,#0x40              ;1354
00004a  2090              MOVS     r0,#0x90              ;1354
00004c  f7fffffe          BL       RA8875_WriteReg
000050  f7fffffe          BL       RA8875_WaitBusy
000054  2000              MOVS     r0,#0                 ;1357
000056  4902              LDR      r1,|L15.96|
000058  7008              STRB     r0,[r1,#0]            ;1357
00005a  bf00              NOP      
00005c  e7d8              B        |L15.16|
;;;1359   
                          ENDP

00005e  0000              DCW      0x0000
                  |L15.96|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_DrawHColorLine||, CODE, READONLY, ALIGN=1

                  RA8875_DrawHColorLine PROC
;;;1869   */
;;;1870   void RA8875_DrawHColorLine(uint16_t _usX1 , uint16_t _usY1, uint16_t _usWidth, uint16_t *_pColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1871   {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
00000a  461c              MOV      r4,r3
;;;1872   	uint16_t i;
;;;1873   
;;;1874   	RA8875_SetCursor(_usX1, _usY1);
00000c  4641              MOV      r1,r8
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       RA8875_SetCursor
;;;1875   
;;;1876   
;;;1877   	RA8875_WriteCmd(0x02); 		/* 用于设定RA8875 进入内存(DDRAM或CGRAM)读取/写入模式 */
000014  2002              MOVS     r0,#2
000016  f7fffffe          BL       RA8875_WriteCmd
;;;1878   
;;;1879   	for (i = 0; i < _usWidth; i++)
00001a  2600              MOVS     r6,#0
00001c  e005              B        |L16.42|
                  |L16.30|
;;;1880   	{
;;;1881   		RA8875_WriteData16(*_pColor++);
00001e  f8340b02          LDRH     r0,[r4],#2
000022  f7fffffe          BL       RA8875_WriteData16
000026  1c70              ADDS     r0,r6,#1              ;1879
000028  b286              UXTH     r6,r0                 ;1879
                  |L16.42|
00002a  42ae              CMP      r6,r5                 ;1879
00002c  dbf7              BLT      |L16.30|
;;;1882   	}
;;;1883   
;;;1884   }
00002e  e8bd81f0          POP      {r4-r8,pc}
;;;1885   
                          ENDP


                          AREA ||i.RA8875_DrawHLine||, CODE, READONLY, ALIGN=1

                  RA8875_DrawHLine PROC
;;;1844   */
;;;1845   void RA8875_DrawHLine(uint16_t _usX1 , uint16_t _usY1 , uint16_t _usX2 , uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1846   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;1847   	uint16_t i;
;;;1848   
;;;1849   	RA8875_SetCursor(_usX1, _usY1);
00000c  4641              MOV      r1,r8
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       RA8875_SetCursor
;;;1850   
;;;1851   	RA8875_WriteCmd(0x02); 		/* 用于设定RA8875 进入内存(DDRAM或CGRAM)读取/写入模式 */
000014  2002              MOVS     r0,#2
000016  f7fffffe          BL       RA8875_WriteCmd
;;;1852   	for (i = 0; i < _usX2 - _usX1 + 1; i++)
00001a  2700              MOVS     r7,#0
00001c  e004              B        |L17.40|
                  |L17.30|
;;;1853   	{
;;;1854   		RA8875_WriteData16(_usColor);
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       RA8875_WriteData16
000024  1c78              ADDS     r0,r7,#1              ;1852
000026  b287              UXTH     r7,r0                 ;1852
                  |L17.40|
000028  1b28              SUBS     r0,r5,r4              ;1852
00002a  1c40              ADDS     r0,r0,#1              ;1852
00002c  42b8              CMP      r0,r7                 ;1852
00002e  dcf6              BGT      |L17.30|
;;;1855   	}
;;;1856   
;;;1857   }
000030  e8bd81f0          POP      {r4-r8,pc}
;;;1858   
                          ENDP


                          AREA ||i.RA8875_DrawLine||, CODE, READONLY, ALIGN=2

                  RA8875_DrawLine PROC
;;;1180   */
;;;1181   void RA8875_DrawLine(uint16_t _usX1 , uint16_t _usY1 , uint16_t _usX2 , uint16_t _usY2 , uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1182   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;1183   	/* pdf 第131页
;;;1184   		RA8875 支持直线绘图功能，让使用者以简易或低速的MCU 就可以在TFT 模块上画直线。先设
;;;1185   		定直线的起始点REG[91h~94h] 与结束点REG[95h~98h]，直线的颜色REG[63h~65h]，然后启
;;;1186   		动绘图设定REG[90h] Bit4 = 0, Bit0=0 且REG[90h] Bit7 = 1，RA8875 就会将直线的图形写入
;;;1187   		DDRAM，相对的在TFT 模块上就可以显示所画的直线。
;;;1188   	*/
;;;1189   
;;;1190   	if ((_usX1 == _usX2) && (_usY1 == _usY2))
000010  42b4              CMP      r4,r6
000012  d108              BNE      |L18.38|
000014  42bd              CMP      r5,r7
000016  d106              BNE      |L18.38|
;;;1191   	{
;;;1192   		RA8875_PutPixel(_usX1, _usY1, _usColor);
000018  4642              MOV      r2,r8
00001a  4629              MOV      r1,r5
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       RA8875_PutPixel
                  |L18.34|
;;;1193   		return;
;;;1194   	}
;;;1195   	
;;;1196   	/* 设置起点坐标 */
;;;1197   	RA8875_WriteReg(0x91, _usX1);
;;;1198   	RA8875_WriteReg(0x92, _usX1 >> 8);
;;;1199   	RA8875_WriteReg(0x93, _usY1);
;;;1200   	RA8875_WriteReg(0x94, _usY1 >> 8);
;;;1201   
;;;1202   	/* 设置终点坐标 */
;;;1203   	RA8875_WriteReg(0x95, _usX2);
;;;1204   	RA8875_WriteReg(0x96, _usX2 >> 8);
;;;1205   	RA8875_WriteReg(0x97, _usY2);
;;;1206   	RA8875_WriteReg(0x98, _usY2 >> 8);
;;;1207   
;;;1208   	RA8875_SetFrontColor(_usColor);	/* 设置直线的颜色 */
;;;1209   
;;;1210   	s_ucRA8875Busy = 1;
;;;1211   	RA8875_WriteReg(0x90, (1 << 7) | (0 << 4) | (0 << 0));	/* 开始画直线 */
;;;1212   //	while (RA8875_ReadReg(0x90) & (1 << 7));				/* 等待结束 */
;;;1213   	RA8875_WaitBusy();
;;;1214   	s_ucRA8875Busy = 0;
;;;1215   }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L18.38|
000026  b2e1              UXTB     r1,r4                 ;1197
000028  2091              MOVS     r0,#0x91              ;1197
00002a  f7fffffe          BL       RA8875_WriteReg
00002e  1221              ASRS     r1,r4,#8              ;1198
000030  2092              MOVS     r0,#0x92              ;1198
000032  f7fffffe          BL       RA8875_WriteReg
000036  b2e9              UXTB     r1,r5                 ;1199
000038  2093              MOVS     r0,#0x93              ;1199
00003a  f7fffffe          BL       RA8875_WriteReg
00003e  1229              ASRS     r1,r5,#8              ;1200
000040  2094              MOVS     r0,#0x94              ;1200
000042  f7fffffe          BL       RA8875_WriteReg
000046  b2f1              UXTB     r1,r6                 ;1203
000048  2095              MOVS     r0,#0x95              ;1203
00004a  f7fffffe          BL       RA8875_WriteReg
00004e  1231              ASRS     r1,r6,#8              ;1204
000050  2096              MOVS     r0,#0x96              ;1204
000052  f7fffffe          BL       RA8875_WriteReg
000056  b2f9              UXTB     r1,r7                 ;1205
000058  2097              MOVS     r0,#0x97              ;1205
00005a  f7fffffe          BL       RA8875_WriteReg
00005e  1239              ASRS     r1,r7,#8              ;1206
000060  2098              MOVS     r0,#0x98              ;1206
000062  f7fffffe          BL       RA8875_WriteReg
000066  4640              MOV      r0,r8                 ;1208
000068  f7fffffe          BL       RA8875_SetFrontColor
00006c  2001              MOVS     r0,#1                 ;1210
00006e  4906              LDR      r1,|L18.136|
000070  7008              STRB     r0,[r1,#0]            ;1210
000072  2180              MOVS     r1,#0x80              ;1211
000074  2090              MOVS     r0,#0x90              ;1211
000076  f7fffffe          BL       RA8875_WriteReg
00007a  f7fffffe          BL       RA8875_WaitBusy
00007e  2000              MOVS     r0,#0                 ;1214
000080  4901              LDR      r1,|L18.136|
000082  7008              STRB     r0,[r1,#0]            ;1214
000084  bf00              NOP      
000086  e7cc              B        |L18.34|
;;;1216   
                          ENDP

                  |L18.136|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_DrawRect||, CODE, READONLY, ALIGN=2

                  RA8875_DrawRect PROC
;;;1228   */
;;;1229   void RA8875_DrawRect(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1230   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;1231   	/*
;;;1232   		RA8875 支持方形绘图功能，让使用者以简易或低速的MCU 就可以在TFT 模块上画方形。先设
;;;1233   	定方形的起始点REG[91h~94h]与结束点REG[95h~98h]，方形的颜色REG[63h~65h]，然后启
;;;1234   	动绘图设定REG[90h] Bit4=1, Bit0=0 且REG[90h] Bit7 = 1，RA8875 就会将方形的图形写入
;;;1235   	DDRAM，相对的在TFT 模块上就可以显示所画的方形。若设定REG[90h] Bit5 = 1，则可画出一
;;;1236   	实心方形 (Fill)
;;;1237   
;;;1238   	 ---------------->---
;;;1239   	|(_usX，_usY)        |
;;;1240   	V                    V  _usHeight
;;;1241   	|                    |
;;;1242   	 ---------------->---
;;;1243   		  _usWidth
;;;1244   	*/
;;;1245   
;;;1246   	/* 设置起点坐标 */
;;;1247   	RA8875_WriteReg(0x91, _usX);
000010  b2e1              UXTB     r1,r4
000012  2091              MOVS     r0,#0x91
000014  f7fffffe          BL       RA8875_WriteReg
;;;1248   	RA8875_WriteReg(0x92, _usX >> 8);
000018  1221              ASRS     r1,r4,#8
00001a  2092              MOVS     r0,#0x92
00001c  f7fffffe          BL       RA8875_WriteReg
;;;1249   	RA8875_WriteReg(0x93, _usY);
000020  b2e9              UXTB     r1,r5
000022  2093              MOVS     r0,#0x93
000024  f7fffffe          BL       RA8875_WriteReg
;;;1250   	RA8875_WriteReg(0x94, _usY >> 8);
000028  1229              ASRS     r1,r5,#8
00002a  2094              MOVS     r0,#0x94
00002c  f7fffffe          BL       RA8875_WriteReg
;;;1251   
;;;1252   	/* 设置终点坐标 */
;;;1253   	RA8875_WriteReg(0x95, _usX + _usWidth - 1);
000030  19e0              ADDS     r0,r4,r7
000032  1e40              SUBS     r0,r0,#1
000034  b2c1              UXTB     r1,r0
000036  2095              MOVS     r0,#0x95
000038  f7fffffe          BL       RA8875_WriteReg
;;;1254   	RA8875_WriteReg(0x96, (_usX + _usWidth - 1) >> 8);
00003c  19e0              ADDS     r0,r4,r7
00003e  1e40              SUBS     r0,r0,#1
000040  f3c02107          UBFX     r1,r0,#8,#8
000044  2096              MOVS     r0,#0x96
000046  f7fffffe          BL       RA8875_WriteReg
;;;1255   	RA8875_WriteReg(0x97, _usY + _usHeight - 1);
00004a  19a8              ADDS     r0,r5,r6
00004c  1e40              SUBS     r0,r0,#1
00004e  b2c1              UXTB     r1,r0
000050  2097              MOVS     r0,#0x97
000052  f7fffffe          BL       RA8875_WriteReg
;;;1256   	RA8875_WriteReg(0x98, (_usY + _usHeight - 1) >> 8);
000056  19a8              ADDS     r0,r5,r6
000058  1e40              SUBS     r0,r0,#1
00005a  f3c02107          UBFX     r1,r0,#8,#8
00005e  2098              MOVS     r0,#0x98
000060  f7fffffe          BL       RA8875_WriteReg
;;;1257   
;;;1258   	RA8875_SetFrontColor(_usColor);	/* 设置颜色 */
000064  4640              MOV      r0,r8
000066  f7fffffe          BL       RA8875_SetFrontColor
;;;1259   
;;;1260   	s_ucRA8875Busy = 1;
00006a  2001              MOVS     r0,#1
00006c  4906              LDR      r1,|L19.136|
00006e  7008              STRB     r0,[r1,#0]
;;;1261   	RA8875_WriteReg(0x90, (1 << 7) | (0 << 5) | (1 << 4) | (0 << 0));	/* 开始画矩形  */
000070  2190              MOVS     r1,#0x90
000072  4608              MOV      r0,r1
000074  f7fffffe          BL       RA8875_WriteReg
;;;1262   //	while (RA8875_ReadReg(0x90) & (1 << 7));							/* 等待结束 */
;;;1263   	RA8875_WaitBusy();
000078  f7fffffe          BL       RA8875_WaitBusy
;;;1264   	s_ucRA8875Busy = 0;
00007c  2000              MOVS     r0,#0
00007e  4902              LDR      r1,|L19.136|
000080  7008              STRB     r0,[r1,#0]
;;;1265   }
000082  e8bd81f0          POP      {r4-r8,pc}
;;;1266   
                          ENDP

000086  0000              DCW      0x0000
                  |L19.136|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_DrawVLine||, CODE, READONLY, ALIGN=2

                  RA8875_DrawVLine PROC
;;;1896   */
;;;1897   void RA8875_DrawVLine(uint16_t _usX1 , uint16_t _usY1 , uint16_t _usY2 , uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1898   {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1899   	uint16_t i;
;;;1900   
;;;1901   	RA8875_SetCursor(_usX1, _usY1);
00000c  4621              MOV      r1,r4
00000e  4640              MOV      r0,r8
000010  f7fffffe          BL       RA8875_SetCursor
;;;1902   
;;;1903   	for (i = 1; i <= _usY2 - _usY1 + 1; i++)
000014  2501              MOVS     r5,#1
000016  e00f              B        |L20.56|
                  |L20.24|
;;;1904   	{
;;;1905   		s_ucRA8875Busy = 1;
000018  2001              MOVS     r0,#1
00001a  490a              LDR      r1,|L20.68|
00001c  7008              STRB     r0,[r1,#0]
;;;1906   
;;;1907   		RA8875_WriteCmd(0x02); 		/* 用于设定RA8875 进入内存(DDRAM或CGRAM)读取/写入模式 */
00001e  2002              MOVS     r0,#2
000020  f7fffffe          BL       RA8875_WriteCmd
;;;1908   		RA8875_WriteData16(_usColor);
000024  4638              MOV      r0,r7
000026  f7fffffe          BL       RA8875_WriteData16
;;;1909   
;;;1910   		RA8875_SetCursor(_usX1, _usY1 + i);
00002a  1960              ADDS     r0,r4,r5
00002c  b281              UXTH     r1,r0
00002e  4640              MOV      r0,r8
000030  f7fffffe          BL       RA8875_SetCursor
000034  1c68              ADDS     r0,r5,#1              ;1903
000036  b285              UXTH     r5,r0                 ;1903
                  |L20.56|
000038  1b30              SUBS     r0,r6,r4              ;1903
00003a  1c40              ADDS     r0,r0,#1              ;1903
00003c  42a8              CMP      r0,r5                 ;1903
00003e  daeb              BGE      |L20.24|
;;;1911   	}
;;;1912   
;;;1913   }
000040  e8bd81f0          POP      {r4-r8,pc}
;;;1914   
                          ENDP

                  |L20.68|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_FillCircle||, CODE, READONLY, ALIGN=2

                  RA8875_FillCircle PROC
;;;1370   */
;;;1371   void RA8875_FillCircle(uint16_t _usX, uint16_t _usY, uint16_t _usRadius, uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1372   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1373   	/*
;;;1374   		RA8875 支持圆形绘图功能，让使用者以简易或低速的MCU 就可以在TFT 模块上画圆。先设定
;;;1375   		圆的中心点REG[99h~9Ch]，圆的半径REG[9Dh]，圆的颜色REG[63h~65h]，然后启动绘图
;;;1376   		REG[90h] Bit6 = 1，RA8875 就会将圆的图形写入DDRAM，相对的在TFT 模块上就可以显示所
;;;1377   		画的圆。若设定REG[90h] Bit5 = 1，则可画出一实心圆 (Fill)；若设定REG[90h] Bit5 = 0，则可
;;;1378   		画出空心圆 (Not Fill
;;;1379   	*/
;;;1380   	/* 设置圆的半径 */
;;;1381   	if (_usRadius > 255)
00000c  2eff              CMP      r6,#0xff
00000e  dd01              BLE      |L21.20|
                  |L21.16|
;;;1382   	{
;;;1383   		return;
;;;1384   	}
;;;1385   
;;;1386   	/* 设置圆心坐标 */
;;;1387   	RA8875_WriteReg(0x99, _usX);
;;;1388   	RA8875_WriteReg(0x9A, _usX >> 8);
;;;1389   	RA8875_WriteReg(0x9B, _usY);
;;;1390   	RA8875_WriteReg(0x9C, _usY >> 8);
;;;1391   
;;;1392   	RA8875_WriteReg(0x9D, _usRadius);	/* 设置圆的半径 */
;;;1393   
;;;1394   	RA8875_SetFrontColor(_usColor);	/* 设置颜色 */
;;;1395   
;;;1396   	s_ucRA8875Busy = 1;
;;;1397   	RA8875_WriteReg(0x90, (1 << 6) | (1 << 5));				/* 开始画圆, 填充  */
;;;1398   //	while (RA8875_ReadReg(0x90) & (1 << 6));				/* 等待结束 */
;;;1399   	RA8875_WaitBusy();
;;;1400   	s_ucRA8875Busy = 0;
;;;1401   }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L21.20|
000014  b2e1              UXTB     r1,r4                 ;1387
000016  2099              MOVS     r0,#0x99              ;1387
000018  f7fffffe          BL       RA8875_WriteReg
00001c  1221              ASRS     r1,r4,#8              ;1388
00001e  209a              MOVS     r0,#0x9a              ;1388
000020  f7fffffe          BL       RA8875_WriteReg
000024  b2e9              UXTB     r1,r5                 ;1389
000026  209b              MOVS     r0,#0x9b              ;1389
000028  f7fffffe          BL       RA8875_WriteReg
00002c  1229              ASRS     r1,r5,#8              ;1390
00002e  209c              MOVS     r0,#0x9c              ;1390
000030  f7fffffe          BL       RA8875_WriteReg
000034  b2f1              UXTB     r1,r6                 ;1392
000036  209d              MOVS     r0,#0x9d              ;1392
000038  f7fffffe          BL       RA8875_WriteReg
00003c  4638              MOV      r0,r7                 ;1394
00003e  f7fffffe          BL       RA8875_SetFrontColor
000042  2001              MOVS     r0,#1                 ;1396
000044  4906              LDR      r1,|L21.96|
000046  7008              STRB     r0,[r1,#0]            ;1396
000048  2160              MOVS     r1,#0x60              ;1397
00004a  2090              MOVS     r0,#0x90              ;1397
00004c  f7fffffe          BL       RA8875_WriteReg
000050  f7fffffe          BL       RA8875_WaitBusy
000054  2000              MOVS     r0,#0                 ;1400
000056  4902              LDR      r1,|L21.96|
000058  7008              STRB     r0,[r1,#0]            ;1400
00005a  bf00              NOP      
00005c  e7d8              B        |L21.16|
;;;1402   
                          ENDP

00005e  0000              DCW      0x0000
                  |L21.96|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_FillRect||, CODE, READONLY, ALIGN=2

                  RA8875_FillRect PROC
;;;1278   */
;;;1279   void RA8875_FillRect(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1280   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;1281   	/*
;;;1282   		RA8875 支持方形绘图功能，让使用者以简易或低速的MCU 就可以在TFT 模块上画方形。先设
;;;1283   	定方形的起始点REG[91h~94h]与结束点REG[95h~98h]，方形的颜色REG[63h~65h]，然后启
;;;1284   	动绘图设定REG[90h] Bit4=1, Bit0=0 且REG[90h] Bit7 = 1，RA8875 就会将方形的图形写入
;;;1285   	DDRAM，相对的在TFT 模块上就可以显示所画的方形。若设定REG[90h] Bit5 = 1，则可画出一
;;;1286   	实心方形 (Fill)
;;;1287   
;;;1288   	 ---------------->---
;;;1289   	|(_usX，_usY)        |
;;;1290   	V                    V  _usHeight
;;;1291   	|                    |
;;;1292   	 ---------------->---
;;;1293   		  _usWidth
;;;1294   	*/
;;;1295   
;;;1296   	/* 设置起点坐标 */
;;;1297   	RA8875_WriteReg(0x91, _usX);
000010  b2e1              UXTB     r1,r4
000012  2091              MOVS     r0,#0x91
000014  f7fffffe          BL       RA8875_WriteReg
;;;1298   	RA8875_WriteReg(0x92, _usX >> 8);
000018  1221              ASRS     r1,r4,#8
00001a  2092              MOVS     r0,#0x92
00001c  f7fffffe          BL       RA8875_WriteReg
;;;1299   	RA8875_WriteReg(0x93, _usY);
000020  b2e9              UXTB     r1,r5
000022  2093              MOVS     r0,#0x93
000024  f7fffffe          BL       RA8875_WriteReg
;;;1300   	RA8875_WriteReg(0x94, _usY >> 8);
000028  1229              ASRS     r1,r5,#8
00002a  2094              MOVS     r0,#0x94
00002c  f7fffffe          BL       RA8875_WriteReg
;;;1301   
;;;1302   	/* 设置终点坐标 */
;;;1303   	RA8875_WriteReg(0x95, _usX + _usWidth - 1);
000030  19e0              ADDS     r0,r4,r7
000032  1e40              SUBS     r0,r0,#1
000034  b2c1              UXTB     r1,r0
000036  2095              MOVS     r0,#0x95
000038  f7fffffe          BL       RA8875_WriteReg
;;;1304   	RA8875_WriteReg(0x96, (_usX + _usWidth - 1) >> 8);
00003c  19e0              ADDS     r0,r4,r7
00003e  1e40              SUBS     r0,r0,#1
000040  f3c02107          UBFX     r1,r0,#8,#8
000044  2096              MOVS     r0,#0x96
000046  f7fffffe          BL       RA8875_WriteReg
;;;1305   	RA8875_WriteReg(0x97, _usY + _usHeight - 1);
00004a  19a8              ADDS     r0,r5,r6
00004c  1e40              SUBS     r0,r0,#1
00004e  b2c1              UXTB     r1,r0
000050  2097              MOVS     r0,#0x97
000052  f7fffffe          BL       RA8875_WriteReg
;;;1306   	RA8875_WriteReg(0x98, (_usY + _usHeight - 1) >> 8);
000056  19a8              ADDS     r0,r5,r6
000058  1e40              SUBS     r0,r0,#1
00005a  f3c02107          UBFX     r1,r0,#8,#8
00005e  2098              MOVS     r0,#0x98
000060  f7fffffe          BL       RA8875_WriteReg
;;;1307   
;;;1308   	RA8875_SetFrontColor(_usColor);	/* 设置颜色 */
000064  4640              MOV      r0,r8
000066  f7fffffe          BL       RA8875_SetFrontColor
;;;1309   
;;;1310   	s_ucRA8875Busy = 1;
00006a  2001              MOVS     r0,#1
00006c  4906              LDR      r1,|L22.136|
00006e  7008              STRB     r0,[r1,#0]
;;;1311   	RA8875_WriteReg(0x90, (1 << 7) | (1 << 5) | (1 << 4) | (0 << 0));	/* 开始填充矩形  */
000070  21b0              MOVS     r1,#0xb0
000072  2090              MOVS     r0,#0x90
000074  f7fffffe          BL       RA8875_WriteReg
;;;1312   //	while (RA8875_ReadReg(0x90) & (1 << 7));							/* 等待结束 */
;;;1313   	RA8875_WaitBusy();
000078  f7fffffe          BL       RA8875_WaitBusy
;;;1314   	s_ucRA8875Busy = 0;
00007c  2000              MOVS     r0,#0
00007e  4902              LDR      r1,|L22.136|
000080  7008              STRB     r0,[r1,#0]
;;;1315   }
000082  e8bd81f0          POP      {r4-r8,pc}
;;;1316   
                          ENDP

000086  0000              DCW      0x0000
                  |L22.136|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_GetDispMemAddr||, CODE, READONLY, ALIGN=1

                  RA8875_GetDispMemAddr PROC
;;;1145   */
;;;1146   uint32_t RA8875_GetDispMemAddr(void)
000000  f04f40c0          MOV      r0,#0x60000000
;;;1147   {
;;;1148   	return RA8875_RAM_ADDR;
;;;1149   }
000004  4770              BX       lr
;;;1150   
                          ENDP


                          AREA ||i.RA8875_GetPixel||, CODE, READONLY, ALIGN=2

                  RA8875_GetPixel PROC
;;;1022   */
;;;1023   uint16_t RA8875_GetPixel(uint16_t _usX, uint16_t _usY)
000000  b570              PUSH     {r4-r6,lr}
;;;1024   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1025   	uint16_t usRGB;
;;;1026   
;;;1027   	RA8875_WriteReg(0x40, (1 << 0));	/* 设置为绘图模式，读取光标不自动加1 */
000006  2101              MOVS     r1,#1
000008  2040              MOVS     r0,#0x40
00000a  f7fffffe          BL       RA8875_WriteReg
;;;1028   
;;;1029   	RA8875_SetReadCursor(_usX, _usY);	/* 设置读取光标位置 */
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       RA8875_SetReadCursor
;;;1030   
;;;1031   	s_ucRA8875Busy = 1;
000016  2001              MOVS     r0,#1
000018  4909              LDR      r1,|L24.64|
00001a  7008              STRB     r0,[r1,#0]
;;;1032   
;;;1033   	RA8875_WriteCmd(0x02);
00001c  2002              MOVS     r0,#2
00001e  f7fffffe          BL       RA8875_WriteCmd
;;;1034   	usRGB = RA8875_ReadData16();	/* 第1次读取数据丢弃 */
000022  f7fffffe          BL       RA8875_ReadData16
000026  4606              MOV      r6,r0
;;;1035   	usRGB = RA8875_ReadData16();
000028  f7fffffe          BL       RA8875_ReadData16
00002c  4606              MOV      r6,r0
;;;1036   	usRGB = RA8875_ReadData16();
00002e  f7fffffe          BL       RA8875_ReadData16
000032  4606              MOV      r6,r0
;;;1037   
;;;1038   	s_ucRA8875Busy = 0;
000034  2000              MOVS     r0,#0
000036  4902              LDR      r1,|L24.64|
000038  7008              STRB     r0,[r1,#0]
;;;1039   
;;;1040   	return usRGB;
00003a  4630              MOV      r0,r6
;;;1041   }
00003c  bd70              POP      {r4-r6,pc}
;;;1042   
                          ENDP

00003e  0000              DCW      0x0000
                  |L24.64|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_InitHard||, CODE, READONLY, ALIGN=2

                  RA8875_InitHard PROC
;;;316    */
;;;317    void RA8875_InitHard(void)
000000  b510              PUSH     {r4,lr}
;;;318    {
;;;319    
;;;320    	/* 读取 RA8875 芯片额GPIX引脚的电平状态；1表示4.3寸屏；0表示7寸屏
;;;321    	【备注】这是安富莱电子为了便于统一测试例程，在LCD模块上做的硬件标识。在做产品时，不必自动识别。
;;;322    	*/
;;;323    	g_ucGPIX = RA8875_ReadReg(0xC7);
000002  20c7              MOVS     r0,#0xc7
000004  f7fffffe          BL       RA8875_ReadReg
000008  4965              LDR      r1,|L25.416|
00000a  7008              STRB     r0,[r1,#0]
;;;324    
;;;325    	if (g_ucGPIX == 1)	/* 	GPIX = 1 表示 4.3 寸屏 480x272 */
00000c  4608              MOV      r0,r1
00000e  7800              LDRB     r0,[r0,#0]  ; g_ucGPIX
000010  2801              CMP      r0,#1
000012  d156              BNE      |L25.194|
;;;326    	{
;;;327    		/* 初始化PLL.  晶振频率为25M */
;;;328    		RA8875_WriteCmd(0x88);
000014  2088              MOVS     r0,#0x88
000016  f7fffffe          BL       RA8875_WriteCmd
;;;329    		RA8875_Delaly1us();		/* 延迟1us */
00001a  f7fffffe          BL       RA8875_Delaly1us
;;;330    		RA8875_WriteData(10);	/* PLLDIVM [7] = 0 ;  PLLDIVN [4:0] = 10 */
00001e  200a              MOVS     r0,#0xa
000020  f7fffffe          BL       RA8875_WriteData
;;;331    
;;;332    	    RA8875_Delaly1ms();
000024  f7fffffe          BL       RA8875_Delaly1ms
;;;333    
;;;334    		RA8875_WriteCmd(0x89);
000028  2089              MOVS     r0,#0x89
00002a  f7fffffe          BL       RA8875_WriteCmd
;;;335    		RA8875_Delaly1us();		/* 延迟1us */
00002e  f7fffffe          BL       RA8875_Delaly1us
;;;336    		RA8875_WriteData(2);		/* PLLDIVK[2:0] = 2, 除以4 */
000032  2002              MOVS     r0,#2
000034  f7fffffe          BL       RA8875_WriteData
;;;337    
;;;338    		/* RA8875 的内部系统频率 (SYS_CLK) 是结合振荡电路及PLL 电路所产生，频率计算公式如下 :
;;;339    		  SYS_CLK = FIN * ( PLLDIVN [4:0] +1 ) / ((PLLDIVM+1 ) * ( 2^PLLDIVK [2:0] ))
;;;340    		          = 25M * (10 + 1) / ((0 + 1) * (2 ^ 2))
;;;341    				  = 68.75MHz
;;;342    		*/
;;;343    
;;;344    		/* REG[88h]或REG[89h]被设定后，为保证PLL 输出稳定，须等待一段「锁频时间」(< 100us)。*/
;;;345    	    RA8875_Delaly1ms();
000038  f7fffffe          BL       RA8875_Delaly1ms
;;;346    
;;;347    		/*
;;;348    			配置系统控制寄存器。 中文pdf 第18页:
;;;349    
;;;350    			bit3:2 色彩深度设定 (Color Depth Setting)
;;;351    				00b : 8-bpp 的通用TFT 接口， i.e. 256 色。
;;;352    				1xb : 16-bpp 的通用TFT 接口， i.e. 65K 色。	 【选这个】
;;;353    
;;;354    			bit1:0 MCUIF 选择
;;;355    				00b : 8-位MCU 接口。
;;;356    				1xb : 16-位MCU 接口。 【选这个】
;;;357    		*/
;;;358    		#ifdef IF_SPI_EN
;;;359    			RA8875_WriteReg(0x10, (1 <<3 ) | (0 << 1));	/* SPI接口时，配置8位，65K色 */
;;;360    		#else
;;;361    			RA8875_WriteReg(0x10, (1 <<3 ) | (1 << 1));	/* 配置16位MCU并口，65K色 */
00003c  210a              MOVS     r1,#0xa
00003e  2010              MOVS     r0,#0x10
000040  f7fffffe          BL       RA8875_WriteReg
;;;362    		#endif
;;;363    
;;;364    		/* REG[04h] Pixel Clock Setting Register   PCSR
;;;365    			bit7  PCLK Inversion
;;;366    				0 : PDAT 是在PCLK 正缘上升 (Rising Edge) 时被取样。
;;;367    				1 : PDAT 是在PCLK 负缘下降 (Falling Edge) 时被取样。
;;;368    			bit1:0 PCLK 频率周期设定
;;;369    				Pixel Clock  PCLK 频率周期设定。
;;;370    				00b: PCLK 频率周期= 系统频率周期。
;;;371    				01b: PCLK 频率周期= 2 倍的系统频率周期。
;;;372    				10b: PCLK 频率周期= 4 倍的系统频率周期。
;;;373    				11b: PCLK 频率周期= 8 倍的系统频率周期。
;;;374    		*/
;;;375    	    RA8875_WriteReg(0x04, 0x82);    /* 设置PCLK反相 */
000044  2182              MOVS     r1,#0x82
000046  2004              MOVS     r0,#4
000048  f7fffffe          BL       RA8875_WriteReg
;;;376    	    RA8875_Delaly1ms();
00004c  f7fffffe          BL       RA8875_Delaly1ms
;;;377    
;;;378    	    //Horizontal set
;;;379    	    //HDWR//Horizontal Display Width Setting Bit[6:0]
;;;380    	 	//Horizontal display width(pixels) = (HDWR + 1)*8
;;;381    	    RA8875_WriteReg(0x14, 0x3B);
000050  213b              MOVS     r1,#0x3b
000052  2014              MOVS     r0,#0x14
000054  f7fffffe          BL       RA8875_WriteReg
;;;382    	    RA8875_WriteReg(0x15, 0x00);
000058  2100              MOVS     r1,#0
00005a  2015              MOVS     r0,#0x15
00005c  f7fffffe          BL       RA8875_WriteReg
;;;383    
;;;384    	    //HNDR//Horizontal Non-Display Period Bit[4:0]
;;;385    	    //Horizontal Non-Display Period (pixels) = (HNDR + 1)*8
;;;386    		RA8875_WriteReg(0x16, 0x01);
000060  2101              MOVS     r1,#1
000062  2016              MOVS     r0,#0x16
000064  f7fffffe          BL       RA8875_WriteReg
;;;387    
;;;388    	    //HSTR//HSYNC Start Position[4:0]
;;;389    	    //HSYNC Start Position(PCLK) = (HSTR + 1)*8
;;;390    		RA8875_WriteReg(0x17, 0x00);
000068  2100              MOVS     r1,#0
00006a  2017              MOVS     r0,#0x17
00006c  f7fffffe          BL       RA8875_WriteReg
;;;391    
;;;392    	    //HPWR//HSYNC Polarity ,The period width of HSYNC.
;;;393    	    //HSYNC Width [4:0]   HSYNC Pulse width(PCLK) = (HPWR + 1)*8
;;;394    		RA8875_WriteReg(0x18, 0x05);
000070  2105              MOVS     r1,#5
000072  2018              MOVS     r0,#0x18
000074  f7fffffe          BL       RA8875_WriteReg
;;;395    
;;;396    	    //Vertical set
;;;397    	    //VDHR0 //Vertical Display Height Bit [7:0]
;;;398    	    //Vertical pixels = VDHR + 1
;;;399    		RA8875_WriteReg(0x19, 0x0F);
000078  210f              MOVS     r1,#0xf
00007a  2019              MOVS     r0,#0x19
00007c  f7fffffe          BL       RA8875_WriteReg
;;;400    
;;;401    	    //VDHR1 //Vertical Display Height Bit [8]
;;;402    	    //Vertical pixels = VDHR + 1
;;;403    		RA8875_WriteReg(0x1A, 0x01);
000080  2101              MOVS     r1,#1
000082  201a              MOVS     r0,#0x1a
000084  f7fffffe          BL       RA8875_WriteReg
;;;404    
;;;405    	    //VNDR0 //Vertical Non-Display Period Bit [7:0]
;;;406    	    //Vertical Non-Display area = (VNDR + 1)
;;;407    		RA8875_WriteReg(0x1B, 0x02);
000088  2102              MOVS     r1,#2
00008a  201b              MOVS     r0,#0x1b
00008c  f7fffffe          BL       RA8875_WriteReg
;;;408    
;;;409    	    //VNDR1 //Vertical Non-Display Period Bit [8]
;;;410    	    //Vertical Non-Display area = (VNDR + 1)
;;;411    		RA8875_WriteReg(0x1C, 0x00);
000090  2100              MOVS     r1,#0
000092  201c              MOVS     r0,#0x1c
000094  f7fffffe          BL       RA8875_WriteReg
;;;412    
;;;413    	    //VSTR0 //VSYNC Start Position[7:0]
;;;414    	    //VSYNC Start Position(PCLK) = (VSTR + 1)
;;;415    		RA8875_WriteReg(0x1D, 0x07);
000098  2107              MOVS     r1,#7
00009a  201d              MOVS     r0,#0x1d
00009c  f7fffffe          BL       RA8875_WriteReg
;;;416    
;;;417    	    //VSTR1 //VSYNC Start Position[8]
;;;418    	    //VSYNC Start Position(PCLK) = (VSTR + 1)
;;;419    		RA8875_WriteReg(0x1E, 0x00);
0000a0  2100              MOVS     r1,#0
0000a2  201e              MOVS     r0,#0x1e
0000a4  f7fffffe          BL       RA8875_WriteReg
;;;420    
;;;421    	    //VPWR //VSYNC Polarity ,VSYNC Pulse Width[6:0]
;;;422    	    //VSYNC Pulse Width(PCLK) = (VPWR + 1)
;;;423    	    RA8875_WriteReg(0x1F, 0x09);
0000a8  2109              MOVS     r1,#9
0000aa  201f              MOVS     r0,#0x1f
0000ac  f7fffffe          BL       RA8875_WriteReg
;;;424    
;;;425    
;;;426    	    g_LcdHeight = LCD_43_HEIGHT;
0000b0  f44f7088          MOV      r0,#0x110
0000b4  493b              LDR      r1,|L25.420|
0000b6  8008              STRH     r0,[r1,#0]
;;;427    		g_LcdWidth = LCD_43_WIDTH;
0000b8  f44f70f0          MOV      r0,#0x1e0
0000bc  493a              LDR      r1,|L25.424|
0000be  8008              STRH     r0,[r1,#0]
0000c0  e055              B        |L25.366|
                  |L25.194|
;;;428    	}
;;;429    	else	/* GPIX = 0 表示7寸屏(800x480) */
;;;430    	{
;;;431    	    g_LcdHeight = LCD_70_HEIGHT;
0000c2  f44f70f0          MOV      r0,#0x1e0
0000c6  4937              LDR      r1,|L25.420|
0000c8  8008              STRH     r0,[r1,#0]
;;;432    		g_LcdWidth = LCD_70_WIDTH;
0000ca  f44f7048          MOV      r0,#0x320
0000ce  4936              LDR      r1,|L25.424|
0000d0  8008              STRH     r0,[r1,#0]
;;;433    
;;;434    		/* 初始化PLL.  晶振频率为25M */
;;;435    		RA8875_WriteCmd(0x88);
0000d2  2088              MOVS     r0,#0x88
0000d4  f7fffffe          BL       RA8875_WriteCmd
;;;436    		RA8875_Delaly1us();		/* 延迟1us */
0000d8  f7fffffe          BL       RA8875_Delaly1us
;;;437    		RA8875_WriteData(12);	/* PLLDIVM [7] = 0 ;  PLLDIVN [4:0] = 10 */
0000dc  200c              MOVS     r0,#0xc
0000de  f7fffffe          BL       RA8875_WriteData
;;;438    
;;;439    	    RA8875_Delaly1ms();
0000e2  f7fffffe          BL       RA8875_Delaly1ms
;;;440    
;;;441    		RA8875_WriteCmd(0x89);
0000e6  2089              MOVS     r0,#0x89
0000e8  f7fffffe          BL       RA8875_WriteCmd
;;;442    		RA8875_Delaly1us();		/* 延迟1us */
0000ec  f7fffffe          BL       RA8875_Delaly1us
;;;443    		RA8875_WriteData(2);	/* PLLDIVK[2:0] = 2, 除以4 */
0000f0  2002              MOVS     r0,#2
0000f2  f7fffffe          BL       RA8875_WriteData
;;;444    
;;;445    		/* RA8875 的内部系统频率 (SYS_CLK) 是结合振荡电路及PLL 电路所产生，频率计算公式如下 :
;;;446    		  SYS_CLK = FIN * ( PLLDIVN [4:0] +1 ) / ((PLLDIVM+1 ) * ( 2^PLLDIVK [2:0] ))
;;;447    		          = 25M * (12 + 1) / ((0 + 1) * (2 ^ 2))
;;;448    				  = 81.25MHz
;;;449    		*/
;;;450    
;;;451    		/* REG[88h]或REG[89h]被设定后，为保证PLL 输出稳定，须等待一段「锁频时间」(< 100us)。*/
;;;452    	    RA8875_Delaly1ms();
0000f6  f7fffffe          BL       RA8875_Delaly1ms
;;;453    
;;;454    		/*
;;;455    			配置系统控制寄存器。 中文pdf 第18页:
;;;456    
;;;457    			bit3:2 色彩深度设定 (Color Depth Setting)
;;;458    				00b : 8-bpp 的通用TFT 接口， i.e. 256 色。
;;;459    				1xb : 16-bpp 的通用TFT 接口， i.e. 65K 色。	 【选这个】
;;;460    
;;;461    			bit1:0 MCUIF 选择
;;;462    				00b : 8-位MCU 接口。
;;;463    				1xb : 16-位MCU 接口。 【选这个】
;;;464    		*/
;;;465    		#ifdef IF_SPI_EN
;;;466    			RA8875_WriteReg(0x10, (1 <<3 ) | (0 << 1));	/* SPI接口时，配置8位，65K色 */
;;;467    		#else
;;;468    			RA8875_WriteReg(0x10, (1 <<3 ) | (1 << 1));	/* 配置16位MCU并口，65K色 */
0000fa  210a              MOVS     r1,#0xa
0000fc  2010              MOVS     r0,#0x10
0000fe  f7fffffe          BL       RA8875_WriteReg
;;;469    		#endif
;;;470    
;;;471    		/* REG[04h] Pixel Clock Setting Register (PCSR)
;;;472    			bit7  PCLK Inversion
;;;473    				0 : PDAT 是在PCLK 正缘上升 (Rising Edge) 时被取样。
;;;474    				1 : PDAT 是在PCLK 负缘下降 (Falling Edge) 时被取样。
;;;475    			bit1:0 PCLK 频率周期设定
;;;476    				Pixel Clock ,PCLK 频率周期设定。
;;;477    				00b: PCLK 频率周期= 系统频率周期。
;;;478    				01b: PCLK 频率周期= 2 倍的系统频率周期。
;;;479    				10b: PCLK 频率周期= 4 倍的系统频率周期。
;;;480    				11b: PCLK 频率周期= 8 倍的系统频率周期。
;;;481    		*/
;;;482    	    RA8875_WriteReg(0x04, 0x81);
000102  2181              MOVS     r1,#0x81
000104  2004              MOVS     r0,#4
000106  f7fffffe          BL       RA8875_WriteReg
;;;483    	    RA8875_Delaly1ms();
00010a  f7fffffe          BL       RA8875_Delaly1ms
;;;484    
;;;485    	#if 1
;;;486    		/* OTD9960 & OTA7001 设置 */
;;;487    		RA8875_WriteReg(0x14, 0x63);
00010e  2163              MOVS     r1,#0x63
000110  2014              MOVS     r0,#0x14
000112  f7fffffe          BL       RA8875_WriteReg
;;;488    		RA8875_WriteReg(0x15, 0x00);
000116  2100              MOVS     r1,#0
000118  2015              MOVS     r0,#0x15
00011a  f7fffffe          BL       RA8875_WriteReg
;;;489    		RA8875_WriteReg(0x16, 0x03);
00011e  2103              MOVS     r1,#3
000120  2016              MOVS     r0,#0x16
000122  f7fffffe          BL       RA8875_WriteReg
;;;490    		RA8875_WriteReg(0x17, 0x03);
000126  2103              MOVS     r1,#3
000128  2017              MOVS     r0,#0x17
00012a  f7fffffe          BL       RA8875_WriteReg
;;;491    		RA8875_WriteReg(0x18, 0x0B);
00012e  210b              MOVS     r1,#0xb
000130  2018              MOVS     r0,#0x18
000132  f7fffffe          BL       RA8875_WriteReg
;;;492    		RA8875_WriteReg(0x19, 0xDF);
000136  21df              MOVS     r1,#0xdf
000138  2019              MOVS     r0,#0x19
00013a  f7fffffe          BL       RA8875_WriteReg
;;;493    		RA8875_WriteReg(0x1A, 0x01);
00013e  2101              MOVS     r1,#1
000140  201a              MOVS     r0,#0x1a
000142  f7fffffe          BL       RA8875_WriteReg
;;;494    		RA8875_WriteReg(0x1B, 0x1F);
000146  211f              MOVS     r1,#0x1f
000148  201b              MOVS     r0,#0x1b
00014a  f7fffffe          BL       RA8875_WriteReg
;;;495    		RA8875_WriteReg(0x1C, 0x00);
00014e  2100              MOVS     r1,#0
000150  201c              MOVS     r0,#0x1c
000152  f7fffffe          BL       RA8875_WriteReg
;;;496    		RA8875_WriteReg(0x1D, 0x16);
000156  2116              MOVS     r1,#0x16
000158  201d              MOVS     r0,#0x1d
00015a  f7fffffe          BL       RA8875_WriteReg
;;;497    		RA8875_WriteReg(0x1E, 0x00);
00015e  2100              MOVS     r1,#0
000160  201e              MOVS     r0,#0x1e
000162  f7fffffe          BL       RA8875_WriteReg
;;;498    		RA8875_WriteReg(0x1F, 0x01);
000166  2101              MOVS     r1,#1
000168  201f              MOVS     r0,#0x1f
00016a  f7fffffe          BL       RA8875_WriteReg
                  |L25.366|
;;;499    
;;;500    	#else	/* AT070TN92  setting */
;;;501    	    //Horizontal set
;;;502    	    //HDWR//Horizontal Display Width Setting Bit[6:0]
;;;503    	 	//Horizontal display width(pixels) = (HDWR + 1)*8
;;;504    	    RA8875_WriteReg(0x14, 0x4F);
;;;505    	    RA8875_WriteReg(0x15, 0x05);
;;;506    
;;;507    	    //HNDR//Horizontal Non-Display Period Bit[4:0]
;;;508    	    //Horizontal Non-Display Period (pixels) = (HNDR + 1)*8
;;;509    		RA8875_WriteReg(0x16, 0x0F);
;;;510    
;;;511    	    //HSTR//HSYNC Start Position[4:0]
;;;512    	    //HSYNC Start Position(PCLK) = (HSTR + 1)*8
;;;513    		RA8875_WriteReg(0x17, 0x01);
;;;514    
;;;515    	    //HPWR//HSYNC Polarity ,The period width of HSYNC.
;;;516    	    //HSYNC Width [4:0]   HSYNC Pulse width(PCLK) = (HPWR + 1)*8
;;;517    		RA8875_WriteReg(0x18, 0x00);
;;;518    
;;;519    	    //Vertical set
;;;520    	    //VDHR0 //Vertical Display Height Bit [7:0]
;;;521    	    //Vertical pixels = VDHR + 1
;;;522    		RA8875_WriteReg(0x19, 0xDF);
;;;523    
;;;524    	    //VDHR1 //Vertical Display Height Bit [8]
;;;525    	    //Vertical pixels = VDHR + 1
;;;526    		RA8875_WriteReg(0x1A, 0x01);
;;;527    
;;;528    	    //VNDR0 //Vertical Non-Display Period Bit [7:0]
;;;529    	    //Vertical Non-Display area = (VNDR + 1)
;;;530    		RA8875_WriteReg(0x1B, 0x0A);
;;;531    
;;;532    	    //VNDR1 //Vertical Non-Display Period Bit [8]
;;;533    	    //Vertical Non-Display area = (VNDR + 1)
;;;534    		RA8875_WriteReg(0x1C, 0x00);
;;;535    
;;;536    	    //VSTR0 //VSYNC Start Position[7:0]
;;;537    	    //VSYNC Start Position(PCLK) = (VSTR + 1)
;;;538    		RA8875_WriteReg(0x1D, 0x0E);
;;;539    
;;;540    	    //VSTR1 //VSYNC Start Position[8]
;;;541    	    //VSYNC Start Position(PCLK) = (VSTR + 1)
;;;542    		RA8875_WriteReg(0x1E, 0x00);
;;;543    
;;;544    	    //VPWR //VSYNC Polarity ,VSYNC Pulse Width[6:0]
;;;545    	    //VSYNC Pulse Width(PCLK) = (VPWR + 1)
;;;546    	    RA8875_WriteReg(0x1F, 0x01);
;;;547    	#endif
;;;548    	}
;;;549    
;;;550    	/* 设置TFT面板的 DISP  引脚为高，使能面板. 安富莱TFT模块的DISP引脚连接到RA8875芯片的GP0X脚 */
;;;551    	RA8875_WriteReg(0xC7, 0x01);	/* DISP = 1 */
00016e  2101              MOVS     r1,#1
000170  20c7              MOVS     r0,#0xc7
000172  f7fffffe          BL       RA8875_WriteReg
;;;552    
;;;553    	/* LCD 显示/关闭讯号 (LCD Display on) */
;;;554    	RA8875_WriteReg(0x01, 0x80);
000176  2180              MOVS     r1,#0x80
000178  2001              MOVS     r0,#1
00017a  f7fffffe          BL       RA8875_WriteReg
;;;555    
;;;556    	/* 	REG[40h] Memory Write Control Register 0 (MWCR0)
;;;557    
;;;558    		Bit 7	显示模式设定
;;;559    			0 : 绘图模式。
;;;560    			1 : 文字模式。
;;;561    
;;;562    		Bit 6	文字写入光标/内存写入光标设定
;;;563    			0 : 设定文字/内存写入光标为不显示。
;;;564    			1 : 设定文字/内存写入光标为显示。
;;;565    
;;;566    		Bit 5	文字写入光标/内存写入光标闪烁设定
;;;567    			0 : 游标不闪烁。
;;;568    			1 : 游标闪烁。
;;;569    
;;;570    		Bit 4   NA
;;;571    
;;;572    		Bit 3-2  绘图模式时的内存写入方向
;;;573    			00b : 左 -> 右，然后上 -> 下。
;;;574    			01b : 右 -> 左，然后上 -> 下。
;;;575    			10b : 上 -> 下，然后左 -> 右。
;;;576    			11b : 下 -> 上，然后左 -> 右。
;;;577    
;;;578    		Bit 1 	内存写入光标自动增加功能设定
;;;579    			0 : 当内存写入时光标位置自动加一。
;;;580    			1 : 当内存写入时光标位置不会自动加一。
;;;581    
;;;582    		Bit 0 内存读取光标自动增加功能设定
;;;583    			0 : 当内存读取时光标位置自动加一。
;;;584    			1 : 当内存读取时光标位置不会自动加一。
;;;585    	*/
;;;586    	RA8875_WriteReg(0x40, 0x00);	/* 选择绘图模式 */
00017e  2100              MOVS     r1,#0
000180  2040              MOVS     r0,#0x40
000182  f7fffffe          BL       RA8875_WriteReg
;;;587    
;;;588    
;;;589    	/* 	REG[41h] Memory Write Control Register1 (MWCR1)
;;;590    		写入目的位置，选择图层1
;;;591    	*/
;;;592    	RA8875_WriteReg(0x41, 0x00);	/* 选择绘图模式, 目的为CGRAM */
000186  2100              MOVS     r1,#0
000188  2041              MOVS     r0,#0x41
00018a  f7fffffe          BL       RA8875_WriteReg
;;;593    
;;;594    	RA8875_SetDispWin(0, 0, g_LcdHeight, g_LcdWidth);
00018e  4806              LDR      r0,|L25.424|
000190  8803              LDRH     r3,[r0,#0]  ; g_LcdWidth
000192  4804              LDR      r0,|L25.420|
000194  8802              LDRH     r2,[r0,#0]  ; g_LcdHeight
000196  2100              MOVS     r1,#0
000198  4608              MOV      r0,r1
00019a  f7fffffe          BL       RA8875_SetDispWin
;;;595    
;;;596    #ifdef IF_SPI_EN
;;;597    	RA8875_HighSpeedSPI();		/* 配置完毕后，切换SPI到高速模式 */
;;;598    #endif
;;;599    }
00019e  bd10              POP      {r4,pc}
;;;600    
                          ENDP

                  |L25.416|
                          DCD      g_ucGPIX
                  |L25.420|
                          DCD      g_LcdHeight
                  |L25.424|
                          DCD      g_LcdWidth

                          AREA ||i.RA8875_IsBusy||, CODE, READONLY, ALIGN=2

                  RA8875_IsBusy PROC
;;;725    */
;;;726    uint8_t RA8875_IsBusy(void)
000000  4803              LDR      r0,|L26.16|
;;;727    {
;;;728    	if (s_ucRA8875Busy == 0)
000002  7800              LDRB     r0,[r0,#0]  ; s_ucRA8875Busy
000004  b908              CBNZ     r0,|L26.10|
;;;729    	{
;;;730    		return 0;
000006  2000              MOVS     r0,#0
                  |L26.8|
;;;731    	}
;;;732    	return 1;
;;;733    }
000008  4770              BX       lr
                  |L26.10|
00000a  2001              MOVS     r0,#1                 ;732
00000c  e7fc              B        |L26.8|
;;;734    
                          ENDP

00000e  0000              DCW      0x0000
                  |L26.16|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_Layer1Visable||, CODE, READONLY, ALIGN=1

                  RA8875_Layer1Visable PROC
;;;755    */
;;;756    void RA8875_Layer1Visable(void)
000000  b510              PUSH     {r4,lr}
;;;757    {
;;;758    	/* 0x52 寄存器的 Bit2:0
;;;759    		图层显示模式
;;;760    		000b : 只有图层1 显示。
;;;761    		001b : 只有图层2 显示。
;;;762    		010b : 显示图层1 与图层2 的渐进/渐出模式。
;;;763    		011b : 显示图层1 与图层2 的通透模式。
;;;764    		100b : Boolean OR。
;;;765    		101b : Boolean AND。
;;;766    		110b : 浮动窗口模式 (Floating window mode)。
;;;767    		111b :保留。
;;;768    	*/
;;;769    	RA8875_WriteReg(0x52, RA8875_ReadReg(0x52) & 0xF8);	/* 只有图层1 显示 */
000002  2052              MOVS     r0,#0x52
000004  f7fffffe          BL       RA8875_ReadReg
000008  f00004f8          AND      r4,r0,#0xf8
00000c  4621              MOV      r1,r4
00000e  2052              MOVS     r0,#0x52
000010  f7fffffe          BL       RA8875_WriteReg
;;;770    }
000014  bd10              POP      {r4,pc}
;;;771    
                          ENDP


                          AREA ||i.RA8875_Layer2Visable||, CODE, READONLY, ALIGN=1

                  RA8875_Layer2Visable PROC
;;;779    */
;;;780    void RA8875_Layer2Visable(void)
000000  b510              PUSH     {r4,lr}
;;;781    {
;;;782    	/* 0x52 寄存器的 Bit2:0
;;;783    		图层显示模式
;;;784    		000b : 只有图层1 显示。
;;;785    		001b : 只有图层2 显示。
;;;786    		010b : 显示图层1 与图层2 的渐进/渐出模式。
;;;787    		011b : 显示图层1 与图层2 的通透模式。
;;;788    		100b : Boolean OR。
;;;789    		101b : Boolean AND。
;;;790    		110b : 浮动窗口模式 (Floating window mode)。
;;;791    		111b :保留。
;;;792    	*/
;;;793    	RA8875_WriteReg(0x52, (RA8875_ReadReg(0x52) & 0xF8) | 0x01);	/* 只有图层2 显示 */
000002  2052              MOVS     r0,#0x52
000004  f7fffffe          BL       RA8875_ReadReg
000008  f00000f8          AND      r0,r0,#0xf8
00000c  1c44              ADDS     r4,r0,#1
00000e  4621              MOV      r1,r4
000010  2052              MOVS     r0,#0x52
000012  f7fffffe          BL       RA8875_WriteReg
;;;794    }
000016  bd10              POP      {r4,pc}
;;;795    
                          ENDP


                          AREA ||i.RA8875_PutPixel||, CODE, READONLY, ALIGN=2

                  RA8875_PutPixel PROC
;;;996    */
;;;997    void RA8875_PutPixel(uint16_t _usX, uint16_t _usY, uint16_t _usColor)
000000  b570              PUSH     {r4-r6,lr}
;;;998    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;999    	/* 展开 	RA8875_SetCursor(_usX, _usY); 函数 */
;;;1000   	s_ucRA8875Busy = 1;
000008  2001              MOVS     r0,#1
00000a  4912              LDR      r1,|L29.84|
00000c  7008              STRB     r0,[r1,#0]
;;;1001   
;;;1002   	RA8875_WriteCmd(0x46); RA8875_WriteData(_usX);
00000e  2046              MOVS     r0,#0x46
000010  f7fffffe          BL       RA8875_WriteCmd
000014  b2e0              UXTB     r0,r4
000016  f7fffffe          BL       RA8875_WriteData
;;;1003   	RA8875_WriteCmd(0x47); RA8875_WriteData(_usX >> 8);
00001a  2047              MOVS     r0,#0x47
00001c  f7fffffe          BL       RA8875_WriteCmd
000020  1220              ASRS     r0,r4,#8
000022  f7fffffe          BL       RA8875_WriteData
;;;1004   	RA8875_WriteCmd(0x48); RA8875_WriteData(_usY);
000026  2048              MOVS     r0,#0x48
000028  f7fffffe          BL       RA8875_WriteCmd
00002c  b2e8              UXTB     r0,r5
00002e  f7fffffe          BL       RA8875_WriteData
;;;1005   	RA8875_WriteCmd(0x49); RA8875_WriteData(_usY >> 8);
000032  2049              MOVS     r0,#0x49
000034  f7fffffe          BL       RA8875_WriteCmd
000038  1228              ASRS     r0,r5,#8
00003a  f7fffffe          BL       RA8875_WriteData
;;;1006   
;;;1007   	RA8875_WriteCmd(0x02); 		/* 用于设定RA8875 进入内存(DDRAM或CGRAM)读取/写入模式 */
00003e  2002              MOVS     r0,#2
000040  f7fffffe          BL       RA8875_WriteCmd
;;;1008   	RA8875_WriteData16(_usColor);
000044  4630              MOV      r0,r6
000046  f7fffffe          BL       RA8875_WriteData16
;;;1009   
;;;1010   	s_ucRA8875Busy = 0;
00004a  2000              MOVS     r0,#0
00004c  4901              LDR      r1,|L29.84|
00004e  7008              STRB     r0,[r1,#0]
;;;1011   }
000050  bd70              POP      {r4-r6,pc}
;;;1012   
                          ENDP

000052  0000              DCW      0x0000
                  |L29.84|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_QuitDirectDraw||, CODE, READONLY, ALIGN=2

                  RA8875_QuitDirectDraw PROC
;;;1161   */
;;;1162   void RA8875_QuitDirectDraw(void)
000000  b510              PUSH     {r4,lr}
;;;1163   {
;;;1164   	s_ucRA8875Busy = 0;
000002  2000              MOVS     r0,#0
000004  4902              LDR      r1,|L30.16|
000006  7008              STRB     r0,[r1,#0]
;;;1165   
;;;1166   	/* 退出窗口绘图模式 */
;;;1167   	RA8875_QuitWinMode();
000008  f7fffffe          BL       RA8875_QuitWinMode
;;;1168   }
00000c  bd10              POP      {r4,pc}
;;;1169   
                          ENDP

00000e  0000              DCW      0x0000
                  |L30.16|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_QuitWinMode||, CODE, READONLY, ALIGN=2

                  RA8875_QuitWinMode PROC
;;;1740   */
;;;1741   void RA8875_QuitWinMode(void)
000000  b510              PUSH     {r4,lr}
;;;1742   {
;;;1743   	RA8875_SetDispWin(0, 0, g_LcdHeight, g_LcdWidth);
000002  4804              LDR      r0,|L31.20|
000004  8803              LDRH     r3,[r0,#0]  ; g_LcdWidth
000006  4804              LDR      r0,|L31.24|
000008  8802              LDRH     r2,[r0,#0]  ; g_LcdHeight
00000a  2100              MOVS     r1,#0
00000c  4608              MOV      r0,r1
00000e  f7fffffe          BL       RA8875_SetDispWin
;;;1744   }
000012  bd10              POP      {r4,pc}
;;;1745   
                          ENDP

                  |L31.20|
                          DCD      g_LcdWidth
                  |L31.24|
                          DCD      g_LcdHeight

                          AREA ||i.RA8875_ReadData||, CODE, READONLY, ALIGN=1

                  RA8875_ReadData PROC
;;;142    */
;;;143    uint8_t RA8875_ReadData(uint8_t _ucRegAddr)
000000  4601              MOV      r1,r0
;;;144    {
;;;145    #ifdef IF_SPI_EN	/* 四线SPI */
;;;146    	uint16_t value;
;;;147    
;;;148    	RA8875_CS_0();
;;;149    	SPI_ShiftByte(SPI_READ_DATA);
;;;150    	value = SPI_ShiftByte(0x00);
;;;151    	RA8875_CS_1();
;;;152    
;;;153    	return value;
;;;154    #else	/* 8080 总线 */
;;;155    	uint8_t value;
;;;156    
;;;157    	value = RA8875_RAM;		/* 读取寄存器值 */
000002  f04f42c0          MOV      r2,#0x60000000
000006  8812              LDRH     r2,[r2,#0]
000008  b2d0              UXTB     r0,r2
;;;158    
;;;159    	return value;
;;;160    #endif
;;;161    }
00000a  4770              BX       lr
;;;162    
                          ENDP


                          AREA ||i.RA8875_ReadData16||, CODE, READONLY, ALIGN=1

                  RA8875_ReadData16 PROC
;;;196    */
;;;197    static uint16_t RA8875_ReadData16(void)
000000  f04f41c0          MOV      r1,#0x60000000
;;;198    {
;;;199    #ifdef IF_SPI_EN	/* 四线SPI */
;;;200    	uint16_t value;
;;;201    
;;;202    	RA8875_CS_0();
;;;203    	SPI_ShiftByte(SPI_READ_DATA);
;;;204    	value = SPI_ShiftByte(0x00);
;;;205    	RA8875_CS_1();
;;;206    
;;;207    	return value;
;;;208    #else	/* 8080 总线 */
;;;209    	uint16_t value;
;;;210    
;;;211    	value = RA8875_RAM;		/* 读取寄存器值 */
000004  8808              LDRH     r0,[r1,#0]
;;;212    
;;;213    	return value;
;;;214    #endif
;;;215    }
000006  4770              BX       lr
;;;216    
                          ENDP


                          AREA ||i.RA8875_ReadID||, CODE, READONLY, ALIGN=1

                  RA8875_ReadID PROC
;;;87     */
;;;88     uint16_t RA8875_ReadID(void)
000000  b510              PUSH     {r4,lr}
;;;89     {
;;;90     	return RA8875_ReadReg(0x00);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       RA8875_ReadReg
;;;91     }
000008  bd10              POP      {r4,pc}
;;;92     
                          ENDP


                          AREA ||i.RA8875_ReadReg||, CODE, READONLY, ALIGN=2

                  RA8875_ReadReg PROC
;;;254    */
;;;255    static uint8_t RA8875_ReadReg(uint8_t _ucRegAddr)
000000  4601              MOV      r1,r0
;;;256    {
;;;257    #ifdef IF_SPI_EN	/* 四线SPI */
;;;258    	uint8_t value;
;;;259    
;;;260    	RA8875_CS_0();
;;;261    	SPI_ShiftByte(SPI_WRITE_CMD);
;;;262    	SPI_ShiftByte(_ucRegAddr);
;;;263    	RA8875_CS_1();
;;;264    
;;;265    	RA8875_CS_0();
;;;266    	SPI_ShiftByte(SPI_READ_DATA);
;;;267    	value = SPI_ShiftByte(0x00);
;;;268    	RA8875_CS_1();
;;;269    
;;;270    	return value;
;;;271    #else	/* 8080 总线 */
;;;272    	uint8_t value;
;;;273    
;;;274    	RA8875_REG = _ucRegAddr;/* 设置寄存器地址 */
000002  4a03              LDR      r2,|L35.16|
000004  8011              STRH     r1,[r2,#0]
;;;275    	value = RA8875_RAM;		/* 读取寄存器值 */
000006  f04f42c0          MOV      r2,#0x60000000
00000a  8812              LDRH     r2,[r2,#0]
00000c  b2d0              UXTB     r0,r2
;;;276    
;;;277    	return value;
;;;278    #endif
;;;279    }
00000e  4770              BX       lr
;;;280    
                          ENDP

                  |L35.16|
                          DCD      0x60080000

                          AREA ||i.RA8875_ReadStatus||, CODE, READONLY, ALIGN=2

                  RA8875_ReadStatus PROC
;;;288    */
;;;289    static uint8_t RA8875_ReadStatus(void)
000000  4901              LDR      r1,|L36.8|
;;;290    {
;;;291    #ifdef IF_SPI_EN	/* 四线SPI */
;;;292    	uint8_t value;
;;;293    
;;;294    	RA8875_CS_0();
;;;295    	SPI_ShiftByte(SPI_READ_STATUS);
;;;296    	value = SPI_ShiftByte(0x00);
;;;297    	RA8875_CS_1();
;;;298    
;;;299    	return value;
;;;300    #else	/* 8080 总线 */
;;;301    	uint8_t value;
;;;302    
;;;303    	value = RA8875_REG;
000002  8809              LDRH     r1,[r1,#0]
000004  b2c8              UXTB     r0,r1
;;;304    
;;;305    	return value;
;;;306    #endif
;;;307    }
000006  4770              BX       lr
;;;308    
                          ENDP

                  |L36.8|
                          DCD      0x60080000

                          AREA ||i.RA8875_SetBackColor||, CODE, READONLY, ALIGN=2

                  RA8875_SetBackColor PROC
;;;677    */
;;;678    void RA8875_SetBackColor(uint16_t _usColor)
000000  b510              PUSH     {r4,lr}
;;;679    {
000002  4604              MOV      r4,r0
;;;680    	s_ucRA8875Busy = 1;
000004  2001              MOVS     r0,#1
000006  490a              LDR      r1,|L37.48|
000008  7008              STRB     r0,[r1,#0]
;;;681    	RA8875_WriteReg(0x60, (_usColor & 0xF800) >> 11);	/* R5  */
00000a  0ae1              LSRS     r1,r4,#11
00000c  2060              MOVS     r0,#0x60
00000e  f7fffffe          BL       RA8875_WriteReg
;;;682    	RA8875_WriteReg(0x61, (_usColor & 0x07E0) >> 5);	/* G6 */
000012  f3c41145          UBFX     r1,r4,#5,#6
000016  2061              MOVS     r0,#0x61
000018  f7fffffe          BL       RA8875_WriteReg
;;;683    	RA8875_WriteReg(0x62, (_usColor & 0x001F));			/* B5 */
00001c  f004011f          AND      r1,r4,#0x1f
000020  2062              MOVS     r0,#0x62
000022  f7fffffe          BL       RA8875_WriteReg
;;;684    	s_ucRA8875Busy = 0;
000026  2000              MOVS     r0,#0
000028  4901              LDR      r1,|L37.48|
00002a  7008              STRB     r0,[r1,#0]
;;;685    }
00002c  bd10              POP      {r4,pc}
;;;686    
                          ENDP

00002e  0000              DCW      0x0000
                  |L37.48|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_SetBackLight||, CODE, READONLY, ALIGN=1

                  RA8875_SetBackLight PROC
;;;1768   */
;;;1769   void RA8875_SetBackLight(uint8_t _bright)
000000  b510              PUSH     {r4,lr}
;;;1770   {
000002  4604              MOV      r4,r0
;;;1771   	if (_bright == 0)
000004  b924              CBNZ     r4,|L38.16|
;;;1772   	{
;;;1773   		/* 关闭PWM, PWM1引脚缺省输出LOW  */
;;;1774   		RA8875_WriteReg(0x8A, 0 << 6);
000006  2100              MOVS     r1,#0
000008  208a              MOVS     r0,#0x8a
00000a  f7fffffe          BL       RA8875_WriteReg
00000e  e00e              B        |L38.46|
                  |L38.16|
;;;1775   	}
;;;1776   	else if (_bright == BRIGHT_MAX)	/* 最大亮度 */
000010  2cff              CMP      r4,#0xff
000012  d104              BNE      |L38.30|
;;;1777   	{
;;;1778   		/* 关闭PWM, PWM1引脚缺省输出HIGH */
;;;1779   		RA8875_WriteReg(0x8A, 1 << 6);
000014  2140              MOVS     r1,#0x40
000016  208a              MOVS     r0,#0x8a
000018  f7fffffe          BL       RA8875_WriteReg
00001c  e007              B        |L38.46|
                  |L38.30|
;;;1780   	}
;;;1781   	else
;;;1782   	{
;;;1783   		/* 使能PWM1, 进行占空比调节 */
;;;1784   
;;;1785   		/* 	REG[8Ah] PWM1 Control Register (P1CR)
;;;1786   
;;;1787   			Bit7 脉波宽度调变 (PWM1) 设定
;;;1788   				0 : 关闭，此状态下，PWM1 输出准位依照此缓存器Bit6 决定。
;;;1789   				1 : 开启。
;;;1790   
;;;1791   			Bit6 PWM1 关闭时的准位
;;;1792   				0 : 当PWM 关闭或于睡眠模式时，PWM1 输出为”Low” 状态。
;;;1793   				1 : 当PWM 关闭或于睡眠模式时，PWM1 输出为”High” 状态。
;;;1794   
;;;1795   			Bit5 保留
;;;1796   
;;;1797   			Bit4 PWM1 功能选择
;;;1798   				0 : PWM1 功能。
;;;1799   				1 : PWM1 固定输出一频率为外部晶体振荡器Clock (Fin) 频率 1 /16 的Clock
;;;1800   
;;;1801   			Bit3-0  PWM1 电路的频率来源选择PWM_CLK	【不是PWM输出频率】
;;;1802   				0000b : SYS_CLK / 1   , 1000b : SYS_CLK / 256
;;;1803   				0001b : SYS_CLK / 2   , 1001b : SYS_CLK / 512
;;;1804   				0010b : SYS_CLK / 4   , 1010b : SYS_CLK / 1024
;;;1805   				0011b : SYS_CLK / 8   , 1011b : SYS_CLK / 2048
;;;1806   				0100b : SYS_CLK / 16  , 1100b : SYS_CLK / 4096
;;;1807   				0101b : SYS_CLK / 32  , 1101b : SYS_CLK / 8192
;;;1808   				0110b : SYS_CLK / 64  , 1110b : SYS_CLK / 16384
;;;1809   				0111b : SYS_CLK / 128 , 1111b : SYS_CLK / 32768
;;;1810   
;;;1811   				“SYS_CLK” 代表系统频率， 例如SYS_CLK 为20MHz， 当Bit[3:0] =0001b 时，PWM1 频率来源为10MHz。
;;;1812   				实际输出的PWM频率还需要除以 256，支持8位的分辨率。
;;;1813   
;;;1814   				安富莱的4.3寸(480*272)模块，SYS_CLK =  68.75MHz
;;;1815   				安富莱的7.0寸(800*480)模块，SYS_CLK =  81.25MHz
;;;1816   
;;;1817   				为了避免音频噪声，PWM频率可以选择
;;;1818   				（1） 低频100Hz
;;;1819   				（2） 高于 20KHz
;;;1820   
;;;1821   				比如，Bit3-0为0011b时 SYS_CLK / 8，
;;;1822   					4.3寸 输出的PWM频率为 (68.75MHz / 8) / 256 = 33.56KHz
;;;1823   					7寸 输出的PWM频率为 (81.25MHz / 8) / 256 = 39.67KHz
;;;1824   		*/
;;;1825   
;;;1826   		// RA8875_WriteReg(0x8A, (1 << 7) | 3);   5寸和7寸新屏可以用 3 ，高频PWM, 4.3寸不行
;;;1827   		RA8875_WriteReg(0x8A, (1 << 7) | 12); 
00001e  218c              MOVS     r1,#0x8c
000020  208a              MOVS     r0,#0x8a
000022  f7fffffe          BL       RA8875_WriteReg
;;;1828   
;;;1829   		/* REG[8Bh] PWM1 Duty Cycle Register (P1DCR) */
;;;1830   		RA8875_WriteReg(0x8B, _bright);
000026  4621              MOV      r1,r4
000028  208b              MOVS     r0,#0x8b
00002a  f7fffffe          BL       RA8875_WriteReg
                  |L38.46|
;;;1831   	}
;;;1832   }
00002e  bd10              POP      {r4,pc}
;;;1833   
                          ENDP


                          AREA ||i.RA8875_SetCursor||, CODE, READONLY, ALIGN=1

                  RA8875_SetCursor PROC
;;;1689   */
;;;1690   void RA8875_SetCursor(uint16_t _usX, uint16_t _usY)
000000  b570              PUSH     {r4-r6,lr}
;;;1691   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1692   	/* 设置内存写光标的坐标 【注意0x80-83 是光标图形的坐标】 */
;;;1693   	RA8875_WriteReg(0x46, _usX);
000006  b2e1              UXTB     r1,r4
000008  2046              MOVS     r0,#0x46
00000a  f7fffffe          BL       RA8875_WriteReg
;;;1694   	RA8875_WriteReg(0x47, _usX >> 8);
00000e  1221              ASRS     r1,r4,#8
000010  2047              MOVS     r0,#0x47
000012  f7fffffe          BL       RA8875_WriteReg
;;;1695   	RA8875_WriteReg(0x48, _usY);
000016  b2e9              UXTB     r1,r5
000018  2048              MOVS     r0,#0x48
00001a  f7fffffe          BL       RA8875_WriteReg
;;;1696   	RA8875_WriteReg(0x49, _usY >> 8);
00001e  1229              ASRS     r1,r5,#8
000020  2049              MOVS     r0,#0x49
000022  f7fffffe          BL       RA8875_WriteReg
;;;1697   }
000026  bd70              POP      {r4-r6,pc}
;;;1698   
                          ENDP


                          AREA ||i.RA8875_SetDispWin||, CODE, READONLY, ALIGN=2

                  RA8875_SetDispWin PROC
;;;1635   */
;;;1636   void RA8875_SetDispWin(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1637   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1638   
;;;1639   	uint16_t usTemp;
;;;1640   
;;;1641   	/* 坐标系统示意图： （横屏）
;;;1642   			 -----------------------------
;;;1643   			|(0,0)                        |
;;;1644   			|     --------->              |
;;;1645   			|         |                   |
;;;1646   			|         |                   |
;;;1647   			|         |                   |
;;;1648   			|         V                   |
;;;1649   			|     --------->              |
;;;1650   			|                    (479,271)|
;;;1651   			 -----------------------------
;;;1652   
;;;1653   		左上角是坐标零点, 扫描方向，先从左到右，再从上到下。
;;;1654   
;;;1655   		如果需要做竖屏方式，你需要进行物理坐标和逻辑坐标的转换
;;;1656   	*/
;;;1657   
;;;1658   	RA8875_WriteReg(0x30, _usX);
00000c  b2e1              UXTB     r1,r4
00000e  2030              MOVS     r0,#0x30
000010  f7fffffe          BL       RA8875_WriteReg
;;;1659       RA8875_WriteReg(0x31, _usX >> 8);
000014  1221              ASRS     r1,r4,#8
000016  2031              MOVS     r0,#0x31
000018  f7fffffe          BL       RA8875_WriteReg
;;;1660   
;;;1661   	RA8875_WriteReg(0x32, _usY);
00001c  b2e9              UXTB     r1,r5
00001e  2032              MOVS     r0,#0x32
000020  f7fffffe          BL       RA8875_WriteReg
;;;1662       RA8875_WriteReg(0x33, _usY >> 8);
000024  1229              ASRS     r1,r5,#8
000026  2033              MOVS     r0,#0x33
000028  f7fffffe          BL       RA8875_WriteReg
;;;1663   
;;;1664   	usTemp = _usWidth + _usX - 1;
00002c  eb080004          ADD      r0,r8,r4
000030  1e40              SUBS     r0,r0,#1
000032  b286              UXTH     r6,r0
;;;1665   	RA8875_WriteReg(0x34, usTemp);
000034  b2f1              UXTB     r1,r6
000036  2034              MOVS     r0,#0x34
000038  f7fffffe          BL       RA8875_WriteReg
;;;1666       RA8875_WriteReg(0x35, usTemp >> 8);
00003c  1231              ASRS     r1,r6,#8
00003e  2035              MOVS     r0,#0x35
000040  f7fffffe          BL       RA8875_WriteReg
;;;1667   
;;;1668   	usTemp = _usHeight + _usY - 1;
000044  1978              ADDS     r0,r7,r5
000046  1e40              SUBS     r0,r0,#1
000048  b286              UXTH     r6,r0
;;;1669   	RA8875_WriteReg(0x36, usTemp);
00004a  b2f1              UXTB     r1,r6
00004c  2036              MOVS     r0,#0x36
00004e  f7fffffe          BL       RA8875_WriteReg
;;;1670       RA8875_WriteReg(0x37, usTemp >> 8);
000052  1231              ASRS     r1,r6,#8
000054  2037              MOVS     r0,#0x37
000056  f7fffffe          BL       RA8875_WriteReg
;;;1671   
;;;1672   	RA8875_SetCursor(_usX, _usY);
00005a  4629              MOV      r1,r5
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       RA8875_SetCursor
;;;1673   
;;;1674   	/* 保存当前窗口信息，提高以后单色填充操作的效率.
;;;1675   	另外一种做法是通过读取0x30-0x37寄存器获得当前窗口，不过效率较低 */
;;;1676   	s_WinX = _usX;
000062  4805              LDR      r0,|L40.120|
000064  8004              STRH     r4,[r0,#0]
;;;1677   	s_WinY = _usY;
000066  4805              LDR      r0,|L40.124|
000068  8005              STRH     r5,[r0,#0]
;;;1678   	s_WinHeight = _usHeight;
00006a  4805              LDR      r0,|L40.128|
00006c  8007              STRH     r7,[r0,#0]
;;;1679   	s_WinWidth = _usWidth;
00006e  4805              LDR      r0,|L40.132|
000070  f8a08000          STRH     r8,[r0,#0]
;;;1680   }
000074  e8bd81f0          POP      {r4-r8,pc}
;;;1681   
                          ENDP

                  |L40.120|
                          DCD      s_WinX
                  |L40.124|
                          DCD      s_WinY
                  |L40.128|
                          DCD      s_WinHeight
                  |L40.132|
                          DCD      s_WinWidth

                          AREA ||i.RA8875_SetFont||, CODE, READONLY, ALIGN=1

                  RA8875_SetFont PROC
;;;1414   */
;;;1415   void RA8875_SetFont(uint8_t _ucFontType, uint8_t _ucLineSpace, uint8_t _ucCharSpace)
000000  b570              PUSH     {r4-r6,lr}
;;;1416   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;1417   	/*
;;;1418   		[29H]在文字模式下，用来设定文字间的行距 (单位: 像素) 。
;;;1419   		只有低5个bit有效，0-31
;;;1420   	*/
;;;1421   	if (_ucLineSpace >31)
000008  2e1f              CMP      r6,#0x1f
00000a  dd00              BLE      |L41.14|
;;;1422   	{
;;;1423   		_ucLineSpace = 31;
00000c  261f              MOVS     r6,#0x1f
                  |L41.14|
;;;1424   	}
;;;1425   	RA8875_WriteReg(0x29, _ucLineSpace);
00000e  4631              MOV      r1,r6
000010  2029              MOVS     r0,#0x29
000012  f7fffffe          BL       RA8875_WriteReg
;;;1426   
;;;1427   	/*
;;;1428   		[2EH] 设置字符间距（像素单位，0-63），和字体（16*16，24*24，32*32）
;;;1429   	*/
;;;1430   	if (_ucCharSpace > 63)
000016  2d3f              CMP      r5,#0x3f
000018  dd00              BLE      |L41.28|
;;;1431   	{
;;;1432   		_ucCharSpace = 63;
00001a  253f              MOVS     r5,#0x3f
                  |L41.28|
;;;1433   	}
;;;1434   	if (_ucFontType > RA_FONT_32)
00001c  2c02              CMP      r4,#2
00001e  dd00              BLE      |L41.34|
;;;1435   	{
;;;1436   		_ucFontType = RA_FONT_16;
000020  2400              MOVS     r4,#0
                  |L41.34|
;;;1437   	}
;;;1438   	RA8875_WriteReg(0x2E, (_ucCharSpace & 0x3F) | (_ucFontType << 6));
000022  4628              MOV      r0,r5
000024  f364109f          BFI      r0,r4,#6,#26
000028  b2c1              UXTB     r1,r0
00002a  f04f002e          MOV      r0,#0x2e
00002e  f7fffffe          BL       RA8875_WriteReg
;;;1439   }
000032  bd70              POP      {r4-r6,pc}
;;;1440   
                          ENDP


                          AREA ||i.RA8875_SetFrontColor||, CODE, READONLY, ALIGN=2

                  RA8875_SetFrontColor PROC
;;;660    */
;;;661    void RA8875_SetFrontColor(uint16_t _usColor)
000000  b510              PUSH     {r4,lr}
;;;662    {
000002  4604              MOV      r4,r0
;;;663    	s_ucRA8875Busy = 1;
000004  2001              MOVS     r0,#1
000006  490a              LDR      r1,|L42.48|
000008  7008              STRB     r0,[r1,#0]
;;;664    	RA8875_WriteReg(0x63, (_usColor & 0xF800) >> 11);	/* R5  */
00000a  0ae1              LSRS     r1,r4,#11
00000c  2063              MOVS     r0,#0x63
00000e  f7fffffe          BL       RA8875_WriteReg
;;;665    	RA8875_WriteReg(0x64, (_usColor & 0x07E0) >> 5);	/* G6 */
000012  f3c41145          UBFX     r1,r4,#5,#6
000016  2064              MOVS     r0,#0x64
000018  f7fffffe          BL       RA8875_WriteReg
;;;666    	RA8875_WriteReg(0x65, (_usColor & 0x001F));			/* B5 */
00001c  f004011f          AND      r1,r4,#0x1f
000020  2065              MOVS     r0,#0x65
000022  f7fffffe          BL       RA8875_WriteReg
;;;667    	s_ucRA8875Busy = 0;
000026  2000              MOVS     r0,#0
000028  4901              LDR      r1,|L42.48|
00002a  7008              STRB     r0,[r1,#0]
;;;668    }
00002c  bd10              POP      {r4,pc}
;;;669    
                          ENDP

00002e  0000              DCW      0x0000
                  |L42.48|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_SetReadCursor||, CODE, READONLY, ALIGN=1

                  RA8875_SetReadCursor PROC
;;;1706   */
;;;1707   static void RA8875_SetReadCursor(uint16_t _usX, uint16_t _usY)
000000  b570              PUSH     {r4-r6,lr}
;;;1708   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1709   	/* 设置内存读光标的坐标 */
;;;1710   	RA8875_WriteReg(0x4A, _usX);
000006  b2e1              UXTB     r1,r4
000008  204a              MOVS     r0,#0x4a
00000a  f7fffffe          BL       RA8875_WriteReg
;;;1711   	RA8875_WriteReg(0x4B, _usX >> 8);
00000e  1221              ASRS     r1,r4,#8
000010  204b              MOVS     r0,#0x4b
000012  f7fffffe          BL       RA8875_WriteReg
;;;1712   	RA8875_WriteReg(0x4C, _usY);
000016  b2e9              UXTB     r1,r5
000018  204c              MOVS     r0,#0x4c
00001a  f7fffffe          BL       RA8875_WriteReg
;;;1713   	RA8875_WriteReg(0x4D, _usY >> 8);
00001e  1229              ASRS     r1,r5,#8
000020  204d              MOVS     r0,#0x4d
000022  f7fffffe          BL       RA8875_WriteReg
;;;1714   }
000026  bd70              POP      {r4-r6,pc}
;;;1715   
                          ENDP


                          AREA ||i.RA8875_SetTextCursor||, CODE, READONLY, ALIGN=1

                  RA8875_SetTextCursor PROC
;;;1723   */
;;;1724   static void RA8875_SetTextCursor(uint16_t _usX, uint16_t _usY)
000000  b570              PUSH     {r4-r6,lr}
;;;1725   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1726   	/* 设置内存读光标的坐标 */
;;;1727   	RA8875_WriteReg(0x2A, _usX);
000006  b2e1              UXTB     r1,r4
000008  202a              MOVS     r0,#0x2a
00000a  f7fffffe          BL       RA8875_WriteReg
;;;1728   	RA8875_WriteReg(0x2B, _usX >> 8);
00000e  1221              ASRS     r1,r4,#8
000010  202b              MOVS     r0,#0x2b
000012  f7fffffe          BL       RA8875_WriteReg
;;;1729   	RA8875_WriteReg(0x2C, _usY);
000016  b2e9              UXTB     r1,r5
000018  202c              MOVS     r0,#0x2c
00001a  f7fffffe          BL       RA8875_WriteReg
;;;1730   	RA8875_WriteReg(0x2D, _usY >> 8);
00001e  1229              ASRS     r1,r5,#8
000020  202d              MOVS     r0,#0x2d
000022  f7fffffe          BL       RA8875_WriteReg
;;;1731   }
000026  bd70              POP      {r4-r6,pc}
;;;1732   
                          ENDP


                          AREA ||i.RA8875_SetTextZoom||, CODE, READONLY, ALIGN=1

                  RA8875_SetTextZoom PROC
;;;1451   */
;;;1452   void RA8875_SetTextZoom(uint8_t _ucHSize, uint8_t _ucVSize)
000000  b570              PUSH     {r4-r6,lr}
;;;1453   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1454   	/*
;;;1455   		pdf 第22页		[22H]
;;;1456   		bit7 用于对齐，一般不用，缺省设0
;;;1457   		bit6 用于通透，一般不用，缺省设0
;;;1458   		bit4 用于旋转90读，一般不用，缺省设0
;;;1459   		bit3-2 水平放大倍数
;;;1460   		bit1-0 垂直放大倍数
;;;1461   	*/
;;;1462   	RA8875_WriteReg(0x22, ((_ucHSize & 0x03) << 2) | ( _ucVSize & 0x03));
000006  f0040203          AND      r2,r4,#3
00000a  4628              MOV      r0,r5
00000c  f362009f          BFI      r0,r2,#2,#30
000010  4601              MOV      r1,r0
000012  f04f0022          MOV      r0,#0x22
000016  f7fffffe          BL       RA8875_WriteReg
;;;1463   }
00001a  bd70              POP      {r4-r6,pc}
;;;1464   
                          ENDP


                          AREA ||i.RA8875_Sleep||, CODE, READONLY, ALIGN=1

                  RA8875_Sleep PROC
;;;973    */
;;;974    void RA8875_Sleep(void)
000000  b510              PUSH     {r4,lr}
;;;975    {
;;;976    	RA8875_SetBackLight(0);		/* 关闭背光 */
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       RA8875_SetBackLight
;;;977    
;;;978    	/* 设置TFT面板的 DISP  引脚为高，使能面板. 安富莱TFT模块的DISP引脚连接到RA8875芯片的GP0X脚 */
;;;979    	RA8875_WriteReg(0xC7, 0x00);	/* DISP = 0  */
000008  2100              MOVS     r1,#0
00000a  20c7              MOVS     r0,#0xc7
00000c  f7fffffe          BL       RA8875_WriteReg
;;;980    
;;;981    	RA8875_WriteReg(0x01, 0x01);
000010  2101              MOVS     r1,#1
000012  4608              MOV      r0,r1
000014  f7fffffe          BL       RA8875_WriteReg
;;;982    	RA8875_WriteReg(0x01, 0x00);
000018  2100              MOVS     r1,#0
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       RA8875_WriteReg
;;;983    
;;;984    	RA8875_WriteReg(0x01, 0x02);	/* RA8875 Sleep */
000020  2102              MOVS     r1,#2
000022  2001              MOVS     r0,#1
000024  f7fffffe          BL       RA8875_WriteReg
;;;985    }
000028  bd10              POP      {r4,pc}
;;;986    
                          ENDP


                          AREA ||i.RA8875_StartDirectDraw||, CODE, READONLY, ALIGN=2

                  RA8875_StartDirectDraw PROC
;;;1125   */
;;;1126   void RA8875_StartDirectDraw(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1127   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1128   	/* 设置图片的位置和大小， 即设置显示窗口 */
;;;1129   	RA8875_SetDispWin(_usX, _usY, _usHeight, _usWidth);
00000c  463b              MOV      r3,r7
00000e  4632              MOV      r2,r6
000010  4629              MOV      r1,r5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       RA8875_SetDispWin
;;;1130   
;;;1131   	s_ucRA8875Busy = 1;
000018  2001              MOVS     r0,#1
00001a  4903              LDR      r1,|L47.40|
00001c  7008              STRB     r0,[r1,#0]
;;;1132   
;;;1133   	RA8875_WriteCmd(0x02); 		/* 准备读写显存 */
00001e  2002              MOVS     r0,#2
000020  f7fffffe          BL       RA8875_WriteCmd
;;;1134   
;;;1135   	/* 之后，应用程序可以直接绘图 */
;;;1136   }
000024  e8bd81f0          POP      {r4-r8,pc}
;;;1137   
                          ENDP

                  |L47.40|
                          DCD      s_ucRA8875Busy

                          AREA ||i.RA8875_TouchInit||, CODE, READONLY, ALIGN=1

                  RA8875_TouchInit PROC
;;;803    */
;;;804    void RA8875_TouchInit(void)
000000  b510              PUSH     {r4,lr}
;;;805    {
;;;806    	RA8875_WriteReg(0xF0, (1 << 2));	/* 开启触控面板中断位 */
000002  2104              MOVS     r1,#4
000004  20f0              MOVS     r0,#0xf0
000006  f7fffffe          BL       RA8875_WriteReg
;;;807    
;;;808    	/*
;;;809    		REG[71h] Touch Panel Control Register 1 (TPCR1)
;;;810    
;;;811    		Bit7 N/A
;;;812    		Bit6 触控面板模式设定
;;;813    			0 : 自动模式。
;;;814    			1 : 手动模式。
;;;815    		Bit5 触控面板控制器ADC 参考电压(Vref)来源设定
;;;816    			0 : 内部产生参考电压。
;;;817    			1 : 外部输入参考电压，ADC 参考电压准位= 1/2 VDD。
;;;818    		Bit4-3 N/A
;;;819    		Bit2 触控中断讯号的消除弹跳电路选择
;;;820    			0: 关闭消除弹跳电路。
;;;821    			1: 开启消除弹跳电路。
;;;822    		Bit1-0 触控面板手动模式之选择位
;;;823    			00b : 闲置模式。触控控制单元进入闲置模式。
;;;824    			01b : 侦测触摸事件发生。在此模式控制器会侦测触摸事件的发
;;;825    				生，事件发生可以引发中断或是由缓存器得知(REG[F1h]
;;;826    				Bit2)。
;;;827    			10b : X 轴数据撷取模式。在此模式触摸位置的X 轴数据会被储
;;;828    				存至 REG[72h] 和REG[74h]。
;;;829    			11b : Y 轴数据撷取模式。在此模式触摸位置的Y 轴数据会被储
;;;830    				存至REG[73h] and REG[74h]。
;;;831    	*/
;;;832    	RA8875_WriteReg(0x71, (0 << 6) | (0 << 5) | (1 << 2));	/* 选择自动模式 */
00000a  2104              MOVS     r1,#4
00000c  2071              MOVS     r0,#0x71
00000e  f7fffffe          BL       RA8875_WriteReg
;;;833    
;;;834    	/*
;;;835    		REG[70h] Touch Panel Control Register 0 (TPCR0)
;;;836    
;;;837    		Bit7 触控面板功能设定
;;;838    			0 : 关闭。
;;;839    			1 : 开启。
;;;840    		Bit6-4 触控面板控制器取样时间设定
;;;841    			000b : ADC 取样时间为512 个系统频率周期。
;;;842    			001b : ADC 取样时间为 1024 个系统频率周期。
;;;843    			010b : ADC 取样时间为 2048 个系统频率周期。
;;;844    			011b : ADC 取样时间为 4096 个系统频率周期。
;;;845    			100b : ADC 取样时间为 8192 个系统频率周期。
;;;846    			101b : ADC 取样时间为 16384 个系统频率周期。
;;;847    			110b : ADC 取样时间为 32768 个系统频率周期。
;;;848    			111b : ADC 取样时间为65536 个系统频率周期。
;;;849    		Bit3 触控面板唤醒模式
;;;850    			0 : 关闭触控事件唤醒模式。
;;;851    			1 : 触控事件可唤醒睡眠模式。
;;;852    		Bit2-0 触控面板控制器ADC 频率设定
;;;853    			000b : 系统频率。
;;;854    			001b : 系统频率 / 2。
;;;855    			010b : 系统频率 / 4。
;;;856    			011b : 系统频率 / 8。
;;;857    			100b : 系统频率 / 16。
;;;858    			101b : 系统频率 / 32。
;;;859    			110b : 系统频率 / 64。
;;;860    			111b : 系统频率 / 128。
;;;861    
;;;862    		注 : ADC 的输入频率设定不能超过10MHz。
;;;863    	*/
;;;864    	RA8875_WriteReg(0x70, (1 << 7) | (2 << 4) | (0 << 3) | (4 << 0));	/* 开启触摸功能； */
000012  21a4              MOVS     r1,#0xa4
000014  2070              MOVS     r0,#0x70
000016  f7fffffe          BL       RA8875_WriteReg
;;;865    }
00001a  bd10              POP      {r4,pc}
;;;866    
                          ENDP


                          AREA ||i.RA8875_TouchReadX||, CODE, READONLY, ALIGN=2

                  RA8875_TouchReadX PROC
;;;874    */
;;;875    uint16_t RA8875_TouchReadX(void)
000000  b570              PUSH     {r4-r6,lr}
;;;876    {
;;;877    	uint16_t usAdc;
;;;878    	uint8_t ucRegValue;
;;;879    	uint8_t ucReg74;
;;;880    
;;;881    	/* 软件读取中断事件标志 */
;;;882    	ucRegValue = RA8875_ReadReg(0xF1);
000002  20f1              MOVS     r0,#0xf1
000004  f7fffffe          BL       RA8875_ReadReg
000008  4606              MOV      r6,r0
;;;883    	if (ucRegValue & (1 << 2))
00000a  f0160f04          TST      r6,#4
00000e  d01e              BEQ      |L49.78|
;;;884    	{
;;;885    		ucReg74 = RA8875_ReadReg(0x74);
000010  2074              MOVS     r0,#0x74
000012  f7fffffe          BL       RA8875_ReadReg
000016  4605              MOV      r5,r0
;;;886    		usAdc = RA8875_ReadReg(0x72);	/* Bit9-2 */
000018  2072              MOVS     r0,#0x72
00001a  f7fffffe          BL       RA8875_ReadReg
00001e  4604              MOV      r4,r0
;;;887    		usAdc <<= 2;
000020  f64f70ff          MOV      r0,#0xffff
000024  ea000484          AND      r4,r0,r4,LSL #2
;;;888    		usAdc += (ucReg74 & 0x03);
000028  f0050003          AND      r0,r5,#3
00002c  4404              ADD      r4,r4,r0
;;;889    
;;;890    		s_usTouchX = usAdc;
00002e  4811              LDR      r0,|L49.116|
000030  8004              STRH     r4,[r0,#0]
;;;891    
;;;892    		usAdc = RA8875_ReadReg(0x73);	/* Bit9-2 */
000032  2073              MOVS     r0,#0x73
000034  f7fffffe          BL       RA8875_ReadReg
000038  4604              MOV      r4,r0
;;;893    		usAdc <<= 2;
00003a  f64f70ff          MOV      r0,#0xffff
00003e  ea000484          AND      r4,r0,r4,LSL #2
;;;894    		usAdc += ((ucReg74 & 0x0C) >> 2);
000042  f3c50081          UBFX     r0,r5,#2,#2
000046  4404              ADD      r4,r4,r0
;;;895    
;;;896    		s_usTouchY = usAdc;
000048  480b              LDR      r0,|L49.120|
00004a  8004              STRH     r4,[r0,#0]
00004c  e004              B        |L49.88|
                  |L49.78|
;;;897    	}
;;;898    	else
;;;899    	{
;;;900    		s_usTouchX = 0;
00004e  2000              MOVS     r0,#0
000050  4908              LDR      r1,|L49.116|
000052  8008              STRH     r0,[r1,#0]
;;;901    		s_usTouchY = 0;
000054  4908              LDR      r1,|L49.120|
000056  8008              STRH     r0,[r1,#0]
                  |L49.88|
;;;902    	}
;;;903    
;;;904    	/*
;;;905    		bit2 写入功能?? 触控面板中断清除位
;;;906    		0 : 未操作。
;;;907    		1 : 清除触控面板中断。
;;;908    		读取功能?? 触控面板中断状态
;;;909    		0 : 未发生触控面板中断。
;;;910    		1 : 发生触控面板中断。
;;;911    	*/
;;;912    
;;;913    	/*
;;;914    		不要调用这个函数写寄存器，因为该函数改写了busy标志
;;;915    		RA8875_WriteReg(0xF1, (1 << 2));	 必须清除， 才会下次采样.
;;;916    	*/
;;;917    	RA8875_WriteCmd(0xF1);
000058  20f1              MOVS     r0,#0xf1
00005a  f7fffffe          BL       RA8875_WriteCmd
;;;918    	RA8875_WriteData(1 << 2);
00005e  2004              MOVS     r0,#4
000060  f7fffffe          BL       RA8875_WriteData
;;;919    	
;;;920    	/* 延时函数不能省略 */
;;;921    	RA8875_Delaly200us();
000064  f7fffffe          BL       RA8875_Delaly200us
;;;922    	RA8875_Delaly200us();
000068  f7fffffe          BL       RA8875_Delaly200us
;;;923    	
;;;924    	return s_usTouchX;
00006c  4801              LDR      r0,|L49.116|
00006e  8800              LDRH     r0,[r0,#0]  ; s_usTouchX
;;;925    }
000070  bd70              POP      {r4-r6,pc}
;;;926    
                          ENDP

000072  0000              DCW      0x0000
                  |L49.116|
                          DCD      s_usTouchX
                  |L49.120|
                          DCD      s_usTouchY

                          AREA ||i.RA8875_TouchReadY||, CODE, READONLY, ALIGN=2

                  RA8875_TouchReadY PROC
;;;934    */
;;;935    uint16_t RA8875_TouchReadY(void)
000000  4801              LDR      r0,|L50.8|
;;;936    {
;;;937    	return s_usTouchY;
000002  8800              LDRH     r0,[r0,#0]  ; s_usTouchY
;;;938    }
000004  4770              BX       lr
;;;939    
                          ENDP

000006  0000              DCW      0x0000
                  |L50.8|
                          DCD      s_usTouchY

                          AREA ||i.RA8875_WaitBusy||, CODE, READONLY, ALIGN=1

                  RA8875_WaitBusy PROC
;;;742    */
;;;743    void RA8875_WaitBusy(void)
000000  b510              PUSH     {r4,lr}
;;;744    {
;;;745    	while ((RA8875_ReadStatus() & 0x80) == 0x80);
000002  bf00              NOP      
                  |L51.4|
000004  f7fffffe          BL       RA8875_ReadStatus
000008  f0000080          AND      r0,r0,#0x80
00000c  2880              CMP      r0,#0x80
00000e  d0f9              BEQ      |L51.4|
;;;746    }
000010  bd10              POP      {r4,pc}
;;;747    
                          ENDP


                          AREA ||i.RA8875_WriteCmd||, CODE, READONLY, ALIGN=2

                  RA8875_WriteCmd PROC
;;;100    */
;;;101    static void RA8875_WriteCmd(uint8_t _ucRegAddr)
000000  4901              LDR      r1,|L52.8|
;;;102    {
;;;103    #ifdef IF_SPI_EN	/* 四线SPI */
;;;104    	RA8875_CS_0();
;;;105    	SPI_ShiftByte(SPI_WRITE_CMD);
;;;106    	SPI_ShiftByte(_ucRegAddr);
;;;107    	RA8875_CS_1();
;;;108    
;;;109    #else	/* 8080 总线 */
;;;110    	RA8875_REG = _ucRegAddr;	/* 设置寄存器地址 */
000002  8008              STRH     r0,[r1,#0]
;;;111    #endif
;;;112    }
000004  4770              BX       lr
;;;113    
                          ENDP

000006  0000              DCW      0x0000
                  |L52.8|
                          DCD      0x60080000

                          AREA ||i.RA8875_WriteData||, CODE, READONLY, ALIGN=1

                  RA8875_WriteData PROC
;;;121    */
;;;122    static void RA8875_WriteData(uint8_t _ucRegValue)
000000  f04f41c0          MOV      r1,#0x60000000
;;;123    {
;;;124    #ifdef IF_SPI_EN	/* 四线SPI */
;;;125    	RA8875_CS_0();
;;;126    	SPI_ShiftByte(SPI_WRITE_DATA);
;;;127    	SPI_ShiftByte(_ucRegValue);
;;;128    	RA8875_CS_1();
;;;129    
;;;130    #else	/* 8080 总线 */
;;;131    	RA8875_RAM = _ucRegValue;	/* 设置寄存器地址 */
000004  8008              STRH     r0,[r1,#0]
;;;132    #endif
;;;133    }
000006  4770              BX       lr
;;;134    
                          ENDP


                          AREA ||i.RA8875_WriteData16||, CODE, READONLY, ALIGN=1

                  RA8875_WriteData16 PROC
;;;170    */
;;;171    static void RA8875_WriteData16(uint16_t _usRGB)
000000  f04f41c0          MOV      r1,#0x60000000
;;;172    {
;;;173    #ifdef IF_SPI_EN	/* 四线SPI */
;;;174    	RA8875_CS_0();
;;;175    	SPI_ShiftByte(SPI_WRITE_DATA);
;;;176    	SPI_ShiftByte(_usRGB >> 8);
;;;177    	RA8875_CS_1();
;;;178    
;;;179    	RA8875_CS_0();
;;;180    	SPI_ShiftByte(SPI_WRITE_DATA);
;;;181    	SPI_ShiftByte(_usRGB);
;;;182    	RA8875_CS_1();
;;;183    
;;;184    #else	/* 8080 总线 */
;;;185    	RA8875_RAM = _usRGB;	/* 设置寄存器地址 */
000004  8008              STRH     r0,[r1,#0]
;;;186    #endif
;;;187    }
000006  4770              BX       lr
;;;188    
                          ENDP


                          AREA ||i.RA8875_WriteReg||, CODE, READONLY, ALIGN=2

                  RA8875_WriteReg PROC
;;;224    */
;;;225    static void RA8875_WriteReg(uint8_t _ucRegAddr, uint8_t _ucRegValue)
000000  2201              MOVS     r2,#1
;;;226    {
;;;227    #ifdef IF_SPI_EN	/* 四线SPI */
;;;228    	s_ucRA8875Busy = 1;
;;;229    	RA8875_CS_0();
;;;230    	SPI_ShiftByte(SPI_WRITE_CMD);
;;;231    	SPI_ShiftByte(_ucRegAddr);
;;;232    	RA8875_CS_1();
;;;233    
;;;234    	RA8875_CS_0();
;;;235    	SPI_ShiftByte(SPI_WRITE_DATA);
;;;236    	SPI_ShiftByte(_ucRegValue);
;;;237    	RA8875_CS_1();
;;;238    	s_ucRA8875Busy = 0;
;;;239    #else	/* 8080 总线 */
;;;240    	s_ucRA8875Busy = 1;
000002  4b05              LDR      r3,|L55.24|
000004  701a              STRB     r2,[r3,#0]
;;;241    	RA8875_REG = _ucRegAddr;	/* 设置寄存器地址 */
000006  4a05              LDR      r2,|L55.28|
000008  8010              STRH     r0,[r2,#0]
;;;242    	RA8875_RAM = _ucRegValue;	/* 写入寄存器值 */
00000a  f04f42c0          MOV      r2,#0x60000000
00000e  8011              STRH     r1,[r2,#0]
;;;243    	s_ucRA8875Busy = 0;
000010  2200              MOVS     r2,#0
000012  701a              STRB     r2,[r3,#0]
;;;244    #endif
;;;245    }
000014  4770              BX       lr
;;;246    
                          ENDP

000016  0000              DCW      0x0000
                  |L55.24|
                          DCD      s_ucRA8875Busy
                  |L55.28|
                          DCD      0x60080000

                          AREA ||.data||, DATA, ALIGN=1

                  s_ucRA8875Busy
000000  0000              DCB      0x00,0x00
                  s_WinX
000002  0000              DCW      0x0000
                  s_WinY
000004  0000              DCW      0x0000
                  s_WinHeight
000006  0110              DCW      0x0110
                  s_WinWidth
000008  01e0              DCW      0x01e0
                  s_usTouchX
00000a  0000              DCB      0x00,0x00
                  s_usTouchY
00000c  0000              DCB      0x00,0x00
                  g_ucGPIX
00000e  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\LCD_RA8875.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_LCD_RA8875_c_fad3ed70____REV16|
#line 129 "D:\\Keil_v4\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_LCD_RA8875_c_fad3ed70____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_LCD_RA8875_c_fad3ed70____REVSH|
#line 144
|__asm___12_LCD_RA8875_c_fad3ed70____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
